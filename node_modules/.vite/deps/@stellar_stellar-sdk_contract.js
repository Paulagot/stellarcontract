import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_api,
  require_lib,
  require_rpc,
  require_transaction
} from "./chunk-TD56FCTW.js";
import "./chunk-B6WC3SW2.js";
import "./chunk-YB5CVH6L.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-KI2BRAH6.js";

// node_modules/@stellar/stellar-sdk/lib/contract/rust_result.js
var require_rust_result = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/contract/rust_result.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Ok = exports.Err = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Ok = exports.Ok = function() {
      function Ok2(value) {
        _classCallCheck(this, Ok2);
        this.value = value;
      }
      return _createClass(Ok2, [{
        key: "unwrapErr",
        value: function unwrapErr() {
          throw new Error("No error");
        }
      }, {
        key: "unwrap",
        value: function unwrap() {
          return this.value;
        }
      }, {
        key: "isOk",
        value: function isOk() {
          return true;
        }
      }, {
        key: "isErr",
        value: function isErr() {
          return false;
        }
      }]);
    }();
    var Err = exports.Err = function() {
      function Err2(error) {
        _classCallCheck(this, Err2);
        this.error = error;
      }
      return _createClass(Err2, [{
        key: "unwrapErr",
        value: function unwrapErr() {
          return this.error;
        }
      }, {
        key: "unwrap",
        value: function unwrap() {
          throw new Error(this.error.message);
        }
      }, {
        key: "isOk",
        value: function isOk() {
          return false;
        }
      }, {
        key: "isErr",
        value: function isErr() {
          return true;
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/lib/contract/types.js
var require_types = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/contract/types.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NULL_ACCOUNT = exports.DEFAULT_TIMEOUT = void 0;
    var _stellarBase = require_lib();
    var DEFAULT_TIMEOUT = exports.DEFAULT_TIMEOUT = 5 * 60;
    var NULL_ACCOUNT = exports.NULL_ACCOUNT = "GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF";
  }
});

// node_modules/@stellar/stellar-sdk/lib/contract/utils.js
var require_utils = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/contract/utils.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.contractErrorPattern = void 0;
    exports.getAccount = getAccount;
    exports.implementsToString = implementsToString;
    exports.processSpecEntryStream = processSpecEntryStream;
    exports.withExponentialBackoff = withExponentialBackoff;
    var _stellarBase = require_lib();
    var _types = require_types();
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define({}, "");
      } catch (t2) {
        define = function define2(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
        return this;
      }), define(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function withExponentialBackoff(_x, _x2, _x3) {
      return _withExponentialBackoff.apply(this, arguments);
    }
    function _withExponentialBackoff() {
      _withExponentialBackoff = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(fn, keepWaitingIf, timeoutInSeconds) {
        var exponentialFactor, verbose, attempts, count, waitUntil, waitTime, totalWaitTime, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              exponentialFactor = _args.length > 3 && _args[3] !== void 0 ? _args[3] : 1.5;
              verbose = _args.length > 4 && _args[4] !== void 0 ? _args[4] : false;
              attempts = [];
              count = 0;
              _context.t0 = attempts;
              _context.next = 7;
              return fn();
            case 7:
              _context.t1 = _context.sent;
              _context.t0.push.call(_context.t0, _context.t1);
              if (keepWaitingIf(attempts[attempts.length - 1])) {
                _context.next = 11;
                break;
              }
              return _context.abrupt("return", attempts);
            case 11:
              waitUntil = new Date(Date.now() + timeoutInSeconds * 1e3).valueOf();
              waitTime = 1e3;
              totalWaitTime = waitTime;
            case 14:
              if (!(Date.now() < waitUntil && keepWaitingIf(attempts[attempts.length - 1]))) {
                _context.next = 30;
                break;
              }
              count += 1;
              if (verbose) {
                console.info("Waiting ".concat(waitTime, "ms before trying again (bringing the total wait time to ").concat(totalWaitTime, "ms so far, of total ").concat(timeoutInSeconds * 1e3, "ms)"));
              }
              _context.next = 19;
              return new Promise(function(res) {
                return setTimeout(res, waitTime);
              });
            case 19:
              waitTime *= exponentialFactor;
              if (new Date(Date.now() + waitTime).valueOf() > waitUntil) {
                waitTime = waitUntil - Date.now();
                if (verbose) {
                  console.info("was gonna wait too long; new waitTime: ".concat(waitTime, "ms"));
                }
              }
              totalWaitTime = waitTime + totalWaitTime;
              _context.t2 = attempts;
              _context.next = 25;
              return fn(attempts[attempts.length - 1]);
            case 25:
              _context.t3 = _context.sent;
              _context.t2.push.call(_context.t2, _context.t3);
              if (verbose && keepWaitingIf(attempts[attempts.length - 1])) {
                console.info("".concat(count, ". Called ").concat(fn, "; ").concat(attempts.length, " prev attempts. Most recent: ").concat(JSON.stringify(attempts[attempts.length - 1], null, 2)));
              }
              _context.next = 14;
              break;
            case 30:
              return _context.abrupt("return", attempts);
            case 31:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _withExponentialBackoff.apply(this, arguments);
    }
    var contractErrorPattern = exports.contractErrorPattern = /Error\(Contract, #(\d+)\)/;
    function implementsToString(obj) {
      return _typeof(obj) === "object" && obj !== null && "toString" in obj;
    }
    function processSpecEntryStream(buffer) {
      var reader = new _stellarBase.cereal.XdrReader(buffer);
      var res = [];
      while (!reader.eof) {
        res.push(_stellarBase.xdr.ScSpecEntry.read(reader));
      }
      return res;
    }
    function getAccount(_x4, _x5) {
      return _getAccount.apply(this, arguments);
    }
    function _getAccount() {
      _getAccount = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(options, server) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", options.publicKey ? server.getAccount(options.publicKey) : new _stellarBase.Account(_types.NULL_ACCOUNT, "0"));
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return _getAccount.apply(this, arguments);
    }
  }
});

// node_modules/@stellar/stellar-sdk/lib/contract/sent_transaction.js
var require_sent_transaction = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/contract/sent_transaction.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SentTransaction = void 0;
    var _rpc = require_rpc();
    var _api = require_api();
    var _utils = require_utils();
    var _types = require_types();
    var _SentTransaction;
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (null === t2 || !_isNativeFunction(t2)) return t2;
        if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t2)) return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return _construct(t2, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t2);
      }, _wrapNativeSuper(t);
    }
    function _construct(t, e, r) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define({}, "");
      } catch (t2) {
        define = function define2(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
        return this;
      }), define(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SentTransaction = exports.SentTransaction = function() {
      function SentTransaction2(assembled) {
        var _this = this, _this$assembled$optio2;
        _classCallCheck(this, SentTransaction2);
        _defineProperty(this, "send", _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
          var _this$assembled$optio;
          var hash, timeoutInSeconds;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.server.sendTransaction(_this.assembled.signed);
              case 2:
                _this.sendTransactionResponse = _context.sent;
                if (!(_this.sendTransactionResponse.status !== "PENDING")) {
                  _context.next = 5;
                  break;
                }
                throw new SentTransaction2.Errors.SendFailed("Sending the transaction to the network failed!\n".concat(JSON.stringify(_this.sendTransactionResponse, null, 2)));
              case 5:
                hash = _this.sendTransactionResponse.hash;
                timeoutInSeconds = (_this$assembled$optio = _this.assembled.options.timeoutInSeconds) !== null && _this$assembled$optio !== void 0 ? _this$assembled$optio : _types.DEFAULT_TIMEOUT;
                _context.next = 9;
                return (0, _utils.withExponentialBackoff)(function() {
                  return _this.server.getTransaction(hash);
                }, function(resp) {
                  return resp.status === _api.Api.GetTransactionStatus.NOT_FOUND;
                }, timeoutInSeconds);
              case 9:
                _this.getTransactionResponseAll = _context.sent;
                _this.getTransactionResponse = _this.getTransactionResponseAll[_this.getTransactionResponseAll.length - 1];
                if (!(_this.getTransactionResponse.status === _api.Api.GetTransactionStatus.NOT_FOUND)) {
                  _context.next = 13;
                  break;
                }
                throw new SentTransaction2.Errors.TransactionStillPending("Waited ".concat(timeoutInSeconds, " seconds for transaction to complete, but it did not. ") + "Returning anyway. Check the transaction status manually. " + "Sent transaction: ".concat(JSON.stringify(_this.sendTransactionResponse, null, 2), "\n") + "All attempts to get the result: ".concat(JSON.stringify(_this.getTransactionResponseAll, null, 2)));
              case 13:
                return _context.abrupt("return", _this);
              case 14:
              case "end":
                return _context.stop();
            }
          }, _callee);
        })));
        this.assembled = assembled;
        this.server = new _rpc.Server(this.assembled.options.rpcUrl, {
          allowHttp: (_this$assembled$optio2 = this.assembled.options.allowHttp) !== null && _this$assembled$optio2 !== void 0 ? _this$assembled$optio2 : false
        });
      }
      return _createClass(SentTransaction2, [{
        key: "result",
        get: function get() {
          if ("getTransactionResponse" in this && this.getTransactionResponse) {
            if ("returnValue" in this.getTransactionResponse) {
              return this.assembled.options.parseResultXdr(this.getTransactionResponse.returnValue);
            }
            throw new Error("Transaction failed! Cannot parse result.");
          }
          if (this.sendTransactionResponse) {
            var _this$sendTransaction;
            var errorResult = (_this$sendTransaction = this.sendTransactionResponse.errorResult) === null || _this$sendTransaction === void 0 ? void 0 : _this$sendTransaction.result();
            if (errorResult) {
              throw new SentTransaction2.Errors.SendFailed("Transaction simulation looked correct, but attempting to send the transaction failed. Check `simulation` and `sendTransactionResponseAll` to troubleshoot. Decoded `sendTransactionResponse.errorResultXdr`: ".concat(errorResult));
            }
            throw new SentTransaction2.Errors.SendResultOnly("Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with `getTransaction(sendTransactionResponse.hash)`");
          }
          throw new Error("Sending transaction failed: ".concat(JSON.stringify(this.assembled.signed)));
        }
      }]);
    }();
    _SentTransaction = SentTransaction;
    _defineProperty(SentTransaction, "Errors", {
      SendFailed: function(_Error) {
        function SendFailedError() {
          _classCallCheck(this, SendFailedError);
          return _callSuper(this, SendFailedError, arguments);
        }
        _inherits(SendFailedError, _Error);
        return _createClass(SendFailedError);
      }(_wrapNativeSuper(Error)),
      SendResultOnly: function(_Error2) {
        function SendResultOnlyError() {
          _classCallCheck(this, SendResultOnlyError);
          return _callSuper(this, SendResultOnlyError, arguments);
        }
        _inherits(SendResultOnlyError, _Error2);
        return _createClass(SendResultOnlyError);
      }(_wrapNativeSuper(Error)),
      TransactionStillPending: function(_Error3) {
        function TransactionStillPendingError() {
          _classCallCheck(this, TransactionStillPendingError);
          return _callSuper(this, TransactionStillPendingError, arguments);
        }
        _inherits(TransactionStillPendingError, _Error3);
        return _createClass(TransactionStillPendingError);
      }(_wrapNativeSuper(Error))
    });
    _defineProperty(SentTransaction, "init", function() {
      var _ref2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(assembled) {
        var tx, sent;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              tx = new _SentTransaction(assembled);
              _context2.next = 3;
              return tx.send();
            case 3:
              sent = _context2.sent;
              return _context2.abrupt("return", sent);
            case 5:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function(_x) {
        return _ref2.apply(this, arguments);
      };
    }());
  }
});

// node_modules/@stellar/stellar-sdk/lib/contract/assembled_transaction.js
var require_assembled_transaction = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/contract/assembled_transaction.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AssembledTransaction = void 0;
    var _stellarBase = require_lib();
    var _rpc = require_rpc();
    var _api = require_api();
    var _transaction = require_transaction();
    var _rust_result = require_rust_result();
    var _utils = require_utils();
    var _types = require_types();
    var _sent_transaction = require_sent_transaction();
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper2(t2) {
        if (null === t2 || !_isNativeFunction(t2)) return t2;
        if ("function" != typeof t2) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t2)) return r.get(t2);
          r.set(t2, Wrapper);
        }
        function Wrapper() {
          return _construct(t2, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }), _setPrototypeOf(Wrapper, t2);
      }, _wrapNativeSuper(t);
    }
    function _construct(t, e, r) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _createForOfIteratorHelper(r, e) {
      var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (!t) {
        if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
          t && (r = t);
          var _n = 0, F = function F2() {
          };
          return { s: F, n: function n() {
            return _n >= r.length ? { done: true } : { done: false, value: r[_n++] };
          }, e: function e2(r2) {
            throw r2;
          }, f: F };
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var o, a = true, u = false;
      return { s: function s() {
        t = t.call(r);
      }, n: function n() {
        var r2 = t.next();
        return a = r2.done, r2;
      }, e: function e2(r2) {
        u = true, o = r2;
      }, f: function f() {
        try {
          a || null == t.return || t.return();
        } finally {
          if (u) throw o;
        }
      } };
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define({}, "");
      } catch (t2) {
        define = function define2(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
        return this;
      }), define(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var AssembledTransaction = exports.AssembledTransaction = function() {
      function AssembledTransaction2(options) {
        var _this = this, _this$options$simulat, _this$options$allowHt;
        _classCallCheck(this, AssembledTransaction2);
        _defineProperty(this, "simulate", _asyncToGenerator(_regeneratorRuntime().mark(function _callee() {
          var _ref2, restore, account, result, _this$options$fee, _this$options$args, _this$options$timeout, contract, _args = arguments;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                _ref2 = _args.length > 0 && _args[0] !== void 0 ? _args[0] : {}, restore = _ref2.restore;
                if (_this.built) {
                  _context.next = 5;
                  break;
                }
                if (_this.raw) {
                  _context.next = 4;
                  break;
                }
                throw new Error("Transaction has not yet been assembled; call `AssembledTransaction.build` first.");
              case 4:
                _this.built = _this.raw.build();
              case 5:
                restore = restore !== null && restore !== void 0 ? restore : _this.options.restore;
                delete _this.simulationResult;
                delete _this.simulationTransactionData;
                _context.next = 10;
                return _this.server.simulateTransaction(_this.built);
              case 10:
                _this.simulation = _context.sent;
                if (!(restore && _api.Api.isSimulationRestore(_this.simulation))) {
                  _context.next = 25;
                  break;
                }
                _context.next = 14;
                return (0, _utils.getAccount)(_this.options, _this.server);
              case 14:
                account = _context.sent;
                _context.next = 17;
                return _this.restoreFootprint(_this.simulation.restorePreamble, account);
              case 17:
                result = _context.sent;
                if (!(result.status === _api.Api.GetTransactionStatus.SUCCESS)) {
                  _context.next = 24;
                  break;
                }
                contract = new _stellarBase.Contract(_this.options.contractId);
                _this.raw = new _stellarBase.TransactionBuilder(account, {
                  fee: (_this$options$fee = _this.options.fee) !== null && _this$options$fee !== void 0 ? _this$options$fee : _stellarBase.BASE_FEE,
                  networkPassphrase: _this.options.networkPassphrase
                }).addOperation(contract.call.apply(contract, [_this.options.method].concat(_toConsumableArray((_this$options$args = _this.options.args) !== null && _this$options$args !== void 0 ? _this$options$args : [])))).setTimeout((_this$options$timeout = _this.options.timeoutInSeconds) !== null && _this$options$timeout !== void 0 ? _this$options$timeout : _types.DEFAULT_TIMEOUT);
                _context.next = 23;
                return _this.simulate();
              case 23:
                return _context.abrupt("return", _this);
              case 24:
                throw new AssembledTransaction2.Errors.RestorationFailure("Automatic restore failed! You set 'restore: true' but the attempted restore did not work. Result:\n".concat(JSON.stringify(result)));
              case 25:
                if (_api.Api.isSimulationSuccess(_this.simulation)) {
                  _this.built = (0, _transaction.assembleTransaction)(_this.built, _this.simulation).build();
                }
                return _context.abrupt("return", _this);
              case 27:
              case "end":
                return _context.stop();
            }
          }, _callee);
        })));
        _defineProperty(this, "sign", _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
          var _this$options$timeout2;
          var _ref4, _ref4$force, force, _ref4$signTransaction, signTransaction, sigsNeeded, timeoutInSeconds, signOpts, _yield$signTransactio, signature, error, _args2 = arguments;
          return _regeneratorRuntime().wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                _ref4 = _args2.length > 0 && _args2[0] !== void 0 ? _args2[0] : {}, _ref4$force = _ref4.force, force = _ref4$force === void 0 ? false : _ref4$force, _ref4$signTransaction = _ref4.signTransaction, signTransaction = _ref4$signTransaction === void 0 ? _this.options.signTransaction : _ref4$signTransaction;
                if (_this.built) {
                  _context2.next = 3;
                  break;
                }
                throw new Error("Transaction has not yet been simulated");
              case 3:
                if (!(!force && _this.isReadCall)) {
                  _context2.next = 5;
                  break;
                }
                throw new AssembledTransaction2.Errors.NoSignatureNeeded("This is a read call. It requires no signature or sending. Use `force: true` to sign and send anyway.");
              case 5:
                if (signTransaction) {
                  _context2.next = 7;
                  break;
                }
                throw new AssembledTransaction2.Errors.NoSigner("You must provide a signTransaction function, either when calling `signAndSend` or when initializing your Client");
              case 7:
                sigsNeeded = _this.needsNonInvokerSigningBy().filter(function(id) {
                  return !id.startsWith("C");
                });
                if (!sigsNeeded.length) {
                  _context2.next = 10;
                  break;
                }
                throw new AssembledTransaction2.Errors.NeedsMoreSignatures("Transaction requires signatures from ".concat(sigsNeeded, ". ") + "See `needsNonInvokerSigningBy` for details.");
              case 10:
                timeoutInSeconds = (_this$options$timeout2 = _this.options.timeoutInSeconds) !== null && _this$options$timeout2 !== void 0 ? _this$options$timeout2 : _types.DEFAULT_TIMEOUT;
                _this.built = _stellarBase.TransactionBuilder.cloneFrom(_this.built, {
                  fee: _this.built.fee,
                  timebounds: void 0,
                  sorobanData: _this.simulationData.transactionData
                }).setTimeout(timeoutInSeconds).build();
                signOpts = {
                  networkPassphrase: _this.options.networkPassphrase
                };
                if (_this.options.address) signOpts.address = _this.options.address;
                if (_this.options.submit !== void 0) signOpts.submit = _this.options.submit;
                if (_this.options.submitUrl) signOpts.submitUrl = _this.options.submitUrl;
                _context2.next = 18;
                return signTransaction(_this.built.toXDR(), signOpts);
              case 18:
                _yield$signTransactio = _context2.sent;
                signature = _yield$signTransactio.signedTxXdr;
                error = _yield$signTransactio.error;
                _this.handleWalletError(error);
                _this.signed = _stellarBase.TransactionBuilder.fromXDR(signature, _this.options.networkPassphrase);
              case 23:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        })));
        _defineProperty(this, "signAndSend", _asyncToGenerator(_regeneratorRuntime().mark(function _callee3() {
          var _ref6, _ref6$force, force, _ref6$signTransaction, signTransaction, originalSubmit, _args3 = arguments;
          return _regeneratorRuntime().wrap(function _callee3$(_context3) {
            while (1) switch (_context3.prev = _context3.next) {
              case 0:
                _ref6 = _args3.length > 0 && _args3[0] !== void 0 ? _args3[0] : {}, _ref6$force = _ref6.force, force = _ref6$force === void 0 ? false : _ref6$force, _ref6$signTransaction = _ref6.signTransaction, signTransaction = _ref6$signTransaction === void 0 ? _this.options.signTransaction : _ref6$signTransaction;
                if (_this.signed) {
                  _context3.next = 10;
                  break;
                }
                originalSubmit = _this.options.submit;
                if (_this.options.submit) {
                  _this.options.submit = false;
                }
                _context3.prev = 4;
                _context3.next = 7;
                return _this.sign({
                  force,
                  signTransaction
                });
              case 7:
                _context3.prev = 7;
                _this.options.submit = originalSubmit;
                return _context3.finish(7);
              case 10:
                return _context3.abrupt("return", _this.send());
              case 11:
              case "end":
                return _context3.stop();
            }
          }, _callee3, null, [[4, , 7, 10]]);
        })));
        _defineProperty(this, "needsNonInvokerSigningBy", function() {
          var _rawInvokeHostFunctio;
          var _ref7 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref7$includeAlreadyS = _ref7.includeAlreadySigned, includeAlreadySigned = _ref7$includeAlreadyS === void 0 ? false : _ref7$includeAlreadyS;
          if (!_this.built) {
            throw new Error("Transaction has not yet been simulated");
          }
          if (!("operations" in _this.built)) {
            throw new Error("Unexpected Transaction type; no operations: ".concat(JSON.stringify(_this.built)));
          }
          var rawInvokeHostFunctionOp = _this.built.operations[0];
          return _toConsumableArray(new Set(((_rawInvokeHostFunctio = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio !== void 0 ? _rawInvokeHostFunctio : []).filter(function(entry) {
            return entry.credentials().switch() === _stellarBase.xdr.SorobanCredentialsType.sorobanCredentialsAddress() && (includeAlreadySigned || entry.credentials().address().signature().switch().name === "scvVoid");
          }).map(function(entry) {
            return _stellarBase.Address.fromScAddress(entry.credentials().address().address()).toString();
          })));
        });
        _defineProperty(this, "signAuthEntries", _asyncToGenerator(_regeneratorRuntime().mark(function _callee6() {
          var _rawInvokeHostFunctio2;
          var _ref9, _ref9$expiration, expiration, _ref9$signAuthEntry, signAuthEntry, _ref9$address, address, _ref9$authorizeEntry, authorizeEntry, needsNonInvokerSigningBy, rawInvokeHostFunctionOp, authEntries, _iterator, _step, _loop, _ret, _args7 = arguments;
          return _regeneratorRuntime().wrap(function _callee6$(_context7) {
            while (1) switch (_context7.prev = _context7.next) {
              case 0:
                _ref9 = _args7.length > 0 && _args7[0] !== void 0 ? _args7[0] : {}, _ref9$expiration = _ref9.expiration, expiration = _ref9$expiration === void 0 ? _asyncToGenerator(_regeneratorRuntime().mark(function _callee4() {
                  return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                    while (1) switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return _this.server.getLatestLedger();
                      case 2:
                        _context4.t0 = _context4.sent.sequence;
                        return _context4.abrupt("return", _context4.t0 + 100);
                      case 4:
                      case "end":
                        return _context4.stop();
                    }
                  }, _callee4);
                }))() : _ref9$expiration, _ref9$signAuthEntry = _ref9.signAuthEntry, signAuthEntry = _ref9$signAuthEntry === void 0 ? _this.options.signAuthEntry : _ref9$signAuthEntry, _ref9$address = _ref9.address, address = _ref9$address === void 0 ? _this.options.publicKey : _ref9$address, _ref9$authorizeEntry = _ref9.authorizeEntry, authorizeEntry = _ref9$authorizeEntry === void 0 ? _stellarBase.authorizeEntry : _ref9$authorizeEntry;
                if (_this.built) {
                  _context7.next = 3;
                  break;
                }
                throw new Error("Transaction has not yet been assembled or simulated");
              case 3:
                if (!(authorizeEntry === _stellarBase.authorizeEntry)) {
                  _context7.next = 11;
                  break;
                }
                needsNonInvokerSigningBy = _this.needsNonInvokerSigningBy();
                if (!(needsNonInvokerSigningBy.length === 0)) {
                  _context7.next = 7;
                  break;
                }
                throw new AssembledTransaction2.Errors.NoUnsignedNonInvokerAuthEntries("No unsigned non-invoker auth entries; maybe you already signed?");
              case 7:
                if (!(needsNonInvokerSigningBy.indexOf(address !== null && address !== void 0 ? address : "") === -1)) {
                  _context7.next = 9;
                  break;
                }
                throw new AssembledTransaction2.Errors.NoSignatureNeeded('No auth entries for public key "'.concat(address, '"'));
              case 9:
                if (signAuthEntry) {
                  _context7.next = 11;
                  break;
                }
                throw new AssembledTransaction2.Errors.NoSigner("You must provide `signAuthEntry` or a custom `authorizeEntry`");
              case 11:
                rawInvokeHostFunctionOp = _this.built.operations[0];
                authEntries = (_rawInvokeHostFunctio2 = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio2 !== void 0 ? _rawInvokeHostFunctio2 : [];
                _iterator = _createForOfIteratorHelper(authEntries.entries());
                _context7.prev = 14;
                _loop = _regeneratorRuntime().mark(function _loop2() {
                  var _step$value, i, entry, credentials, authEntryAddress, sign;
                  return _regeneratorRuntime().wrap(function _loop$(_context6) {
                    while (1) switch (_context6.prev = _context6.next) {
                      case 0:
                        _step$value = _slicedToArray(_step.value, 2), i = _step$value[0], entry = _step$value[1];
                        credentials = _stellarBase.xdr.SorobanCredentials.fromXDR(entry.credentials().toXDR());
                        if (!(credentials.switch() !== _stellarBase.xdr.SorobanCredentialsType.sorobanCredentialsAddress())) {
                          _context6.next = 4;
                          break;
                        }
                        return _context6.abrupt("return", 0);
                      case 4:
                        authEntryAddress = _stellarBase.Address.fromScAddress(credentials.address().address()).toString();
                        if (!(authEntryAddress !== address)) {
                          _context6.next = 7;
                          break;
                        }
                        return _context6.abrupt("return", 0);
                      case 7:
                        sign = signAuthEntry !== null && signAuthEntry !== void 0 ? signAuthEntry : Promise.resolve;
                        _context6.t0 = authorizeEntry;
                        _context6.t1 = entry;
                        _context6.t2 = function() {
                          var _ref11 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(preimage) {
                            var _yield$sign, signedAuthEntry, error;
                            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
                              while (1) switch (_context5.prev = _context5.next) {
                                case 0:
                                  _context5.next = 2;
                                  return sign(preimage.toXDR("base64"), {
                                    address
                                  });
                                case 2:
                                  _yield$sign = _context5.sent;
                                  signedAuthEntry = _yield$sign.signedAuthEntry;
                                  error = _yield$sign.error;
                                  _this.handleWalletError(error);
                                  return _context5.abrupt("return", Buffer.from(signedAuthEntry, "base64"));
                                case 7:
                                case "end":
                                  return _context5.stop();
                              }
                            }, _callee5);
                          }));
                          return function(_x) {
                            return _ref11.apply(this, arguments);
                          };
                        }();
                        _context6.next = 13;
                        return expiration;
                      case 13:
                        _context6.t3 = _context6.sent;
                        _context6.t4 = _this.options.networkPassphrase;
                        _context6.next = 17;
                        return (0, _context6.t0)(_context6.t1, _context6.t2, _context6.t3, _context6.t4);
                      case 17:
                        authEntries[i] = _context6.sent;
                      case 18:
                      case "end":
                        return _context6.stop();
                    }
                  }, _loop2);
                });
                _iterator.s();
              case 17:
                if ((_step = _iterator.n()).done) {
                  _context7.next = 24;
                  break;
                }
                return _context7.delegateYield(_loop(), "t0", 19);
              case 19:
                _ret = _context7.t0;
                if (!(_ret === 0)) {
                  _context7.next = 22;
                  break;
                }
                return _context7.abrupt("continue", 22);
              case 22:
                _context7.next = 17;
                break;
              case 24:
                _context7.next = 29;
                break;
              case 26:
                _context7.prev = 26;
                _context7.t1 = _context7["catch"](14);
                _iterator.e(_context7.t1);
              case 29:
                _context7.prev = 29;
                _iterator.f();
                return _context7.finish(29);
              case 32:
              case "end":
                return _context7.stop();
            }
          }, _callee6, null, [[14, 26, 29, 32]]);
        })));
        this.options = options;
        this.options.simulate = (_this$options$simulat = this.options.simulate) !== null && _this$options$simulat !== void 0 ? _this$options$simulat : true;
        this.server = new _rpc.Server(this.options.rpcUrl, {
          allowHttp: (_this$options$allowHt = this.options.allowHttp) !== null && _this$options$allowHt !== void 0 ? _this$options$allowHt : false
        });
      }
      return _createClass(AssembledTransaction2, [{
        key: "toJSON",
        value: function toJSON() {
          var _this$built;
          return JSON.stringify({
            method: this.options.method,
            tx: (_this$built = this.built) === null || _this$built === void 0 ? void 0 : _this$built.toXDR(),
            simulationResult: {
              auth: this.simulationData.result.auth.map(function(a) {
                return a.toXDR("base64");
              }),
              retval: this.simulationData.result.retval.toXDR("base64")
            },
            simulationTransactionData: this.simulationData.transactionData.toXDR("base64")
          });
        }
      }, {
        key: "toXDR",
        value: function toXDR() {
          var _this$built2;
          if (!this.built) throw new Error("Transaction has not yet been simulated; call `AssembledTransaction.simulate` first.");
          return (_this$built2 = this.built) === null || _this$built2 === void 0 ? void 0 : _this$built2.toEnvelope().toXDR("base64");
        }
      }, {
        key: "handleWalletError",
        value: function handleWalletError(error) {
          if (!error) return;
          var message = error.message, code = error.code;
          var fullMessage = "".concat(message).concat(error.ext ? " (".concat(error.ext.join(", "), ")") : "");
          switch (code) {
            case -1:
              throw new AssembledTransaction2.Errors.InternalWalletError(fullMessage);
            case -2:
              throw new AssembledTransaction2.Errors.ExternalServiceError(fullMessage);
            case -3:
              throw new AssembledTransaction2.Errors.InvalidClientRequest(fullMessage);
            case -4:
              throw new AssembledTransaction2.Errors.UserRejected(fullMessage);
            default:
              throw new Error("Unhandled error: ".concat(fullMessage));
          }
        }
      }, {
        key: "simulationData",
        get: function get() {
          var _simulation$result;
          if (this.simulationResult && this.simulationTransactionData) {
            return {
              result: this.simulationResult,
              transactionData: this.simulationTransactionData
            };
          }
          var simulation = this.simulation;
          if (!simulation) {
            throw new AssembledTransaction2.Errors.NotYetSimulated("Transaction has not yet been simulated");
          }
          if (_api.Api.isSimulationError(simulation)) {
            throw new AssembledTransaction2.Errors.SimulationFailed('Transaction simulation failed: "'.concat(simulation.error, '"'));
          }
          if (_api.Api.isSimulationRestore(simulation)) {
            throw new AssembledTransaction2.Errors.ExpiredState("You need to restore some contract state before you can invoke this method.\nYou can set `restore` to true in the method options in order to automatically restore the contract state when needed.");
          }
          this.simulationResult = (_simulation$result = simulation.result) !== null && _simulation$result !== void 0 ? _simulation$result : {
            auth: [],
            retval: _stellarBase.xdr.ScVal.scvVoid()
          };
          this.simulationTransactionData = simulation.transactionData.build();
          return {
            result: this.simulationResult,
            transactionData: this.simulationTransactionData
          };
        }
      }, {
        key: "result",
        get: function get() {
          try {
            if (!this.simulationData.result) {
              throw new Error("No simulation result!");
            }
            return this.options.parseResultXdr(this.simulationData.result.retval);
          } catch (e) {
            if (!(0, _utils.implementsToString)(e)) throw e;
            var err = this.parseError(e.toString());
            if (err) return err;
            throw e;
          }
        }
      }, {
        key: "parseError",
        value: function parseError(errorMessage) {
          if (!this.options.errorTypes) return void 0;
          var match = errorMessage.match(_utils.contractErrorPattern);
          if (!match) return void 0;
          var i = parseInt(match[1], 10);
          var err = this.options.errorTypes[i];
          if (!err) return void 0;
          return new _rust_result.Err(err);
        }
      }, {
        key: "send",
        value: function() {
          var _send = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7() {
            var sent;
            return _regeneratorRuntime().wrap(function _callee7$(_context8) {
              while (1) switch (_context8.prev = _context8.next) {
                case 0:
                  if (this.signed) {
                    _context8.next = 2;
                    break;
                  }
                  throw new Error("The transaction has not yet been signed. Run `sign` first, or use `signAndSend` instead.");
                case 2:
                  _context8.next = 4;
                  return _sent_transaction.SentTransaction.init(this);
                case 4:
                  sent = _context8.sent;
                  return _context8.abrupt("return", sent);
                case 6:
                case "end":
                  return _context8.stop();
              }
            }, _callee7, this);
          }));
          function send() {
            return _send.apply(this, arguments);
          }
          return send;
        }()
      }, {
        key: "isReadCall",
        get: function get() {
          var authsCount = this.simulationData.result.auth.length;
          var writeLength = this.simulationData.transactionData.resources().footprint().readWrite().length;
          return authsCount === 0 && writeLength === 0;
        }
      }, {
        key: "restoreFootprint",
        value: function() {
          var _restoreFootprint = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8(restorePreamble, account) {
            var restoreTx, sentTransaction;
            return _regeneratorRuntime().wrap(function _callee8$(_context9) {
              while (1) switch (_context9.prev = _context9.next) {
                case 0:
                  if (this.options.signTransaction) {
                    _context9.next = 2;
                    break;
                  }
                  throw new Error("For automatic restore to work you must provide a signTransaction function when initializing your Client");
                case 2:
                  if (!(account !== null && account !== void 0)) {
                    _context9.next = 6;
                    break;
                  }
                  _context9.t0 = account;
                  _context9.next = 9;
                  break;
                case 6:
                  _context9.next = 8;
                  return (0, _utils.getAccount)(this.options, this.server);
                case 8:
                  _context9.t0 = _context9.sent;
                case 9:
                  account = _context9.t0;
                  _context9.next = 12;
                  return AssembledTransaction2.buildFootprintRestoreTransaction(_objectSpread({}, this.options), restorePreamble.transactionData, account, restorePreamble.minResourceFee);
                case 12:
                  restoreTx = _context9.sent;
                  _context9.next = 15;
                  return restoreTx.signAndSend();
                case 15:
                  sentTransaction = _context9.sent;
                  if (sentTransaction.getTransactionResponse) {
                    _context9.next = 18;
                    break;
                  }
                  throw new AssembledTransaction2.Errors.RestorationFailure("The attempt at automatic restore failed. \n".concat(JSON.stringify(sentTransaction)));
                case 18:
                  return _context9.abrupt("return", sentTransaction.getTransactionResponse);
                case 19:
                case "end":
                  return _context9.stop();
              }
            }, _callee8, this);
          }));
          function restoreFootprint(_x2, _x3) {
            return _restoreFootprint.apply(this, arguments);
          }
          return restoreFootprint;
        }()
      }], [{
        key: "fromJSON",
        value: function fromJSON(options, _ref12) {
          var tx = _ref12.tx, simulationResult = _ref12.simulationResult, simulationTransactionData = _ref12.simulationTransactionData;
          var txn = new AssembledTransaction2(options);
          txn.built = _stellarBase.TransactionBuilder.fromXDR(tx, options.networkPassphrase);
          txn.simulationResult = {
            auth: simulationResult.auth.map(function(a) {
              return _stellarBase.xdr.SorobanAuthorizationEntry.fromXDR(a, "base64");
            }),
            retval: _stellarBase.xdr.ScVal.fromXDR(simulationResult.retval, "base64")
          };
          txn.simulationTransactionData = _stellarBase.xdr.SorobanTransactionData.fromXDR(simulationTransactionData, "base64");
          return txn;
        }
      }, {
        key: "fromXDR",
        value: function fromXDR(options, encodedXDR, spec) {
          var _operation$func;
          var envelope = _stellarBase.xdr.TransactionEnvelope.fromXDR(encodedXDR, "base64");
          var built = _stellarBase.TransactionBuilder.fromXDR(envelope, options.networkPassphrase);
          var operation = built.operations[0];
          if (!(operation !== null && operation !== void 0 && (_operation$func = operation.func) !== null && _operation$func !== void 0 && _operation$func.value) || typeof operation.func.value !== "function") {
            throw new Error("Could not extract the method from the transaction envelope.");
          }
          var invokeContractArgs = operation.func.value();
          if (!(invokeContractArgs !== null && invokeContractArgs !== void 0 && invokeContractArgs.functionName)) {
            throw new Error("Could not extract the method name from the transaction envelope.");
          }
          var method = invokeContractArgs.functionName().toString("utf-8");
          var txn = new AssembledTransaction2(_objectSpread(_objectSpread({}, options), {}, {
            method,
            parseResultXdr: function parseResultXdr(result) {
              return spec.funcResToNative(method, result);
            }
          }));
          txn.built = built;
          return txn;
        }
      }, {
        key: "build",
        value: function build(options) {
          var _options$args;
          var contract = new _stellarBase.Contract(options.contractId);
          return AssembledTransaction2.buildWithOp(contract.call.apply(contract, [options.method].concat(_toConsumableArray((_options$args = options.args) !== null && _options$args !== void 0 ? _options$args : []))), options);
        }
      }, {
        key: "buildWithOp",
        value: function() {
          var _buildWithOp = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9(operation, options) {
            var _options$fee, _options$timeoutInSec;
            var tx, account;
            return _regeneratorRuntime().wrap(function _callee9$(_context10) {
              while (1) switch (_context10.prev = _context10.next) {
                case 0:
                  tx = new AssembledTransaction2(options);
                  _context10.next = 3;
                  return (0, _utils.getAccount)(options, tx.server);
                case 3:
                  account = _context10.sent;
                  tx.raw = new _stellarBase.TransactionBuilder(account, {
                    fee: (_options$fee = options.fee) !== null && _options$fee !== void 0 ? _options$fee : _stellarBase.BASE_FEE,
                    networkPassphrase: options.networkPassphrase
                  }).setTimeout((_options$timeoutInSec = options.timeoutInSeconds) !== null && _options$timeoutInSec !== void 0 ? _options$timeoutInSec : _types.DEFAULT_TIMEOUT).addOperation(operation);
                  if (!options.simulate) {
                    _context10.next = 8;
                    break;
                  }
                  _context10.next = 8;
                  return tx.simulate();
                case 8:
                  return _context10.abrupt("return", tx);
                case 9:
                case "end":
                  return _context10.stop();
              }
            }, _callee9);
          }));
          function buildWithOp(_x4, _x5) {
            return _buildWithOp.apply(this, arguments);
          }
          return buildWithOp;
        }()
      }, {
        key: "buildFootprintRestoreTransaction",
        value: function() {
          var _buildFootprintRestoreTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10(options, sorobanData, account, fee) {
            var _options$timeoutInSec2;
            var tx;
            return _regeneratorRuntime().wrap(function _callee10$(_context11) {
              while (1) switch (_context11.prev = _context11.next) {
                case 0:
                  tx = new AssembledTransaction2(options);
                  tx.raw = new _stellarBase.TransactionBuilder(account, {
                    fee,
                    networkPassphrase: options.networkPassphrase
                  }).setSorobanData(sorobanData instanceof _stellarBase.SorobanDataBuilder ? sorobanData.build() : sorobanData).addOperation(_stellarBase.Operation.restoreFootprint({})).setTimeout((_options$timeoutInSec2 = options.timeoutInSeconds) !== null && _options$timeoutInSec2 !== void 0 ? _options$timeoutInSec2 : _types.DEFAULT_TIMEOUT);
                  _context11.next = 4;
                  return tx.simulate({
                    restore: false
                  });
                case 4:
                  return _context11.abrupt("return", tx);
                case 5:
                case "end":
                  return _context11.stop();
              }
            }, _callee10);
          }));
          function buildFootprintRestoreTransaction(_x6, _x7, _x8, _x9) {
            return _buildFootprintRestoreTransaction.apply(this, arguments);
          }
          return buildFootprintRestoreTransaction;
        }()
      }]);
    }();
    _defineProperty(AssembledTransaction, "Errors", {
      ExpiredState: function(_Error) {
        function ExpiredStateError() {
          _classCallCheck(this, ExpiredStateError);
          return _callSuper(this, ExpiredStateError, arguments);
        }
        _inherits(ExpiredStateError, _Error);
        return _createClass(ExpiredStateError);
      }(_wrapNativeSuper(Error)),
      RestorationFailure: function(_Error2) {
        function RestoreFailureError() {
          _classCallCheck(this, RestoreFailureError);
          return _callSuper(this, RestoreFailureError, arguments);
        }
        _inherits(RestoreFailureError, _Error2);
        return _createClass(RestoreFailureError);
      }(_wrapNativeSuper(Error)),
      NeedsMoreSignatures: function(_Error3) {
        function NeedsMoreSignaturesError() {
          _classCallCheck(this, NeedsMoreSignaturesError);
          return _callSuper(this, NeedsMoreSignaturesError, arguments);
        }
        _inherits(NeedsMoreSignaturesError, _Error3);
        return _createClass(NeedsMoreSignaturesError);
      }(_wrapNativeSuper(Error)),
      NoSignatureNeeded: function(_Error4) {
        function NoSignatureNeededError() {
          _classCallCheck(this, NoSignatureNeededError);
          return _callSuper(this, NoSignatureNeededError, arguments);
        }
        _inherits(NoSignatureNeededError, _Error4);
        return _createClass(NoSignatureNeededError);
      }(_wrapNativeSuper(Error)),
      NoUnsignedNonInvokerAuthEntries: function(_Error5) {
        function NoUnsignedNonInvokerAuthEntriesError() {
          _classCallCheck(this, NoUnsignedNonInvokerAuthEntriesError);
          return _callSuper(this, NoUnsignedNonInvokerAuthEntriesError, arguments);
        }
        _inherits(NoUnsignedNonInvokerAuthEntriesError, _Error5);
        return _createClass(NoUnsignedNonInvokerAuthEntriesError);
      }(_wrapNativeSuper(Error)),
      NoSigner: function(_Error6) {
        function NoSignerError() {
          _classCallCheck(this, NoSignerError);
          return _callSuper(this, NoSignerError, arguments);
        }
        _inherits(NoSignerError, _Error6);
        return _createClass(NoSignerError);
      }(_wrapNativeSuper(Error)),
      NotYetSimulated: function(_Error7) {
        function NotYetSimulatedError() {
          _classCallCheck(this, NotYetSimulatedError);
          return _callSuper(this, NotYetSimulatedError, arguments);
        }
        _inherits(NotYetSimulatedError, _Error7);
        return _createClass(NotYetSimulatedError);
      }(_wrapNativeSuper(Error)),
      FakeAccount: function(_Error8) {
        function FakeAccountError() {
          _classCallCheck(this, FakeAccountError);
          return _callSuper(this, FakeAccountError, arguments);
        }
        _inherits(FakeAccountError, _Error8);
        return _createClass(FakeAccountError);
      }(_wrapNativeSuper(Error)),
      SimulationFailed: function(_Error9) {
        function SimulationFailedError() {
          _classCallCheck(this, SimulationFailedError);
          return _callSuper(this, SimulationFailedError, arguments);
        }
        _inherits(SimulationFailedError, _Error9);
        return _createClass(SimulationFailedError);
      }(_wrapNativeSuper(Error)),
      InternalWalletError: function(_Error10) {
        function InternalWalletError() {
          _classCallCheck(this, InternalWalletError);
          return _callSuper(this, InternalWalletError, arguments);
        }
        _inherits(InternalWalletError, _Error10);
        return _createClass(InternalWalletError);
      }(_wrapNativeSuper(Error)),
      ExternalServiceError: function(_Error11) {
        function ExternalServiceError() {
          _classCallCheck(this, ExternalServiceError);
          return _callSuper(this, ExternalServiceError, arguments);
        }
        _inherits(ExternalServiceError, _Error11);
        return _createClass(ExternalServiceError);
      }(_wrapNativeSuper(Error)),
      InvalidClientRequest: function(_Error12) {
        function InvalidClientRequestError() {
          _classCallCheck(this, InvalidClientRequestError);
          return _callSuper(this, InvalidClientRequestError, arguments);
        }
        _inherits(InvalidClientRequestError, _Error12);
        return _createClass(InvalidClientRequestError);
      }(_wrapNativeSuper(Error)),
      UserRejected: function(_Error13) {
        function UserRejectedError() {
          _classCallCheck(this, UserRejectedError);
          return _callSuper(this, UserRejectedError, arguments);
        }
        _inherits(UserRejectedError, _Error13);
        return _createClass(UserRejectedError);
      }(_wrapNativeSuper(Error))
    });
  }
});

// node_modules/@stellar/stellar-sdk/lib/contract/basic_node_signer.js
var require_basic_node_signer = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/contract/basic_node_signer.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.basicNodeSigner = void 0;
    var _stellarBase = require_lib();
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define({}, "");
      } catch (t2) {
        define = function define2(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
        return this;
      }), define(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var basicNodeSigner = exports.basicNodeSigner = function basicNodeSigner2(keypair, networkPassphrase) {
      return {
        signTransaction: function() {
          var _signTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(xdr, opts) {
            var t;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  t = _stellarBase.TransactionBuilder.fromXDR(xdr, (opts === null || opts === void 0 ? void 0 : opts.networkPassphrase) || networkPassphrase);
                  t.sign(keypair);
                  return _context.abrupt("return", {
                    signedTxXdr: t.toXDR(),
                    signerAddress: keypair.publicKey()
                  });
                case 3:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function signTransaction(_x, _x2) {
            return _signTransaction.apply(this, arguments);
          }
          return signTransaction;
        }(),
        signAuthEntry: function() {
          var _signAuthEntry = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(authEntry) {
            var signedAuthEntry;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  signedAuthEntry = keypair.sign((0, _stellarBase.hash)(Buffer.from(authEntry, "base64"))).toString("base64");
                  return _context2.abrupt("return", {
                    signedAuthEntry,
                    signerAddress: keypair.publicKey()
                  });
                case 2:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          function signAuthEntry(_x3) {
            return _signAuthEntry.apply(this, arguments);
          }
          return signAuthEntry;
        }()
      };
    };
  }
});

// node_modules/@stellar/stellar-sdk/lib/contract/spec.js
var require_spec = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/contract/spec.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Spec = void 0;
    var _stellarBase = require_lib();
    var _rust_result = require_rust_result();
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function enumToJsonSchema(udt) {
      var description = udt.doc().toString();
      var cases = udt.cases();
      var oneOf = [];
      cases.forEach(function(aCase) {
        var title = aCase.name().toString();
        var desc = aCase.doc().toString();
        oneOf.push({
          description: desc,
          title,
          enum: [aCase.value()],
          type: "number"
        });
      });
      var res = {
        oneOf
      };
      if (description.length > 0) {
        res.description = description;
      }
      return res;
    }
    function isNumeric(field) {
      return /^\d+$/.test(field.name().toString());
    }
    function readObj(args, input) {
      var inputName = input.name().toString();
      var entry = Object.entries(args).find(function(_ref) {
        var _ref2 = _slicedToArray(_ref, 1), name = _ref2[0];
        return name === inputName;
      });
      if (!entry) {
        throw new Error("Missing field ".concat(inputName));
      }
      return entry[1];
    }
    function findCase(name) {
      return function matches(entry) {
        switch (entry.switch().value) {
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value: {
            var tuple = entry.tupleCase();
            return tuple.name().toString() === name;
          }
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value: {
            var voidCase = entry.voidCase();
            return voidCase.name().toString() === name;
          }
          default:
            return false;
        }
      };
    }
    function stringToScVal(str, ty) {
      switch (ty.value) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeString().value:
          return _stellarBase.xdr.ScVal.scvString(str);
        case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value:
          return _stellarBase.xdr.ScVal.scvSymbol(str);
        case _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value:
          return _stellarBase.Address.fromString(str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value:
          return new _stellarBase.XdrLargeInt("u64", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value:
          return new _stellarBase.XdrLargeInt("i64", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value:
          return new _stellarBase.XdrLargeInt("u128", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value:
          return new _stellarBase.XdrLargeInt("i128", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value:
          return new _stellarBase.XdrLargeInt("u256", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value:
          return new _stellarBase.XdrLargeInt("i256", str).toScVal();
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value:
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value:
          return _stellarBase.xdr.ScVal.scvBytes(Buffer.from(str, "base64"));
        default:
          throw new TypeError("invalid type ".concat(ty.name, " specified for string value"));
      }
    }
    var PRIMITIVE_DEFINITONS = {
      U32: {
        type: "integer",
        minimum: 0,
        maximum: 4294967295
      },
      I32: {
        type: "integer",
        minimum: -2147483648,
        maximum: 2147483647
      },
      U64: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 20
      },
      I64: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 21
      },
      U128: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 39
      },
      I128: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 40
      },
      U256: {
        type: "string",
        pattern: "^([1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 78
      },
      I256: {
        type: "string",
        pattern: "^(-?[1-9][0-9]*|0)$",
        minLength: 1,
        maxLength: 79
      },
      Address: {
        type: "string",
        format: "address",
        description: "Address can be a public key or contract id"
      },
      ScString: {
        type: "string",
        description: "ScString is a string"
      },
      ScSymbol: {
        type: "string",
        description: "ScSymbol is a string"
      },
      DataUrl: {
        type: "string",
        pattern: "^(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\\/]{3}=)?$"
      }
    };
    function typeRef(typeDef) {
      var t = typeDef.switch();
      var value = t.value;
      var ref;
      switch (value) {
        case _stellarBase.xdr.ScSpecType.scSpecTypeVal().value: {
          ref = "Val";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBool().value: {
          return {
            type: "boolean"
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value: {
          return {
            type: "null"
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeError().value: {
          ref = "Error";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU32().value: {
          ref = "U32";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI32().value: {
          ref = "I32";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value: {
          ref = "U64";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value: {
          ref = "I64";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeTimepoint().value: {
          throw new Error("Timepoint type not supported");
          ref = "Timepoint";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeDuration().value: {
          throw new Error("Duration not supported");
          ref = "Duration";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value: {
          ref = "U128";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value: {
          ref = "I128";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value: {
          ref = "U256";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value: {
          ref = "I256";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value: {
          ref = "DataUrl";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeString().value: {
          ref = "ScString";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value: {
          ref = "ScSymbol";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value: {
          ref = "Address";
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeOption().value: {
          var opt = typeDef.option();
          return typeRef(opt.valueType());
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeResult().value: {
          break;
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeVec().value: {
          var arr = typeDef.vec();
          var reference = typeRef(arr.elementType());
          return {
            type: "array",
            items: reference
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeMap().value: {
          var map = typeDef.map();
          var items = [typeRef(map.keyType()), typeRef(map.valueType())];
          return {
            type: "array",
            items: {
              type: "array",
              items,
              minItems: 2,
              maxItems: 2
            }
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value: {
          var tuple = typeDef.tuple();
          var minItems = tuple.valueTypes().length;
          var maxItems = minItems;
          var _items = tuple.valueTypes().map(typeRef);
          return {
            type: "array",
            items: _items,
            minItems,
            maxItems
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value: {
          var _arr = typeDef.bytesN();
          return {
            $ref: "#/definitions/DataUrl",
            maxLength: _arr.n()
          };
        }
        case _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value: {
          var udt = typeDef.udt();
          ref = udt.name().toString();
          break;
        }
      }
      return {
        $ref: "#/definitions/".concat(ref)
      };
    }
    function isRequired(typeDef) {
      return typeDef.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeOption().value;
    }
    function argsAndRequired(input) {
      var properties = {};
      var required = [];
      input.forEach(function(arg) {
        var aType = arg.type();
        var name = arg.name().toString();
        properties[name] = typeRef(aType);
        if (isRequired(aType)) {
          required.push(name);
        }
      });
      var res = {
        properties
      };
      if (required.length > 0) {
        res.required = required;
      }
      return res;
    }
    function structToJsonSchema(udt) {
      var fields = udt.fields();
      if (fields.some(isNumeric)) {
        if (!fields.every(isNumeric)) {
          throw new Error("mixed numeric and non-numeric field names are not allowed");
        }
        var items = fields.map(function(_, i) {
          return typeRef(fields[i].type());
        });
        return {
          type: "array",
          items,
          minItems: fields.length,
          maxItems: fields.length
        };
      }
      var description = udt.doc().toString();
      var _argsAndRequired = argsAndRequired(fields), properties = _argsAndRequired.properties, required = _argsAndRequired.required;
      properties.additionalProperties = false;
      return {
        description,
        properties,
        required,
        type: "object"
      };
    }
    function functionToJsonSchema(func) {
      var _argsAndRequired2 = argsAndRequired(func.inputs()), properties = _argsAndRequired2.properties, required = _argsAndRequired2.required;
      var args = {
        additionalProperties: false,
        properties,
        type: "object"
      };
      if ((required === null || required === void 0 ? void 0 : required.length) > 0) {
        args.required = required;
      }
      var input = {
        properties: {
          args
        }
      };
      var outputs = func.outputs();
      var output = outputs.length > 0 ? typeRef(outputs[0]) : typeRef(_stellarBase.xdr.ScSpecTypeDef.scSpecTypeVoid());
      var description = func.doc().toString();
      if (description.length > 0) {
        input.description = description;
      }
      input.additionalProperties = false;
      output.additionalProperties = false;
      return {
        input,
        output
      };
    }
    function unionToJsonSchema(udt) {
      var description = udt.doc().toString();
      var cases = udt.cases();
      var oneOf = [];
      cases.forEach(function(aCase) {
        switch (aCase.switch().value) {
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0().value: {
            var c = aCase.voidCase();
            var title = c.name().toString();
            oneOf.push({
              type: "object",
              title,
              properties: {
                tag: title
              },
              additionalProperties: false,
              required: ["tag"]
            });
            break;
          }
          case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value: {
            var _c = aCase.tupleCase();
            var _title = _c.name().toString();
            oneOf.push({
              type: "object",
              title: _title,
              properties: {
                tag: _title,
                values: {
                  type: "array",
                  items: _c.type().map(typeRef)
                }
              },
              required: ["tag", "values"],
              additionalProperties: false
            });
          }
        }
      });
      var res = {
        oneOf
      };
      if (description.length > 0) {
        res.description = description;
      }
      return res;
    }
    var Spec = exports.Spec = function() {
      function Spec2(entries) {
        _classCallCheck(this, Spec2);
        _defineProperty(this, "entries", []);
        if (entries.length === 0) {
          throw new Error("Contract spec must have at least one entry");
        }
        var entry = entries[0];
        if (typeof entry === "string") {
          this.entries = entries.map(function(s) {
            return _stellarBase.xdr.ScSpecEntry.fromXDR(s, "base64");
          });
        } else {
          this.entries = entries;
        }
      }
      return _createClass(Spec2, [{
        key: "funcs",
        value: function funcs() {
          return this.entries.filter(function(entry) {
            return entry.switch().value === _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value;
          }).map(function(entry) {
            return entry.functionV0();
          });
        }
      }, {
        key: "getFunc",
        value: function getFunc(name) {
          var entry = this.findEntry(name);
          if (entry.switch().value !== _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value) {
            throw new Error("".concat(name, " is not a function"));
          }
          return entry.functionV0();
        }
      }, {
        key: "funcArgsToScVals",
        value: function funcArgsToScVals(name, args) {
          var _this = this;
          var fn = this.getFunc(name);
          return fn.inputs().map(function(input) {
            return _this.nativeToScVal(readObj(args, input), input.type());
          });
        }
      }, {
        key: "funcResToNative",
        value: function funcResToNative(name, val_or_base64) {
          var val = typeof val_or_base64 === "string" ? _stellarBase.xdr.ScVal.fromXDR(val_or_base64, "base64") : val_or_base64;
          var func = this.getFunc(name);
          var outputs = func.outputs();
          if (outputs.length === 0) {
            var type = val.switch();
            if (type.value !== _stellarBase.xdr.ScValType.scvVoid().value) {
              throw new Error("Expected void, got ".concat(type.name));
            }
            return null;
          }
          if (outputs.length > 1) {
            throw new Error("Multiple outputs not supported");
          }
          var output = outputs[0];
          if (output.switch().value === _stellarBase.xdr.ScSpecType.scSpecTypeResult().value) {
            return new _rust_result.Ok(this.scValToNative(val, output.result().okType()));
          }
          return this.scValToNative(val, output);
        }
      }, {
        key: "findEntry",
        value: function findEntry(name) {
          var entry = this.entries.find(function(e) {
            return e.value().name().toString() === name;
          });
          if (!entry) {
            throw new Error("no such entry: ".concat(name));
          }
          return entry;
        }
      }, {
        key: "nativeToScVal",
        value: function nativeToScVal(val, ty) {
          var _this2 = this;
          var t = ty.switch();
          var value = t.value;
          if (t.value === _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value) {
            var udt = ty.udt();
            return this.nativeToUdt(val, udt.name().toString());
          }
          if (value === _stellarBase.xdr.ScSpecType.scSpecTypeOption().value) {
            var opt = ty.option();
            if (val === void 0) {
              return _stellarBase.xdr.ScVal.scvVoid();
            }
            return this.nativeToScVal(val, opt.valueType());
          }
          switch (_typeof(val)) {
            case "object": {
              var _val$constructor$name, _val$constructor;
              if (val === null) {
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value:
                    return _stellarBase.xdr.ScVal.scvVoid();
                  default:
                    throw new TypeError("Type ".concat(ty, " was not void, but value was null"));
                }
              }
              if (val instanceof _stellarBase.xdr.ScVal) {
                return val;
              }
              if (val instanceof _stellarBase.Address) {
                if (ty.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value) {
                  throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
                }
                return val.toScVal();
              }
              if (val instanceof _stellarBase.Contract) {
                if (ty.switch().value !== _stellarBase.xdr.ScSpecType.scSpecTypeAddress().value) {
                  throw new TypeError("Type ".concat(ty, " was not address, but value was Address"));
                }
                return val.address().toScVal();
              }
              if (val instanceof Uint8Array || Buffer.isBuffer(val)) {
                var copy = Uint8Array.from(val);
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeBytesN().value: {
                    var bytesN = ty.bytesN();
                    if (copy.length !== bytesN.n()) {
                      throw new TypeError("expected ".concat(bytesN.n(), " bytes, but got ").concat(copy.length));
                    }
                    return _stellarBase.xdr.ScVal.scvBytes(copy);
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeBytes().value:
                    return _stellarBase.xdr.ScVal.scvBytes(copy);
                  default:
                    throw new TypeError("invalid type (".concat(ty, ") specified for Bytes and BytesN"));
                }
              }
              if (Array.isArray(val)) {
                switch (value) {
                  case _stellarBase.xdr.ScSpecType.scSpecTypeVec().value: {
                    var vec = ty.vec();
                    var elementType = vec.elementType();
                    return _stellarBase.xdr.ScVal.scvVec(val.map(function(v2) {
                      return _this2.nativeToScVal(v2, elementType);
                    }));
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value: {
                    var tup = ty.tuple();
                    var valTypes = tup.valueTypes();
                    if (val.length !== valTypes.length) {
                      throw new TypeError("Tuple expects ".concat(valTypes.length, " values, but ").concat(val.length, " were provided"));
                    }
                    return _stellarBase.xdr.ScVal.scvVec(val.map(function(v2, i) {
                      return _this2.nativeToScVal(v2, valTypes[i]);
                    }));
                  }
                  case _stellarBase.xdr.ScSpecType.scSpecTypeMap().value: {
                    var map = ty.map();
                    var keyType = map.keyType();
                    var valueType = map.valueType();
                    return _stellarBase.xdr.ScVal.scvMap(val.map(function(entry) {
                      var key2 = _this2.nativeToScVal(entry[0], keyType);
                      var mapVal = _this2.nativeToScVal(entry[1], valueType);
                      return new _stellarBase.xdr.ScMapEntry({
                        key: key2,
                        val: mapVal
                      });
                    }));
                  }
                  default:
                    throw new TypeError("Type ".concat(ty, " was not vec, but value was Array"));
                }
              }
              if (val.constructor === Map) {
                if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeMap().value) {
                  throw new TypeError("Type ".concat(ty, " was not map, but value was Map"));
                }
                var scMap = ty.map();
                var _map = val;
                var entries = [];
                var values = _map.entries();
                var res = values.next();
                while (!res.done) {
                  var _res$value = _slicedToArray(res.value, 2), k = _res$value[0], v = _res$value[1];
                  var key = this.nativeToScVal(k, scMap.keyType());
                  var mapval = this.nativeToScVal(v, scMap.valueType());
                  entries.push(new _stellarBase.xdr.ScMapEntry({
                    key,
                    val: mapval
                  }));
                  res = values.next();
                }
                return _stellarBase.xdr.ScVal.scvMap(entries);
              }
              if (((_val$constructor$name = (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) !== null && _val$constructor$name !== void 0 ? _val$constructor$name : "") !== "Object") {
                var _val$constructor2;
                throw new TypeError("cannot interpret ".concat((_val$constructor2 = val.constructor) === null || _val$constructor2 === void 0 ? void 0 : _val$constructor2.name, " value as ScVal (").concat(JSON.stringify(val), ")"));
              }
              throw new TypeError("Received object ".concat(val, "  did not match the provided type ").concat(ty));
            }
            case "number":
            case "bigint": {
              switch (value) {
                case _stellarBase.xdr.ScSpecType.scSpecTypeU32().value:
                  return _stellarBase.xdr.ScVal.scvU32(val);
                case _stellarBase.xdr.ScSpecType.scSpecTypeI32().value:
                  return _stellarBase.xdr.ScVal.scvI32(val);
                case _stellarBase.xdr.ScSpecType.scSpecTypeU64().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI64().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeU128().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI128().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeU256().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeI256().value: {
                  var intType = t.name.substring(10).toLowerCase();
                  return new _stellarBase.XdrLargeInt(intType, val).toScVal();
                }
                default:
                  throw new TypeError("invalid type (".concat(ty, ") specified for integer"));
              }
            }
            case "string":
              return stringToScVal(val, t);
            case "boolean": {
              if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeBool().value) {
                throw TypeError("Type ".concat(ty, " was not bool, but value was bool"));
              }
              return _stellarBase.xdr.ScVal.scvBool(val);
            }
            case "undefined": {
              if (!ty) {
                return _stellarBase.xdr.ScVal.scvVoid();
              }
              switch (value) {
                case _stellarBase.xdr.ScSpecType.scSpecTypeVoid().value:
                case _stellarBase.xdr.ScSpecType.scSpecTypeOption().value:
                  return _stellarBase.xdr.ScVal.scvVoid();
                default:
                  throw new TypeError("Type ".concat(ty, " was not void, but value was undefined"));
              }
            }
            case "function":
              return this.nativeToScVal(val(), ty);
            default:
              throw new TypeError("failed to convert typeof ".concat(_typeof(val), " (").concat(val, ")"));
          }
        }
      }, {
        key: "nativeToUdt",
        value: function nativeToUdt(val, name) {
          var entry = this.findEntry(name);
          switch (entry.switch()) {
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              if (typeof val !== "number") {
                throw new TypeError("expected number for enum ".concat(name, ", but got ").concat(_typeof(val)));
              }
              return this.nativeToEnum(val, entry.udtEnumV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.nativeToStruct(val, entry.udtStructV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.nativeToUnion(val, entry.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(name));
          }
        }
      }, {
        key: "nativeToUnion",
        value: function nativeToUnion(val, union_) {
          var _this3 = this;
          var entryName = val.tag;
          var caseFound = union_.cases().find(function(entry) {
            var caseN = entry.value().name().toString();
            return caseN === entryName;
          });
          if (!caseFound) {
            throw new TypeError("no such enum entry: ".concat(entryName, " in ").concat(union_));
          }
          var key = _stellarBase.xdr.ScVal.scvSymbol(entryName);
          switch (caseFound.switch()) {
            case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseVoidV0(): {
              return _stellarBase.xdr.ScVal.scvVec([key]);
            }
            case _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0(): {
              var types = caseFound.tupleCase().type();
              if (Array.isArray(val.values)) {
                if (val.values.length !== types.length) {
                  throw new TypeError("union ".concat(union_, " expects ").concat(types.length, " values, but got ").concat(val.values.length));
                }
                var scvals = val.values.map(function(v, i) {
                  return _this3.nativeToScVal(v, types[i]);
                });
                scvals.unshift(key);
                return _stellarBase.xdr.ScVal.scvVec(scvals);
              }
              throw new Error("failed to parse union case ".concat(caseFound, " with ").concat(val));
            }
            default:
              throw new Error("failed to parse union ".concat(union_, " with ").concat(val));
          }
        }
      }, {
        key: "nativeToStruct",
        value: function nativeToStruct(val, struct) {
          var _this4 = this;
          var fields = struct.fields();
          if (fields.some(isNumeric)) {
            if (!fields.every(isNumeric)) {
              throw new Error("mixed numeric and non-numeric field names are not allowed");
            }
            return _stellarBase.xdr.ScVal.scvVec(fields.map(function(_, i) {
              return _this4.nativeToScVal(val[i], fields[i].type());
            }));
          }
          return _stellarBase.xdr.ScVal.scvMap(fields.map(function(field) {
            var name = field.name().toString();
            return new _stellarBase.xdr.ScMapEntry({
              key: _this4.nativeToScVal(name, _stellarBase.xdr.ScSpecTypeDef.scSpecTypeSymbol()),
              val: _this4.nativeToScVal(val[name], field.type())
            });
          }));
        }
      }, {
        key: "nativeToEnum",
        value: function nativeToEnum(val, enum_) {
          if (enum_.cases().some(function(entry) {
            return entry.value() === val;
          })) {
            return _stellarBase.xdr.ScVal.scvU32(val);
          }
          throw new TypeError("no such enum entry: ".concat(val, " in ").concat(enum_));
        }
      }, {
        key: "scValStrToNative",
        value: function scValStrToNative(scv, typeDef) {
          return this.scValToNative(_stellarBase.xdr.ScVal.fromXDR(scv, "base64"), typeDef);
        }
      }, {
        key: "scValToNative",
        value: function scValToNative(scv, typeDef) {
          var _this5 = this;
          var t = typeDef.switch();
          var value = t.value;
          if (value === _stellarBase.xdr.ScSpecType.scSpecTypeUdt().value) {
            return this.scValUdtToNative(scv, typeDef.udt());
          }
          switch (scv.switch().value) {
            case _stellarBase.xdr.ScValType.scvVoid().value:
              return void 0;
            case _stellarBase.xdr.ScValType.scvU64().value:
            case _stellarBase.xdr.ScValType.scvI64().value:
            case _stellarBase.xdr.ScValType.scvU128().value:
            case _stellarBase.xdr.ScValType.scvI128().value:
            case _stellarBase.xdr.ScValType.scvU256().value:
            case _stellarBase.xdr.ScValType.scvI256().value:
              return (0, _stellarBase.scValToBigInt)(scv);
            case _stellarBase.xdr.ScValType.scvVec().value: {
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeVec().value) {
                var _scv$vec;
                var vec = typeDef.vec();
                return ((_scv$vec = scv.vec()) !== null && _scv$vec !== void 0 ? _scv$vec : []).map(function(elm) {
                  return _this5.scValToNative(elm, vec.elementType());
                });
              }
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeTuple().value) {
                var _scv$vec2;
                var tuple = typeDef.tuple();
                var valTypes = tuple.valueTypes();
                return ((_scv$vec2 = scv.vec()) !== null && _scv$vec2 !== void 0 ? _scv$vec2 : []).map(function(elm, i) {
                  return _this5.scValToNative(elm, valTypes[i]);
                });
              }
              throw new TypeError("Type ".concat(typeDef, " was not vec, but ").concat(scv, " is"));
            }
            case _stellarBase.xdr.ScValType.scvAddress().value:
              return _stellarBase.Address.fromScVal(scv).toString();
            case _stellarBase.xdr.ScValType.scvMap().value: {
              var _scv$map;
              var map = (_scv$map = scv.map()) !== null && _scv$map !== void 0 ? _scv$map : [];
              if (value === _stellarBase.xdr.ScSpecType.scSpecTypeMap().value) {
                var typed = typeDef.map();
                var keyType = typed.keyType();
                var valueType = typed.valueType();
                var res = map.map(function(entry) {
                  return [_this5.scValToNative(entry.key(), keyType), _this5.scValToNative(entry.val(), valueType)];
                });
                return res;
              }
              throw new TypeError("ScSpecType ".concat(t.name, " was not map, but ").concat(JSON.stringify(scv, null, 2), " is"));
            }
            case _stellarBase.xdr.ScValType.scvBool().value:
            case _stellarBase.xdr.ScValType.scvU32().value:
            case _stellarBase.xdr.ScValType.scvI32().value:
            case _stellarBase.xdr.ScValType.scvBytes().value:
              return scv.value();
            case _stellarBase.xdr.ScValType.scvString().value:
            case _stellarBase.xdr.ScValType.scvSymbol().value: {
              var _scv$value;
              if (value !== _stellarBase.xdr.ScSpecType.scSpecTypeString().value && value !== _stellarBase.xdr.ScSpecType.scSpecTypeSymbol().value) {
                throw new Error("ScSpecType ".concat(t.name, " was not string or symbol, but ").concat(JSON.stringify(scv, null, 2), " is"));
              }
              return (_scv$value = scv.value()) === null || _scv$value === void 0 ? void 0 : _scv$value.toString();
            }
            case _stellarBase.xdr.ScValType.scvTimepoint().value:
            case _stellarBase.xdr.ScValType.scvDuration().value:
              return (0, _stellarBase.scValToBigInt)(_stellarBase.xdr.ScVal.scvU64(scv.u64()));
            default:
              throw new TypeError("failed to convert ".concat(JSON.stringify(scv, null, 2), " to native type from type ").concat(t.name));
          }
        }
      }, {
        key: "scValUdtToNative",
        value: function scValUdtToNative(scv, udt) {
          var entry = this.findEntry(udt.name().toString());
          switch (entry.switch()) {
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0():
              return this.enumToNative(scv);
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0():
              return this.structToNative(scv, entry.udtStructV0());
            case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0():
              return this.unionToNative(scv, entry.udtUnionV0());
            default:
              throw new Error("failed to parse udt ".concat(udt.name().toString(), ": ").concat(entry));
          }
        }
      }, {
        key: "unionToNative",
        value: function unionToNative(val, udt) {
          var _this6 = this;
          var vec = val.vec();
          if (!vec) {
            throw new Error("".concat(JSON.stringify(val, null, 2), " is not a vec"));
          }
          if (vec.length === 0 && udt.cases.length !== 0) {
            throw new Error("".concat(val, " has length 0, but the there are at least one case in the union"));
          }
          var name = vec[0].sym().toString();
          if (vec[0].switch().value !== _stellarBase.xdr.ScValType.scvSymbol().value) {
            throw new Error("{vec[0]} is not a symbol");
          }
          var entry = udt.cases().find(findCase(name));
          if (!entry) {
            throw new Error("failed to find entry ".concat(name, " in union {udt.name().toString()}"));
          }
          var res = {
            tag: name
          };
          if (entry.switch().value === _stellarBase.xdr.ScSpecUdtUnionCaseV0Kind.scSpecUdtUnionCaseTupleV0().value) {
            var tuple = entry.tupleCase();
            var ty = tuple.type();
            var values = ty.map(function(e, i) {
              return _this6.scValToNative(vec[i + 1], e);
            });
            res.values = values;
          }
          return res;
        }
      }, {
        key: "structToNative",
        value: function structToNative(val, udt) {
          var _this7 = this, _val$map;
          var res = {};
          var fields = udt.fields();
          if (fields.some(isNumeric)) {
            var _val$vec;
            var r = (_val$vec = val.vec()) === null || _val$vec === void 0 ? void 0 : _val$vec.map(function(entry, i) {
              return _this7.scValToNative(entry, fields[i].type());
            });
            return r;
          }
          (_val$map = val.map()) === null || _val$map === void 0 || _val$map.forEach(function(entry, i) {
            var field = fields[i];
            res[field.name().toString()] = _this7.scValToNative(entry.val(), field.type());
          });
          return res;
        }
      }, {
        key: "enumToNative",
        value: function enumToNative(scv) {
          if (scv.switch().value !== _stellarBase.xdr.ScValType.scvU32().value) {
            throw new Error("Enum must have a u32 value");
          }
          var num = scv.u32();
          return num;
        }
      }, {
        key: "errorCases",
        value: function errorCases() {
          return this.entries.filter(function(entry) {
            return entry.switch().value === _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value;
          }).flatMap(function(entry) {
            return entry.value().cases();
          });
        }
      }, {
        key: "jsonSchema",
        value: function jsonSchema(funcName) {
          var definitions = {};
          this.entries.forEach(function(entry) {
            switch (entry.switch().value) {
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtEnumV0().value: {
                var udt = entry.udtEnumV0();
                definitions[udt.name().toString()] = enumToJsonSchema(udt);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtStructV0().value: {
                var _udt = entry.udtStructV0();
                definitions[_udt.name().toString()] = structToJsonSchema(_udt);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtUnionV0().value: {
                var _udt2 = entry.udtUnionV0();
                definitions[_udt2.name().toString()] = unionToJsonSchema(_udt2);
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryFunctionV0().value: {
                var fn = entry.functionV0();
                var fnName = fn.name().toString();
                var _functionToJsonSchema = functionToJsonSchema(fn), input = _functionToJsonSchema.input;
                definitions[fnName] = input;
                break;
              }
              case _stellarBase.xdr.ScSpecEntryKind.scSpecEntryUdtErrorEnumV0().value: {
              }
            }
          });
          var res = {
            $schema: "http://json-schema.org/draft-07/schema#",
            definitions: _objectSpread(_objectSpread({}, PRIMITIVE_DEFINITONS), definitions)
          };
          if (funcName) {
            res.$ref = "#/definitions/".concat(funcName);
          }
          return res;
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/lib/contract/client.js
var require_client = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/contract/client.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Client = void 0;
    var _stellarBase = require_lib();
    var _spec = require_spec();
    var _rpc = require_rpc();
    var _assembled_transaction = require_assembled_transaction();
    var _utils = require_utils();
    var _excluded = ["method"];
    var _excluded2 = ["wasmHash", "salt", "format", "fee", "timeoutInSeconds", "simulate"];
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define({}, "");
      } catch (t2) {
        define = function define2(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function() {
        return this;
      }), define(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _objectWithoutProperties(e, t) {
      if (null == e) return {};
      var o, r, i = _objectWithoutPropertiesLoose(e, t);
      if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(e);
        for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }
    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (-1 !== e.indexOf(n)) continue;
        t[n] = r[n];
      }
      return t;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    var CONSTRUCTOR_FUNC = "__constructor";
    function specFromWasm(_x) {
      return _specFromWasm.apply(this, arguments);
    }
    function _specFromWasm() {
      _specFromWasm = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(wasm) {
        var xdrSections, wasmModule, customData, bufferSection, specEntryArray, spec;
        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return WebAssembly.compile(wasm);
            case 3:
              wasmModule = _context5.sent;
              xdrSections = WebAssembly.Module.customSections(wasmModule, "contractspecv0");
              _context5.next = 11;
              break;
            case 7:
              _context5.prev = 7;
              _context5.t0 = _context5["catch"](0);
              customData = parseWasmCustomSections(wasm);
              xdrSections = customData.get("contractspecv0");
            case 11:
              if (!(!xdrSections || xdrSections.length === 0)) {
                _context5.next = 13;
                break;
              }
              throw new Error("Could not obtain contract spec from wasm");
            case 13:
              bufferSection = Buffer.from(xdrSections[0]);
              specEntryArray = (0, _utils.processSpecEntryStream)(bufferSection);
              spec = new _spec.Spec(specEntryArray);
              return _context5.abrupt("return", spec);
            case 17:
            case "end":
              return _context5.stop();
          }
        }, _callee5, null, [[0, 7]]);
      }));
      return _specFromWasm.apply(this, arguments);
    }
    function parseWasmCustomSections(buffer) {
      var sections = /* @__PURE__ */ new Map();
      var arrayBuffer = buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
      var offset = 0;
      var read = function read2(length) {
        if (offset + length > buffer.byteLength) throw new Error("Buffer overflow");
        var bytes = new Uint8Array(arrayBuffer, offset, length);
        offset += length;
        return bytes;
      };
      if (_toConsumableArray(read(4)).join() !== "0,97,115,109") throw new Error("Invalid WASM magic");
      if (_toConsumableArray(read(4)).join() !== "1,0,0,0") throw new Error("Invalid WASM version");
      while (offset < buffer.byteLength) {
        var sectionId = read(1)[0];
        var sectionLength = readVarUint32();
        var start = offset;
        if (sectionId === 0) {
          var nameLen = readVarUint32();
          if (nameLen === 0 || offset + nameLen > start + sectionLength) continue;
          var nameBytes = read(nameLen);
          var payload = read(sectionLength - (offset - start));
          try {
            var name = new TextDecoder("utf-8", {
              fatal: true
            }).decode(nameBytes);
            if (payload.length > 0) {
              sections.set(name, (sections.get(name) || []).concat(payload));
            }
          } catch (_unused) {
          }
        } else {
          offset += sectionLength;
        }
      }
      function readVarUint32() {
        var value = 0, shift = 0;
        while (true) {
          var byte = read(1)[0];
          value |= (byte & 127) << shift;
          if ((byte & 128) === 0) break;
          if ((shift += 7) >= 32) throw new Error("Invalid WASM value");
        }
        return value >>> 0;
      }
      return sections;
    }
    function specFromWasmHash(_x2, _x3) {
      return _specFromWasmHash.apply(this, arguments);
    }
    function _specFromWasmHash() {
      _specFromWasmHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6(wasmHash, options) {
        var format, rpcUrl, allowHttp, serverOpts, server, wasm, _args6 = arguments;
        return _regeneratorRuntime().wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              format = _args6.length > 2 && _args6[2] !== void 0 ? _args6[2] : "hex";
              if (!(!options || !options.rpcUrl)) {
                _context6.next = 3;
                break;
              }
              throw new TypeError("options must contain rpcUrl");
            case 3:
              rpcUrl = options.rpcUrl, allowHttp = options.allowHttp;
              serverOpts = {
                allowHttp
              };
              server = new _rpc.Server(rpcUrl, serverOpts);
              _context6.next = 8;
              return server.getContractWasmByHash(wasmHash, format);
            case 8:
              wasm = _context6.sent;
              return _context6.abrupt("return", specFromWasm(wasm));
            case 10:
            case "end":
              return _context6.stop();
          }
        }, _callee6);
      }));
      return _specFromWasmHash.apply(this, arguments);
    }
    var Client = exports.Client = function() {
      function Client2(spec, options) {
        var _this = this;
        _classCallCheck(this, Client2);
        _defineProperty(this, "txFromJSON", function(json) {
          var _JSON$parse = JSON.parse(json), method = _JSON$parse.method, tx = _objectWithoutProperties(_JSON$parse, _excluded);
          return _assembled_transaction.AssembledTransaction.fromJSON(_objectSpread(_objectSpread({}, _this.options), {}, {
            method,
            parseResultXdr: function parseResultXdr(result) {
              return _this.spec.funcResToNative(method, result);
            }
          }), tx);
        });
        _defineProperty(this, "txFromXDR", function(xdrBase64) {
          return _assembled_transaction.AssembledTransaction.fromXDR(_this.options, xdrBase64, _this.spec);
        });
        this.spec = spec;
        this.options = options;
        this.spec.funcs().forEach(function(xdrFn) {
          var method = xdrFn.name().toString();
          if (method === CONSTRUCTOR_FUNC) {
            return;
          }
          var assembleTransaction = function assembleTransaction2(args, methodOptions) {
            return _assembled_transaction.AssembledTransaction.build(_objectSpread(_objectSpread(_objectSpread({
              method,
              args: args && spec.funcArgsToScVals(method, args)
            }, options), methodOptions), {}, {
              errorTypes: spec.errorCases().reduce(function(acc, curr) {
                return _objectSpread(_objectSpread({}, acc), {}, _defineProperty({}, curr.value(), {
                  message: curr.doc().toString()
                }));
              }, {}),
              parseResultXdr: function parseResultXdr(result) {
                return spec.funcResToNative(method, result);
              }
            }));
          };
          _this[method] = spec.getFunc(method).inputs().length === 0 ? function(opts) {
            return assembleTransaction(void 0, opts);
          } : assembleTransaction;
        });
      }
      return _createClass(Client2, null, [{
        key: "deploy",
        value: function() {
          var _deploy = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(args, options) {
            var wasmHash, salt, format, fee, timeoutInSeconds, simulate, clientOptions, spec, operation;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  wasmHash = options.wasmHash, salt = options.salt, format = options.format, fee = options.fee, timeoutInSeconds = options.timeoutInSeconds, simulate = options.simulate, clientOptions = _objectWithoutProperties(options, _excluded2);
                  _context.next = 3;
                  return specFromWasmHash(wasmHash, clientOptions, format);
                case 3:
                  spec = _context.sent;
                  operation = _stellarBase.Operation.createCustomContract({
                    address: new _stellarBase.Address(options.address || options.publicKey),
                    wasmHash: typeof wasmHash === "string" ? Buffer.from(wasmHash, format !== null && format !== void 0 ? format : "hex") : wasmHash,
                    salt,
                    constructorArgs: args ? spec.funcArgsToScVals(CONSTRUCTOR_FUNC, args) : []
                  });
                  return _context.abrupt("return", _assembled_transaction.AssembledTransaction.buildWithOp(operation, _objectSpread(_objectSpread({
                    fee,
                    timeoutInSeconds,
                    simulate
                  }, clientOptions), {}, {
                    contractId: "ignored",
                    method: CONSTRUCTOR_FUNC,
                    parseResultXdr: function parseResultXdr(result) {
                      return new Client2(spec, _objectSpread(_objectSpread({}, clientOptions), {}, {
                        contractId: _stellarBase.Address.fromScVal(result).toString()
                      }));
                    }
                  })));
                case 6:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          function deploy(_x4, _x5) {
            return _deploy.apply(this, arguments);
          }
          return deploy;
        }()
      }, {
        key: "fromWasmHash",
        value: function() {
          var _fromWasmHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2(wasmHash, options) {
            var format, rpcUrl, allowHttp, serverOpts, server, wasm, _args2 = arguments;
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  format = _args2.length > 2 && _args2[2] !== void 0 ? _args2[2] : "hex";
                  if (!(!options || !options.rpcUrl)) {
                    _context2.next = 3;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl");
                case 3:
                  rpcUrl = options.rpcUrl, allowHttp = options.allowHttp;
                  serverOpts = {
                    allowHttp
                  };
                  server = new _rpc.Server(rpcUrl, serverOpts);
                  _context2.next = 8;
                  return server.getContractWasmByHash(wasmHash, format);
                case 8:
                  wasm = _context2.sent;
                  return _context2.abrupt("return", Client2.fromWasm(wasm, options));
                case 10:
                case "end":
                  return _context2.stop();
              }
            }, _callee2);
          }));
          function fromWasmHash(_x6, _x7) {
            return _fromWasmHash.apply(this, arguments);
          }
          return fromWasmHash;
        }()
      }, {
        key: "fromWasm",
        value: function() {
          var _fromWasm = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(wasm, options) {
            var spec;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return specFromWasm(wasm);
                case 2:
                  spec = _context3.sent;
                  return _context3.abrupt("return", new Client2(spec, options));
                case 4:
                case "end":
                  return _context3.stop();
              }
            }, _callee3);
          }));
          function fromWasm(_x8, _x9) {
            return _fromWasm.apply(this, arguments);
          }
          return fromWasm;
        }()
      }, {
        key: "from",
        value: function() {
          var _from = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(options) {
            var rpcUrl, contractId, allowHttp, serverOpts, server, wasm;
            return _regeneratorRuntime().wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  if (!(!options || !options.rpcUrl || !options.contractId)) {
                    _context4.next = 2;
                    break;
                  }
                  throw new TypeError("options must contain rpcUrl and contractId");
                case 2:
                  rpcUrl = options.rpcUrl, contractId = options.contractId, allowHttp = options.allowHttp;
                  serverOpts = {
                    allowHttp
                  };
                  server = new _rpc.Server(rpcUrl, serverOpts);
                  _context4.next = 7;
                  return server.getContractWasmByContractId(contractId);
                case 7:
                  wasm = _context4.sent;
                  return _context4.abrupt("return", Client2.fromWasm(wasm, options));
                case 9:
                case "end":
                  return _context4.stop();
              }
            }, _callee4);
          }));
          function from(_x10) {
            return _from.apply(this, arguments);
          }
          return from;
        }()
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/lib/contract/index.js
var require_contract = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/contract/index.js"(exports) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _assembled_transaction = require_assembled_transaction();
    Object.keys(_assembled_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _assembled_transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _assembled_transaction[key];
        }
      });
    });
    var _basic_node_signer = require_basic_node_signer();
    Object.keys(_basic_node_signer).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _basic_node_signer[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _basic_node_signer[key];
        }
      });
    });
    var _client = require_client();
    Object.keys(_client).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _client[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _client[key];
        }
      });
    });
    var _rust_result = require_rust_result();
    Object.keys(_rust_result).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _rust_result[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _rust_result[key];
        }
      });
    });
    var _sent_transaction = require_sent_transaction();
    Object.keys(_sent_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _sent_transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _sent_transaction[key];
        }
      });
    });
    var _spec = require_spec();
    Object.keys(_spec).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _spec[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _spec[key];
        }
      });
    });
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (key in exports && exports[key] === _types[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _types[key];
        }
      });
    });
  }
});
export default require_contract();
//# sourceMappingURL=@stellar_stellar-sdk_contract.js.map
