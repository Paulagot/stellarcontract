import __buffer_polyfill from 'vite-plugin-node-polyfills/shims/buffer'
globalThis.Buffer = globalThis.Buffer || __buffer_polyfill
import __global_polyfill from 'vite-plugin-node-polyfills/shims/global'
globalThis.global = globalThis.global || __global_polyfill
import __process_polyfill from 'vite-plugin-node-polyfills/shims/process'
globalThis.process = globalThis.process || __process_polyfill

import {
  require_inherits_browser,
  require_nacl_fast,
  require_safe_buffer
} from "./chunk-B6WC3SW2.js";
import {
  __commonJS,
  __toESM,
  require_dist,
  require_dist2,
  require_dist3
} from "./chunk-KI2BRAH6.js";

// node_modules/@stellar/stellar-sdk/lib/rpc/api.js
var require_api = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/rpc/api.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Api = void 0;
    var Api;
    (function(_Api) {
      var GetTransactionStatus = function(GetTransactionStatus2) {
        GetTransactionStatus2["SUCCESS"] = "SUCCESS";
        GetTransactionStatus2["NOT_FOUND"] = "NOT_FOUND";
        GetTransactionStatus2["FAILED"] = "FAILED";
        return GetTransactionStatus2;
      }({});
      _Api.GetTransactionStatus = GetTransactionStatus;
      function isSimulationError(sim) {
        return "error" in sim;
      }
      _Api.isSimulationError = isSimulationError;
      function isSimulationSuccess(sim) {
        return "transactionData" in sim;
      }
      _Api.isSimulationSuccess = isSimulationSuccess;
      function isSimulationRestore(sim) {
        return isSimulationSuccess(sim) && "restorePreamble" in sim && !!sim.restorePreamble.transactionData;
      }
      _Api.isSimulationRestore = isSimulationRestore;
      function isSimulationRaw(sim) {
        return !sim._parsed;
      }
      _Api.isSimulationRaw = isSimulationRaw;
    })(Api || (exports.Api = Api = {}));
  }
});

// node_modules/urijs/src/punycode.js
var require_punycode = __commonJS({
  "node_modules/urijs/src/punycode.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (function(root) {
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = typeof module == "object" && module && !module.nodeType && module;
      var freeGlobal = typeof global == "object" && global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
        root = freeGlobal;
      }
      var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
        "overflow": "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
      function error(type) {
        throw new RangeError(errors[type]);
      }
      function map(array, fn) {
        var length = array.length;
        var result = [];
        while (length--) {
          result[length] = fn(array[length]);
        }
        return result;
      }
      function mapDomain(string, fn) {
        var parts = string.split("@");
        var result = "";
        if (parts.length > 1) {
          result = parts[0] + "@";
          string = parts[1];
        }
        string = string.replace(regexSeparators, ".");
        var labels = string.split(".");
        var encoded = map(labels, fn).join(".");
        return result + encoded;
      }
      function ucs2decode(string) {
        var output = [], counter = 0, length = string.length, value, extra;
        while (counter < length) {
          value = string.charCodeAt(counter++);
          if (value >= 55296 && value <= 56319 && counter < length) {
            extra = string.charCodeAt(counter++);
            if ((extra & 64512) == 56320) {
              output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
            } else {
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }
      function ucs2encode(array) {
        return map(array, function(value) {
          var output = "";
          if (value > 65535) {
            value -= 65536;
            output += stringFromCharCode(value >>> 10 & 1023 | 55296);
            value = 56320 | value & 1023;
          }
          output += stringFromCharCode(value);
          return output;
        }).join("");
      }
      function basicToDigit(codePoint) {
        if (codePoint - 48 < 10) {
          return codePoint - 22;
        }
        if (codePoint - 65 < 26) {
          return codePoint - 65;
        }
        if (codePoint - 97 < 26) {
          return codePoint - 97;
        }
        return base;
      }
      function digitToBasic(digit, flag) {
        return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
      }
      function adapt(delta, numPoints, firstTime) {
        var k = 0;
        delta = firstTime ? floor(delta / damp) : delta >> 1;
        delta += floor(delta / numPoints);
        for (; delta > baseMinusTMin * tMax >> 1; k += base) {
          delta = floor(delta / baseMinusTMin);
        }
        return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
      }
      function decode(input) {
        var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
        basic = input.lastIndexOf(delimiter);
        if (basic < 0) {
          basic = 0;
        }
        for (j = 0; j < basic; ++j) {
          if (input.charCodeAt(j) >= 128) {
            error("not-basic");
          }
          output.push(input.charCodeAt(j));
        }
        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
          for (oldi = i, w = 1, k = base; ; k += base) {
            if (index >= inputLength) {
              error("invalid-input");
            }
            digit = basicToDigit(input.charCodeAt(index++));
            if (digit >= base || digit > floor((maxInt - i) / w)) {
              error("overflow");
            }
            i += digit * w;
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
            if (digit < t) {
              break;
            }
            baseMinusT = base - t;
            if (w > floor(maxInt / baseMinusT)) {
              error("overflow");
            }
            w *= baseMinusT;
          }
          out = output.length + 1;
          bias = adapt(i - oldi, out, oldi == 0);
          if (floor(i / out) > maxInt - n) {
            error("overflow");
          }
          n += floor(i / out);
          i %= out;
          output.splice(i++, 0, n);
        }
        return ucs2encode(output);
      }
      function encode(input) {
        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
        input = ucs2decode(input);
        inputLength = input.length;
        n = initialN;
        delta = 0;
        bias = initialBias;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < 128) {
            output.push(stringFromCharCode(currentValue));
          }
        }
        handledCPCount = basicLength = output.length;
        if (basicLength) {
          output.push(delimiter);
        }
        while (handledCPCount < inputLength) {
          for (m = maxInt, j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
          handledCPCountPlusOne = handledCPCount + 1;
          if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
            error("overflow");
          }
          delta += (m - n) * handledCPCountPlusOne;
          n = m;
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < n && ++delta > maxInt) {
              error("overflow");
            }
            if (currentValue == n) {
              for (q = delta, k = base; ; k += base) {
                t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                qMinusT = q - t;
                baseMinusT = base - t;
                output.push(
                  stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                );
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
          ++delta;
          ++n;
        }
        return output.join("");
      }
      function toUnicode(input) {
        return mapDomain(input, function(string) {
          return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
        });
      }
      function toASCII(input) {
        return mapDomain(input, function(string) {
          return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
        });
      }
      punycode = {
        /**
         * A string representing the current Punycode.js version number.
         * @memberOf punycode
         * @type String
         */
        "version": "1.3.2",
        /**
         * An object of methods to convert from JavaScript's internal character
         * representation (UCS-2) to Unicode code points, and back.
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode
         * @type Object
         */
        "ucs2": {
          "decode": ucs2decode,
          "encode": ucs2encode
        },
        "decode": decode,
        "encode": encode,
        "toASCII": toASCII,
        "toUnicode": toUnicode
      };
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        define("punycode", function() {
          return punycode;
        });
      } else if (freeExports && freeModule) {
        if (module.exports == freeExports) {
          freeModule.exports = punycode;
        } else {
          for (key in punycode) {
            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
          }
        }
      } else {
        root.punycode = punycode;
      }
    })(exports);
  }
});

// node_modules/urijs/src/IPv6.js
var require_IPv6 = __commonJS({
  "node_modules/urijs/src/IPv6.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.IPv6 = factory(root);
      }
    })(exports, function(root) {
      "use strict";
      var _IPv6 = root && root.IPv6;
      function bestPresentation(address) {
        var _address = address.toLowerCase();
        var segments = _address.split(":");
        var length = segments.length;
        var total = 8;
        if (segments[0] === "" && segments[1] === "" && segments[2] === "") {
          segments.shift();
          segments.shift();
        } else if (segments[0] === "" && segments[1] === "") {
          segments.shift();
        } else if (segments[length - 1] === "" && segments[length - 2] === "") {
          segments.pop();
        }
        length = segments.length;
        if (segments[length - 1].indexOf(".") !== -1) {
          total = 7;
        }
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (segments[pos] === "") {
            break;
          }
        }
        if (pos < total) {
          segments.splice(pos, 1, "0000");
          while (segments.length < total) {
            segments.splice(pos, 0, "0000");
          }
        }
        var _segments;
        for (var i = 0; i < total; i++) {
          _segments = segments[i].split("");
          for (var j = 0; j < 3; j++) {
            if (_segments[0] === "0" && _segments.length > 1) {
              _segments.splice(0, 1);
            } else {
              break;
            }
          }
          segments[i] = _segments.join("");
        }
        var best = -1;
        var _best = 0;
        var _current = 0;
        var current = -1;
        var inzeroes = false;
        for (i = 0; i < total; i++) {
          if (inzeroes) {
            if (segments[i] === "0") {
              _current += 1;
            } else {
              inzeroes = false;
              if (_current > _best) {
                best = current;
                _best = _current;
              }
            }
          } else {
            if (segments[i] === "0") {
              inzeroes = true;
              current = i;
              _current = 1;
            }
          }
        }
        if (_current > _best) {
          best = current;
          _best = _current;
        }
        if (_best > 1) {
          segments.splice(best, _best, "");
        }
        length = segments.length;
        var result = "";
        if (segments[0] === "") {
          result = ":";
        }
        for (i = 0; i < length; i++) {
          result += segments[i];
          if (i === length - 1) {
            break;
          }
          result += ":";
        }
        if (segments[length - 1] === "") {
          result += ":";
        }
        return result;
      }
      function noConflict() {
        if (root.IPv6 === this) {
          root.IPv6 = _IPv6;
        }
        return this;
      }
      return {
        best: bestPresentation,
        noConflict
      };
    });
  }
});

// node_modules/urijs/src/SecondLevelDomains.js
var require_SecondLevelDomains = __commonJS({
  "node_modules/urijs/src/SecondLevelDomains.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        root.SecondLevelDomains = factory(root);
      }
    })(exports, function(root) {
      "use strict";
      var _SecondLevelDomains = root && root.SecondLevelDomains;
      var SLD = {
        // list of known Second Level Domains
        // converted list of SLDs from https://github.com/gavingmiller/second-level-domains
        // ----
        // publicsuffix.org is more current and actually used by a couple of browsers internally.
        // downside is it also contains domains like "dyndns.org" - which is fine for the security
        // issues browser have to deal with (SOP for cookies, etc) - but is way overboard for URI.js
        // ----
        list: {
          "ac": " com gov mil net org ",
          "ae": " ac co gov mil name net org pro sch ",
          "af": " com edu gov net org ",
          "al": " com edu gov mil net org ",
          "ao": " co ed gv it og pb ",
          "ar": " com edu gob gov int mil net org tur ",
          "at": " ac co gv or ",
          "au": " asn com csiro edu gov id net org ",
          "ba": " co com edu gov mil net org rs unbi unmo unsa untz unze ",
          "bb": " biz co com edu gov info net org store tv ",
          "bh": " biz cc com edu gov info net org ",
          "bn": " com edu gov net org ",
          "bo": " com edu gob gov int mil net org tv ",
          "br": " adm adv agr am arq art ato b bio blog bmd cim cng cnt com coop ecn edu eng esp etc eti far flog fm fnd fot fst g12 ggf gov imb ind inf jor jus lel mat med mil mus net nom not ntr odo org ppg pro psc psi qsl rec slg srv tmp trd tur tv vet vlog wiki zlg ",
          "bs": " com edu gov net org ",
          "bz": " du et om ov rg ",
          "ca": " ab bc mb nb nf nl ns nt nu on pe qc sk yk ",
          "ck": " biz co edu gen gov info net org ",
          "cn": " ac ah bj com cq edu fj gd gov gs gx gz ha hb he hi hl hn jl js jx ln mil net nm nx org qh sc sd sh sn sx tj tw xj xz yn zj ",
          "co": " com edu gov mil net nom org ",
          "cr": " ac c co ed fi go or sa ",
          "cy": " ac biz com ekloges gov ltd name net org parliament press pro tm ",
          "do": " art com edu gob gov mil net org sld web ",
          "dz": " art asso com edu gov net org pol ",
          "ec": " com edu fin gov info med mil net org pro ",
          "eg": " com edu eun gov mil name net org sci ",
          "er": " com edu gov ind mil net org rochest w ",
          "es": " com edu gob nom org ",
          "et": " biz com edu gov info name net org ",
          "fj": " ac biz com info mil name net org pro ",
          "fk": " ac co gov net nom org ",
          "fr": " asso com f gouv nom prd presse tm ",
          "gg": " co net org ",
          "gh": " com edu gov mil org ",
          "gn": " ac com gov net org ",
          "gr": " com edu gov mil net org ",
          "gt": " com edu gob ind mil net org ",
          "gu": " com edu gov net org ",
          "hk": " com edu gov idv net org ",
          "hu": " 2000 agrar bolt casino city co erotica erotika film forum games hotel info ingatlan jogasz konyvelo lakas media news org priv reklam sex shop sport suli szex tm tozsde utazas video ",
          "id": " ac co go mil net or sch web ",
          "il": " ac co gov idf k12 muni net org ",
          "in": " ac co edu ernet firm gen gov i ind mil net nic org res ",
          "iq": " com edu gov i mil net org ",
          "ir": " ac co dnssec gov i id net org sch ",
          "it": " edu gov ",
          "je": " co net org ",
          "jo": " com edu gov mil name net org sch ",
          "jp": " ac ad co ed go gr lg ne or ",
          "ke": " ac co go info me mobi ne or sc ",
          "kh": " com edu gov mil net org per ",
          "ki": " biz com de edu gov info mob net org tel ",
          "km": " asso com coop edu gouv k medecin mil nom notaires pharmaciens presse tm veterinaire ",
          "kn": " edu gov net org ",
          "kr": " ac busan chungbuk chungnam co daegu daejeon es gangwon go gwangju gyeongbuk gyeonggi gyeongnam hs incheon jeju jeonbuk jeonnam k kg mil ms ne or pe re sc seoul ulsan ",
          "kw": " com edu gov net org ",
          "ky": " com edu gov net org ",
          "kz": " com edu gov mil net org ",
          "lb": " com edu gov net org ",
          "lk": " assn com edu gov grp hotel int ltd net ngo org sch soc web ",
          "lr": " com edu gov net org ",
          "lv": " asn com conf edu gov id mil net org ",
          "ly": " com edu gov id med net org plc sch ",
          "ma": " ac co gov m net org press ",
          "mc": " asso tm ",
          "me": " ac co edu gov its net org priv ",
          "mg": " com edu gov mil nom org prd tm ",
          "mk": " com edu gov inf name net org pro ",
          "ml": " com edu gov net org presse ",
          "mn": " edu gov org ",
          "mo": " com edu gov net org ",
          "mt": " com edu gov net org ",
          "mv": " aero biz com coop edu gov info int mil museum name net org pro ",
          "mw": " ac co com coop edu gov int museum net org ",
          "mx": " com edu gob net org ",
          "my": " com edu gov mil name net org sch ",
          "nf": " arts com firm info net other per rec store web ",
          "ng": " biz com edu gov mil mobi name net org sch ",
          "ni": " ac co com edu gob mil net nom org ",
          "np": " com edu gov mil net org ",
          "nr": " biz com edu gov info net org ",
          "om": " ac biz co com edu gov med mil museum net org pro sch ",
          "pe": " com edu gob mil net nom org sld ",
          "ph": " com edu gov i mil net ngo org ",
          "pk": " biz com edu fam gob gok gon gop gos gov net org web ",
          "pl": " art bialystok biz com edu gda gdansk gorzow gov info katowice krakow lodz lublin mil net ngo olsztyn org poznan pwr radom slupsk szczecin torun warszawa waw wroc wroclaw zgora ",
          "pr": " ac biz com edu est gov info isla name net org pro prof ",
          "ps": " com edu gov net org plo sec ",
          "pw": " belau co ed go ne or ",
          "ro": " arts com firm info nom nt org rec store tm www ",
          "rs": " ac co edu gov in org ",
          "sb": " com edu gov net org ",
          "sc": " com edu gov net org ",
          "sh": " co com edu gov net nom org ",
          "sl": " com edu gov net org ",
          "st": " co com consulado edu embaixada gov mil net org principe saotome store ",
          "sv": " com edu gob org red ",
          "sz": " ac co org ",
          "tr": " av bbs bel biz com dr edu gen gov info k12 name net org pol tel tsk tv web ",
          "tt": " aero biz cat co com coop edu gov info int jobs mil mobi museum name net org pro tel travel ",
          "tw": " club com ebiz edu game gov idv mil net org ",
          "mu": " ac co com gov net or org ",
          "mz": " ac co edu gov org ",
          "na": " co com ",
          "nz": " ac co cri geek gen govt health iwi maori mil net org parliament school ",
          "pa": " abo ac com edu gob ing med net nom org sld ",
          "pt": " com edu gov int net nome org publ ",
          "py": " com edu gov mil net org ",
          "qa": " com edu gov mil net org ",
          "re": " asso com nom ",
          "ru": " ac adygeya altai amur arkhangelsk astrakhan bashkiria belgorod bir bryansk buryatia cbg chel chelyabinsk chita chukotka chuvashia com dagestan e-burg edu gov grozny int irkutsk ivanovo izhevsk jar joshkar-ola kalmykia kaluga kamchatka karelia kazan kchr kemerovo khabarovsk khakassia khv kirov koenig komi kostroma kranoyarsk kuban kurgan kursk lipetsk magadan mari mari-el marine mil mordovia mosreg msk murmansk nalchik net nnov nov novosibirsk nsk omsk orenburg org oryol penza perm pp pskov ptz rnd ryazan sakhalin samara saratov simbirsk smolensk spb stavropol stv surgut tambov tatarstan tom tomsk tsaritsyn tsk tula tuva tver tyumen udm udmurtia ulan-ude vladikavkaz vladimir vladivostok volgograd vologda voronezh vrn vyatka yakutia yamal yekaterinburg yuzhno-sakhalinsk ",
          "rw": " ac co com edu gouv gov int mil net ",
          "sa": " com edu gov med net org pub sch ",
          "sd": " com edu gov info med net org tv ",
          "se": " a ac b bd c d e f g h i k l m n o org p parti pp press r s t tm u w x y z ",
          "sg": " com edu gov idn net org per ",
          "sn": " art com edu gouv org perso univ ",
          "sy": " com edu gov mil net news org ",
          "th": " ac co go in mi net or ",
          "tj": " ac biz co com edu go gov info int mil name net nic org test web ",
          "tn": " agrinet com defense edunet ens fin gov ind info intl mincom nat net org perso rnrt rns rnu tourism ",
          "tz": " ac co go ne or ",
          "ua": " biz cherkassy chernigov chernovtsy ck cn co com crimea cv dn dnepropetrovsk donetsk dp edu gov if in ivano-frankivsk kh kharkov kherson khmelnitskiy kiev kirovograd km kr ks kv lg lugansk lutsk lviv me mk net nikolaev od odessa org pl poltava pp rovno rv sebastopol sumy te ternopil uzhgorod vinnica vn zaporizhzhe zhitomir zp zt ",
          "ug": " ac co go ne or org sc ",
          "uk": " ac bl british-library co cym gov govt icnet jet lea ltd me mil mod national-library-scotland nel net nhs nic nls org orgn parliament plc police sch scot soc ",
          "us": " dni fed isa kids nsn ",
          "uy": " com edu gub mil net org ",
          "ve": " co com edu gob info mil net org web ",
          "vi": " co com k12 net org ",
          "vn": " ac biz com edu gov health info int name net org pro ",
          "ye": " co com gov ltd me net org plc ",
          "yu": " ac co edu gov org ",
          "za": " ac agric alt bourse city co cybernet db edu gov grondar iaccess imt inca landesign law mil net ngo nis nom olivetti org pix school tm web ",
          "zm": " ac co com edu gov net org sch ",
          // https://en.wikipedia.org/wiki/CentralNic#Second-level_domains
          "com": "ar br cn de eu gb gr hu jpn kr no qc ru sa se uk us uy za ",
          "net": "gb jp se uk ",
          "org": "ae",
          "de": "com "
        },
        // gorhill 2013-10-25: Using indexOf() instead Regexp(). Significant boost
        // in both performance and memory footprint. No initialization required.
        // http://jsperf.com/uri-js-sld-regex-vs-binary-search/4
        // Following methods use lastIndexOf() rather than array.split() in order
        // to avoid any memory allocations.
        has: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") >= 0;
        },
        is: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return false;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset >= 0) {
            return false;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return false;
          }
          return sldList.indexOf(" " + domain.slice(0, tldOffset) + " ") >= 0;
        },
        get: function(domain) {
          var tldOffset = domain.lastIndexOf(".");
          if (tldOffset <= 0 || tldOffset >= domain.length - 1) {
            return null;
          }
          var sldOffset = domain.lastIndexOf(".", tldOffset - 1);
          if (sldOffset <= 0 || sldOffset >= tldOffset - 1) {
            return null;
          }
          var sldList = SLD.list[domain.slice(tldOffset + 1)];
          if (!sldList) {
            return null;
          }
          if (sldList.indexOf(" " + domain.slice(sldOffset + 1, tldOffset) + " ") < 0) {
            return null;
          }
          return domain.slice(sldOffset + 1);
        },
        noConflict: function() {
          if (root.SecondLevelDomains === this) {
            root.SecondLevelDomains = _SecondLevelDomains;
          }
          return this;
        }
      };
      return SLD;
    });
  }
});

// node_modules/urijs/src/URI.js
var require_URI = __commonJS({
  "node_modules/urijs/src/URI.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (function(root, factory) {
      "use strict";
      if (typeof module === "object" && module.exports) {
        module.exports = factory(require_punycode(), require_IPv6(), require_SecondLevelDomains());
      } else if (typeof define === "function" && define.amd) {
        define(["./punycode", "./IPv6", "./SecondLevelDomains"], factory);
      } else {
        root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
      }
    })(exports, function(punycode, IPv6, SLD, root) {
      "use strict";
      var _URI = root && root.URI;
      function URI(url, base) {
        var _urlSupplied = arguments.length >= 1;
        var _baseSupplied = arguments.length >= 2;
        if (!(this instanceof URI)) {
          if (_urlSupplied) {
            if (_baseSupplied) {
              return new URI(url, base);
            }
            return new URI(url);
          }
          return new URI();
        }
        if (url === void 0) {
          if (_urlSupplied) {
            throw new TypeError("undefined is not a valid argument for URI");
          }
          if (typeof location !== "undefined") {
            url = location.href + "";
          } else {
            url = "";
          }
        }
        if (url === null) {
          if (_urlSupplied) {
            throw new TypeError("null is not a valid argument for URI");
          }
        }
        this.href(url);
        if (base !== void 0) {
          return this.absoluteTo(base);
        }
        return this;
      }
      function isInteger(value) {
        return /^[0-9]+$/.test(value);
      }
      URI.version = "1.19.11";
      var p = URI.prototype;
      var hasOwn = Object.prototype.hasOwnProperty;
      function escapeRegEx(string) {
        return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, "\\$1");
      }
      function getType(value) {
        if (value === void 0) {
          return "Undefined";
        }
        return String(Object.prototype.toString.call(value)).slice(8, -1);
      }
      function isArray(obj) {
        return getType(obj) === "Array";
      }
      function filterArrayValues(data, value) {
        var lookup = {};
        var i, length;
        if (getType(value) === "RegExp") {
          lookup = null;
        } else if (isArray(value)) {
          for (i = 0, length = value.length; i < length; i++) {
            lookup[value[i]] = true;
          }
        } else {
          lookup[value] = true;
        }
        for (i = 0, length = data.length; i < length; i++) {
          var _match = lookup && lookup[data[i]] !== void 0 || !lookup && value.test(data[i]);
          if (_match) {
            data.splice(i, 1);
            length--;
            i--;
          }
        }
        return data;
      }
      function arrayContains(list, value) {
        var i, length;
        if (isArray(value)) {
          for (i = 0, length = value.length; i < length; i++) {
            if (!arrayContains(list, value[i])) {
              return false;
            }
          }
          return true;
        }
        var _type = getType(value);
        for (i = 0, length = list.length; i < length; i++) {
          if (_type === "RegExp") {
            if (typeof list[i] === "string" && list[i].match(value)) {
              return true;
            }
          } else if (list[i] === value) {
            return true;
          }
        }
        return false;
      }
      function arraysEqual(one, two) {
        if (!isArray(one) || !isArray(two)) {
          return false;
        }
        if (one.length !== two.length) {
          return false;
        }
        one.sort();
        two.sort();
        for (var i = 0, l = one.length; i < l; i++) {
          if (one[i] !== two[i]) {
            return false;
          }
        }
        return true;
      }
      function trimSlashes(text) {
        var trim_expression = /^\/+|\/+$/g;
        return text.replace(trim_expression, "");
      }
      URI._parts = function() {
        return {
          protocol: null,
          username: null,
          password: null,
          hostname: null,
          urn: null,
          port: null,
          path: null,
          query: null,
          fragment: null,
          // state
          preventInvalidHostname: URI.preventInvalidHostname,
          duplicateQueryParameters: URI.duplicateQueryParameters,
          escapeQuerySpace: URI.escapeQuerySpace
        };
      };
      URI.preventInvalidHostname = false;
      URI.duplicateQueryParameters = false;
      URI.escapeQuerySpace = true;
      URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
      URI.idn_expression = /[^a-z0-9\._-]/i;
      URI.punycode_expression = /(xn--)/i;
      URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
      URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
      URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
      URI.findUri = {
        // valid "scheme://" or "www."
        start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
        // everything up to the next whitespace
        end: /[\s\r\n]|$/,
        // trim trailing punctuation captured by end RegExp
        trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/,
        // balanced parens inclusion (), [], {}, <>
        parens: /(\([^\)]*\)|\[[^\]]*\]|\{[^}]*\}|<[^>]*>)/g
      };
      URI.leading_whitespace_expression = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/;
      URI.ascii_tab_whitespace = /[\u0009\u000A\u000D]+/g;
      URI.defaultPorts = {
        http: "80",
        https: "443",
        ftp: "21",
        gopher: "70",
        ws: "80",
        wss: "443"
      };
      URI.hostProtocols = [
        "http",
        "https"
      ];
      URI.invalid_hostname_characters = /[^a-zA-Z0-9\.\-:_]/;
      URI.domAttributes = {
        "a": "href",
        "blockquote": "cite",
        "link": "href",
        "base": "href",
        "script": "src",
        "form": "action",
        "img": "src",
        "area": "href",
        "iframe": "src",
        "embed": "src",
        "source": "src",
        "track": "src",
        "input": "src",
        // but only if type="image"
        "audio": "src",
        "video": "src"
      };
      URI.getDomAttribute = function(node) {
        if (!node || !node.nodeName) {
          return void 0;
        }
        var nodeName = node.nodeName.toLowerCase();
        if (nodeName === "input" && node.type !== "image") {
          return void 0;
        }
        return URI.domAttributes[nodeName];
      };
      function escapeForDumbFirefox36(value) {
        return escape(value);
      }
      function strictEncodeURIComponent(string) {
        return encodeURIComponent(string).replace(/[!'()*]/g, escapeForDumbFirefox36).replace(/\*/g, "%2A");
      }
      URI.encode = strictEncodeURIComponent;
      URI.decode = decodeURIComponent;
      URI.iso8859 = function() {
        URI.encode = escape;
        URI.decode = unescape;
      };
      URI.unicode = function() {
        URI.encode = strictEncodeURIComponent;
        URI.decode = decodeURIComponent;
      };
      URI.characters = {
        pathname: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
            map: {
              // -._~!'()*
              "%24": "$",
              "%26": "&",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%3A": ":",
              "%40": "@"
            }
          },
          decode: {
            expression: /[\/\?#]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23"
            }
          }
        },
        reserved: {
          encode: {
            // RFC3986 2.1: For consistency, URI producers and normalizers should
            // use uppercase hexadecimal digits for all percent-encodings.
            expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
            map: {
              // gen-delims
              "%3A": ":",
              "%2F": "/",
              "%3F": "?",
              "%23": "#",
              "%5B": "[",
              "%5D": "]",
              "%40": "@",
              // sub-delims
              "%21": "!",
              "%24": "$",
              "%26": "&",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "="
            }
          }
        },
        urnpath: {
          // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
          // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
          // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
          // note that the colon character is not featured in the encoding map; this is because URI.js
          // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
          // should not appear unencoded in a segment itself.
          // See also the note above about RFC3986 and capitalalized hex digits.
          encode: {
            expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
            map: {
              "%21": "!",
              "%24": "$",
              "%27": "'",
              "%28": "(",
              "%29": ")",
              "%2A": "*",
              "%2B": "+",
              "%2C": ",",
              "%3B": ";",
              "%3D": "=",
              "%40": "@"
            }
          },
          // These characters are the characters called out by RFC2141 as "reserved" characters that
          // should never appear in a URN, plus the colon character (see note above).
          decode: {
            expression: /[\/\?#:]/g,
            map: {
              "/": "%2F",
              "?": "%3F",
              "#": "%23",
              ":": "%3A"
            }
          }
        }
      };
      URI.encodeQuery = function(string, escapeQuerySpace) {
        var escaped = URI.encode(string + "");
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI.escapeQuerySpace;
        }
        return escapeQuerySpace ? escaped.replace(/%20/g, "+") : escaped;
      };
      URI.decodeQuery = function(string, escapeQuerySpace) {
        string += "";
        if (escapeQuerySpace === void 0) {
          escapeQuerySpace = URI.escapeQuerySpace;
        }
        try {
          return URI.decode(escapeQuerySpace ? string.replace(/\+/g, "%20") : string);
        } catch (e) {
          return string;
        }
      };
      var _parts = { "encode": "encode", "decode": "decode" };
      var _part;
      var generateAccessor = function(_group, _part2) {
        return function(string) {
          try {
            return URI[_part2](string + "").replace(URI.characters[_group][_part2].expression, function(c) {
              return URI.characters[_group][_part2].map[c];
            });
          } catch (e) {
            return string;
          }
        };
      };
      for (_part in _parts) {
        URI[_part + "PathSegment"] = generateAccessor("pathname", _parts[_part]);
        URI[_part + "UrnPathSegment"] = generateAccessor("urnpath", _parts[_part]);
      }
      var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
        return function(string) {
          var actualCodingFunc;
          if (!_innerCodingFuncName) {
            actualCodingFunc = URI[_codingFuncName];
          } else {
            actualCodingFunc = function(string2) {
              return URI[_codingFuncName](URI[_innerCodingFuncName](string2));
            };
          }
          var segments = (string + "").split(_sep);
          for (var i = 0, length = segments.length; i < length; i++) {
            segments[i] = actualCodingFunc(segments[i]);
          }
          return segments.join(_sep);
        };
      };
      URI.decodePath = generateSegmentedPathFunction("/", "decodePathSegment");
      URI.decodeUrnPath = generateSegmentedPathFunction(":", "decodeUrnPathSegment");
      URI.recodePath = generateSegmentedPathFunction("/", "encodePathSegment", "decode");
      URI.recodeUrnPath = generateSegmentedPathFunction(":", "encodeUrnPathSegment", "decode");
      URI.encodeReserved = generateAccessor("reserved", "encode");
      URI.parse = function(string, parts) {
        var pos;
        if (!parts) {
          parts = {
            preventInvalidHostname: URI.preventInvalidHostname
          };
        }
        string = string.replace(URI.leading_whitespace_expression, "");
        string = string.replace(URI.ascii_tab_whitespace, "");
        pos = string.indexOf("#");
        if (pos > -1) {
          parts.fragment = string.substring(pos + 1) || null;
          string = string.substring(0, pos);
        }
        pos = string.indexOf("?");
        if (pos > -1) {
          parts.query = string.substring(pos + 1) || null;
          string = string.substring(0, pos);
        }
        string = string.replace(/^(https?|ftp|wss?)?:+[/\\]*/i, "$1://");
        string = string.replace(/^[/\\]{2,}/i, "//");
        if (string.substring(0, 2) === "//") {
          parts.protocol = null;
          string = string.substring(2);
          string = URI.parseAuthority(string, parts);
        } else {
          pos = string.indexOf(":");
          if (pos > -1) {
            parts.protocol = string.substring(0, pos) || null;
            if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
              parts.protocol = void 0;
            } else if (string.substring(pos + 1, pos + 3).replace(/\\/g, "/") === "//") {
              string = string.substring(pos + 3);
              string = URI.parseAuthority(string, parts);
            } else {
              string = string.substring(pos + 1);
              parts.urn = true;
            }
          }
        }
        parts.path = string;
        return parts;
      };
      URI.parseHost = function(string, parts) {
        if (!string) {
          string = "";
        }
        string = string.replace(/\\/g, "/");
        var pos = string.indexOf("/");
        var bracketPos;
        var t;
        if (pos === -1) {
          pos = string.length;
        }
        if (string.charAt(0) === "[") {
          bracketPos = string.indexOf("]");
          parts.hostname = string.substring(1, bracketPos) || null;
          parts.port = string.substring(bracketPos + 2, pos) || null;
          if (parts.port === "/") {
            parts.port = null;
          }
        } else {
          var firstColon = string.indexOf(":");
          var firstSlash = string.indexOf("/");
          var nextColon = string.indexOf(":", firstColon + 1);
          if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
            parts.hostname = string.substring(0, pos) || null;
            parts.port = null;
          } else {
            t = string.substring(0, pos).split(":");
            parts.hostname = t[0] || null;
            parts.port = t[1] || null;
          }
        }
        if (parts.hostname && string.substring(pos).charAt(0) !== "/") {
          pos++;
          string = "/" + string;
        }
        if (parts.preventInvalidHostname) {
          URI.ensureValidHostname(parts.hostname, parts.protocol);
        }
        if (parts.port) {
          URI.ensureValidPort(parts.port);
        }
        return string.substring(pos) || "/";
      };
      URI.parseAuthority = function(string, parts) {
        string = URI.parseUserinfo(string, parts);
        return URI.parseHost(string, parts);
      };
      URI.parseUserinfo = function(string, parts) {
        var _string = string;
        var firstBackSlash = string.indexOf("\\");
        if (firstBackSlash !== -1) {
          string = string.replace(/\\/g, "/");
        }
        var firstSlash = string.indexOf("/");
        var pos = string.lastIndexOf("@", firstSlash > -1 ? firstSlash : string.length - 1);
        var t;
        if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
          t = string.substring(0, pos).split(":");
          parts.username = t[0] ? URI.decode(t[0]) : null;
          t.shift();
          parts.password = t[0] ? URI.decode(t.join(":")) : null;
          string = _string.substring(pos + 1);
        } else {
          parts.username = null;
          parts.password = null;
        }
        return string;
      };
      URI.parseQuery = function(string, escapeQuerySpace) {
        if (!string) {
          return {};
        }
        string = string.replace(/&+/g, "&").replace(/^\?*&*|&+$/g, "");
        if (!string) {
          return {};
        }
        var items = {};
        var splits = string.split("&");
        var length = splits.length;
        var v, name, value;
        for (var i = 0; i < length; i++) {
          v = splits[i].split("=");
          name = URI.decodeQuery(v.shift(), escapeQuerySpace);
          value = v.length ? URI.decodeQuery(v.join("="), escapeQuerySpace) : null;
          if (name === "__proto__") {
            continue;
          } else if (hasOwn.call(items, name)) {
            if (typeof items[name] === "string" || items[name] === null) {
              items[name] = [items[name]];
            }
            items[name].push(value);
          } else {
            items[name] = value;
          }
        }
        return items;
      };
      URI.build = function(parts) {
        var t = "";
        var requireAbsolutePath = false;
        if (parts.protocol) {
          t += parts.protocol + ":";
        }
        if (!parts.urn && (t || parts.hostname)) {
          t += "//";
          requireAbsolutePath = true;
        }
        t += URI.buildAuthority(parts) || "";
        if (typeof parts.path === "string") {
          if (parts.path.charAt(0) !== "/" && requireAbsolutePath) {
            t += "/";
          }
          t += parts.path;
        }
        if (typeof parts.query === "string" && parts.query) {
          t += "?" + parts.query;
        }
        if (typeof parts.fragment === "string" && parts.fragment) {
          t += "#" + parts.fragment;
        }
        return t;
      };
      URI.buildHost = function(parts) {
        var t = "";
        if (!parts.hostname) {
          return "";
        } else if (URI.ip6_expression.test(parts.hostname)) {
          t += "[" + parts.hostname + "]";
        } else {
          t += parts.hostname;
        }
        if (parts.port) {
          t += ":" + parts.port;
        }
        return t;
      };
      URI.buildAuthority = function(parts) {
        return URI.buildUserinfo(parts) + URI.buildHost(parts);
      };
      URI.buildUserinfo = function(parts) {
        var t = "";
        if (parts.username) {
          t += URI.encode(parts.username);
        }
        if (parts.password) {
          t += ":" + URI.encode(parts.password);
        }
        if (t) {
          t += "@";
        }
        return t;
      };
      URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
        var t = "";
        var unique, key, i, length;
        for (key in data) {
          if (key === "__proto__") {
            continue;
          } else if (hasOwn.call(data, key)) {
            if (isArray(data[key])) {
              unique = {};
              for (i = 0, length = data[key].length; i < length; i++) {
                if (data[key][i] !== void 0 && unique[data[key][i] + ""] === void 0) {
                  t += "&" + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
                  if (duplicateQueryParameters !== true) {
                    unique[data[key][i] + ""] = true;
                  }
                }
              }
            } else if (data[key] !== void 0) {
              t += "&" + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
            }
          }
        }
        return t.substring(1);
      };
      URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
        return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? "=" + URI.encodeQuery(value, escapeQuerySpace) : "");
      };
      URI.addQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              URI.addQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          if (data[name] === void 0) {
            data[name] = value;
            return;
          } else if (typeof data[name] === "string") {
            data[name] = [data[name]];
          }
          if (!isArray(value)) {
            value = [value];
          }
          data[name] = (data[name] || []).concat(value);
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
      };
      URI.setQuery = function(data, name, value) {
        if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              URI.setQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          data[name] = value === void 0 ? null : value;
        } else {
          throw new TypeError("URI.setQuery() accepts an object, string as the name parameter");
        }
      };
      URI.removeQuery = function(data, name, value) {
        var i, length, key;
        if (isArray(name)) {
          for (i = 0, length = name.length; i < length; i++) {
            data[name[i]] = void 0;
          }
        } else if (getType(name) === "RegExp") {
          for (key in data) {
            if (name.test(key)) {
              data[key] = void 0;
            }
          }
        } else if (typeof name === "object") {
          for (key in name) {
            if (hasOwn.call(name, key)) {
              URI.removeQuery(data, key, name[key]);
            }
          }
        } else if (typeof name === "string") {
          if (value !== void 0) {
            if (getType(value) === "RegExp") {
              if (!isArray(data[name]) && value.test(data[name])) {
                data[name] = void 0;
              } else {
                data[name] = filterArrayValues(data[name], value);
              }
            } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
              data[name] = void 0;
            } else if (isArray(data[name])) {
              data[name] = filterArrayValues(data[name], value);
            }
          } else {
            data[name] = void 0;
          }
        } else {
          throw new TypeError("URI.removeQuery() accepts an object, string, RegExp as the first parameter");
        }
      };
      URI.hasQuery = function(data, name, value, withinArray) {
        switch (getType(name)) {
          case "String":
            break;
          case "RegExp":
            for (var key in data) {
              if (hasOwn.call(data, key)) {
                if (name.test(key) && (value === void 0 || URI.hasQuery(data, key, value))) {
                  return true;
                }
              }
            }
            return false;
          case "Object":
            for (var _key in name) {
              if (hasOwn.call(name, _key)) {
                if (!URI.hasQuery(data, _key, name[_key])) {
                  return false;
                }
              }
            }
            return true;
          default:
            throw new TypeError("URI.hasQuery() accepts a string, regular expression or object as the name parameter");
        }
        switch (getType(value)) {
          case "Undefined":
            return name in data;
          // data[name] !== undefined;
          case "Boolean":
            var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
            return value === _booly;
          case "Function":
            return !!value(data[name], name, data);
          case "Array":
            if (!isArray(data[name])) {
              return false;
            }
            var op = withinArray ? arrayContains : arraysEqual;
            return op(data[name], value);
          case "RegExp":
            if (!isArray(data[name])) {
              return Boolean(data[name] && data[name].match(value));
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          case "Number":
            value = String(value);
          /* falls through */
          case "String":
            if (!isArray(data[name])) {
              return data[name] === value;
            }
            if (!withinArray) {
              return false;
            }
            return arrayContains(data[name], value);
          default:
            throw new TypeError("URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter");
        }
      };
      URI.joinPaths = function() {
        var input = [];
        var segments = [];
        var nonEmptySegments = 0;
        for (var i = 0; i < arguments.length; i++) {
          var url = new URI(arguments[i]);
          input.push(url);
          var _segments = url.segment();
          for (var s = 0; s < _segments.length; s++) {
            if (typeof _segments[s] === "string") {
              segments.push(_segments[s]);
            }
            if (_segments[s]) {
              nonEmptySegments++;
            }
          }
        }
        if (!segments.length || !nonEmptySegments) {
          return new URI("");
        }
        var uri = new URI("").segment(segments);
        if (input[0].path() === "" || input[0].path().slice(0, 1) === "/") {
          uri.path("/" + uri.path());
        }
        return uri.normalize();
      };
      URI.commonPath = function(one, two) {
        var length = Math.min(one.length, two.length);
        var pos;
        for (pos = 0; pos < length; pos++) {
          if (one.charAt(pos) !== two.charAt(pos)) {
            pos--;
            break;
          }
        }
        if (pos < 1) {
          return one.charAt(0) === two.charAt(0) && one.charAt(0) === "/" ? "/" : "";
        }
        if (one.charAt(pos) !== "/" || two.charAt(pos) !== "/") {
          pos = one.substring(0, pos).lastIndexOf("/");
        }
        return one.substring(0, pos + 1);
      };
      URI.withinString = function(string, callback, options) {
        options || (options = {});
        var _start = options.start || URI.findUri.start;
        var _end = options.end || URI.findUri.end;
        var _trim = options.trim || URI.findUri.trim;
        var _parens = options.parens || URI.findUri.parens;
        var _attributeOpen = /[a-z0-9-]=["']?$/i;
        _start.lastIndex = 0;
        while (true) {
          var match = _start.exec(string);
          if (!match) {
            break;
          }
          var start = match.index;
          if (options.ignoreHtml) {
            var attributeOpen = string.slice(Math.max(start - 3, 0), start);
            if (attributeOpen && _attributeOpen.test(attributeOpen)) {
              continue;
            }
          }
          var end = start + string.slice(start).search(_end);
          var slice = string.slice(start, end);
          var parensEnd = -1;
          while (true) {
            var parensMatch = _parens.exec(slice);
            if (!parensMatch) {
              break;
            }
            var parensMatchEnd = parensMatch.index + parensMatch[0].length;
            parensEnd = Math.max(parensEnd, parensMatchEnd);
          }
          if (parensEnd > -1) {
            slice = slice.slice(0, parensEnd) + slice.slice(parensEnd).replace(_trim, "");
          } else {
            slice = slice.replace(_trim, "");
          }
          if (slice.length <= match[0].length) {
            continue;
          }
          if (options.ignore && options.ignore.test(slice)) {
            continue;
          }
          end = start + slice.length;
          var result = callback(slice, start, end, string);
          if (result === void 0) {
            _start.lastIndex = end;
            continue;
          }
          result = String(result);
          string = string.slice(0, start) + result + string.slice(end);
          _start.lastIndex = start + result.length;
        }
        _start.lastIndex = 0;
        return string;
      };
      URI.ensureValidHostname = function(v, protocol) {
        var hasHostname = !!v;
        var hasProtocol = !!protocol;
        var rejectEmptyHostname = false;
        if (hasProtocol) {
          rejectEmptyHostname = arrayContains(URI.hostProtocols, protocol);
        }
        if (rejectEmptyHostname && !hasHostname) {
          throw new TypeError("Hostname cannot be empty, if protocol is " + protocol);
        } else if (v && v.match(URI.invalid_hostname_characters)) {
          if (!punycode) {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_] and Punycode.js is not available');
          }
          if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-:_]');
          }
        }
      };
      URI.ensureValidPort = function(v) {
        if (!v) {
          return;
        }
        var port = Number(v);
        if (isInteger(port) && port > 0 && port < 65536) {
          return;
        }
        throw new TypeError('Port "' + v + '" is not a valid port');
      };
      URI.noConflict = function(removeAll) {
        if (removeAll) {
          var unconflicted = {
            URI: this.noConflict()
          };
          if (root.URITemplate && typeof root.URITemplate.noConflict === "function") {
            unconflicted.URITemplate = root.URITemplate.noConflict();
          }
          if (root.IPv6 && typeof root.IPv6.noConflict === "function") {
            unconflicted.IPv6 = root.IPv6.noConflict();
          }
          if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === "function") {
            unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
          }
          return unconflicted;
        } else if (root.URI === this) {
          root.URI = _URI;
        }
        return this;
      };
      p.build = function(deferBuild) {
        if (deferBuild === true) {
          this._deferred_build = true;
        } else if (deferBuild === void 0 || this._deferred_build) {
          this._string = URI.build(this._parts);
          this._deferred_build = false;
        }
        return this;
      };
      p.clone = function() {
        return new URI(this);
      };
      p.valueOf = p.toString = function() {
        return this.build(false)._string;
      };
      function generateSimpleAccessor(_part2) {
        return function(v, build) {
          if (v === void 0) {
            return this._parts[_part2] || "";
          } else {
            this._parts[_part2] = v || null;
            this.build(!build);
            return this;
          }
        };
      }
      function generatePrefixAccessor(_part2, _key) {
        return function(v, build) {
          if (v === void 0) {
            return this._parts[_part2] || "";
          } else {
            if (v !== null) {
              v = v + "";
              if (v.charAt(0) === _key) {
                v = v.substring(1);
              }
            }
            this._parts[_part2] = v;
            this.build(!build);
            return this;
          }
        };
      }
      p.protocol = generateSimpleAccessor("protocol");
      p.username = generateSimpleAccessor("username");
      p.password = generateSimpleAccessor("password");
      p.hostname = generateSimpleAccessor("hostname");
      p.port = generateSimpleAccessor("port");
      p.query = generatePrefixAccessor("query", "?");
      p.fragment = generatePrefixAccessor("fragment", "#");
      p.search = function(v, build) {
        var t = this.query(v, build);
        return typeof t === "string" && t.length ? "?" + t : t;
      };
      p.hash = function(v, build) {
        var t = this.fragment(v, build);
        return typeof t === "string" && t.length ? "#" + t : t;
      };
      p.pathname = function(v, build) {
        if (v === void 0 || v === true) {
          var res = this._parts.path || (this._parts.hostname ? "/" : "");
          return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
        } else {
          if (this._parts.urn) {
            this._parts.path = v ? URI.recodeUrnPath(v) : "";
          } else {
            this._parts.path = v ? URI.recodePath(v) : "/";
          }
          this.build(!build);
          return this;
        }
      };
      p.path = p.pathname;
      p.href = function(href, build) {
        var key;
        if (href === void 0) {
          return this.toString();
        }
        this._string = "";
        this._parts = URI._parts();
        var _URI2 = href instanceof URI;
        var _object = typeof href === "object" && (href.hostname || href.path || href.pathname);
        if (href.nodeName) {
          var attribute = URI.getDomAttribute(href);
          href = href[attribute] || "";
          _object = false;
        }
        if (!_URI2 && _object && href.pathname !== void 0) {
          href = href.toString();
        }
        if (typeof href === "string" || href instanceof String) {
          this._parts = URI.parse(String(href), this._parts);
        } else if (_URI2 || _object) {
          var src = _URI2 ? href._parts : href;
          for (key in src) {
            if (key === "query") {
              continue;
            }
            if (hasOwn.call(this._parts, key)) {
              this._parts[key] = src[key];
            }
          }
          if (src.query) {
            this.query(src.query, false);
          }
        } else {
          throw new TypeError("invalid input");
        }
        this.build(!build);
        return this;
      };
      p.is = function(what) {
        var ip = false;
        var ip4 = false;
        var ip6 = false;
        var name = false;
        var sld = false;
        var idn = false;
        var punycode2 = false;
        var relative = !this._parts.urn;
        if (this._parts.hostname) {
          relative = false;
          ip4 = URI.ip4_expression.test(this._parts.hostname);
          ip6 = URI.ip6_expression.test(this._parts.hostname);
          ip = ip4 || ip6;
          name = !ip;
          sld = name && SLD && SLD.has(this._parts.hostname);
          idn = name && URI.idn_expression.test(this._parts.hostname);
          punycode2 = name && URI.punycode_expression.test(this._parts.hostname);
        }
        switch (what.toLowerCase()) {
          case "relative":
            return relative;
          case "absolute":
            return !relative;
          // hostname identification
          case "domain":
          case "name":
            return name;
          case "sld":
            return sld;
          case "ip":
            return ip;
          case "ip4":
          case "ipv4":
          case "inet4":
            return ip4;
          case "ip6":
          case "ipv6":
          case "inet6":
            return ip6;
          case "idn":
            return idn;
          case "url":
            return !this._parts.urn;
          case "urn":
            return !!this._parts.urn;
          case "punycode":
            return punycode2;
        }
        return null;
      };
      var _protocol = p.protocol;
      var _port = p.port;
      var _hostname = p.hostname;
      p.protocol = function(v, build) {
        if (v) {
          v = v.replace(/:(\/\/)?$/, "");
          if (!v.match(URI.protocol_expression)) {
            throw new TypeError('Protocol "' + v + `" contains characters other than [A-Z0-9.+-] or doesn't start with [A-Z]`);
          }
        }
        return _protocol.call(this, v, build);
      };
      p.scheme = p.protocol;
      p.port = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v !== void 0) {
          if (v === 0) {
            v = null;
          }
          if (v) {
            v += "";
            if (v.charAt(0) === ":") {
              v = v.substring(1);
            }
            URI.ensureValidPort(v);
          }
        }
        return _port.call(this, v, build);
      };
      p.hostname = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v !== void 0) {
          var x = { preventInvalidHostname: this._parts.preventInvalidHostname };
          var res = URI.parseHost(v, x);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          v = x.hostname;
          if (this._parts.preventInvalidHostname) {
            URI.ensureValidHostname(v, this._parts.protocol);
          }
        }
        return _hostname.call(this, v, build);
      };
      p.origin = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          var protocol = this.protocol();
          var authority = this.authority();
          if (!authority) {
            return "";
          }
          return (protocol ? protocol + "://" : "") + this.authority();
        } else {
          var origin = URI(v);
          this.protocol(origin.protocol()).authority(origin.authority()).build(!build);
          return this;
        }
      };
      p.host = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          return this._parts.hostname ? URI.buildHost(this._parts) : "";
        } else {
          var res = URI.parseHost(v, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build);
          return this;
        }
      };
      p.authority = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          return this._parts.hostname ? URI.buildAuthority(this._parts) : "";
        } else {
          var res = URI.parseAuthority(v, this._parts);
          if (res !== "/") {
            throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
          }
          this.build(!build);
          return this;
        }
      };
      p.userinfo = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          var t = URI.buildUserinfo(this._parts);
          return t ? t.substring(0, t.length - 1) : t;
        } else {
          if (v[v.length - 1] !== "@") {
            v += "@";
          }
          URI.parseUserinfo(v, this._parts);
          this.build(!build);
          return this;
        }
      };
      p.resource = function(v, build) {
        var parts;
        if (v === void 0) {
          return this.path() + this.search() + this.hash();
        }
        parts = URI.parse(v);
        this._parts.path = parts.path;
        this._parts.query = parts.query;
        this._parts.fragment = parts.fragment;
        this.build(!build);
        return this;
      };
      p.subdomain = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var end = this._parts.hostname.length - this.domain().length - 1;
          return this._parts.hostname.substring(0, end) || "";
        } else {
          var e = this._parts.hostname.length - this.domain().length;
          var sub = this._parts.hostname.substring(0, e);
          var replace = new RegExp("^" + escapeRegEx(sub));
          if (v && v.charAt(v.length - 1) !== ".") {
            v += ".";
          }
          if (v.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          if (v) {
            URI.ensureValidHostname(v, this._parts.protocol);
          }
          this._parts.hostname = this._parts.hostname.replace(replace, v);
          this.build(!build);
          return this;
        }
      };
      p.domain = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v === "boolean") {
          build = v;
          v = void 0;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var t = this._parts.hostname.match(/\./g);
          if (t && t.length < 2) {
            return this._parts.hostname;
          }
          var end = this._parts.hostname.length - this.tld(build).length - 1;
          end = this._parts.hostname.lastIndexOf(".", end - 1) + 1;
          return this._parts.hostname.substring(end) || "";
        } else {
          if (!v) {
            throw new TypeError("cannot set domain empty");
          }
          if (v.indexOf(":") !== -1) {
            throw new TypeError("Domains cannot contain colons");
          }
          URI.ensureValidHostname(v, this._parts.protocol);
          if (!this._parts.hostname || this.is("IP")) {
            this._parts.hostname = v;
          } else {
            var replace = new RegExp(escapeRegEx(this.domain()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.tld = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v === "boolean") {
          build = v;
          v = void 0;
        }
        if (v === void 0) {
          if (!this._parts.hostname || this.is("IP")) {
            return "";
          }
          var pos = this._parts.hostname.lastIndexOf(".");
          var tld = this._parts.hostname.substring(pos + 1);
          if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
            return SLD.get(this._parts.hostname) || tld;
          }
          return tld;
        } else {
          var replace;
          if (!v) {
            throw new TypeError("cannot set TLD empty");
          } else if (v.match(/[^a-zA-Z0-9-]/)) {
            if (SLD && SLD.is(v)) {
              replace = new RegExp(escapeRegEx(this.tld()) + "$");
              this._parts.hostname = this._parts.hostname.replace(replace, v);
            } else {
              throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
            }
          } else if (!this._parts.hostname || this.is("IP")) {
            throw new ReferenceError("cannot set TLD on non-domain host");
          } else {
            replace = new RegExp(escapeRegEx(this.tld()) + "$");
            this._parts.hostname = this._parts.hostname.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.directory = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0 || v === true) {
          if (!this._parts.path && !this._parts.hostname) {
            return "";
          }
          if (this._parts.path === "/") {
            return "/";
          }
          var end = this._parts.path.length - this.filename().length - 1;
          var res = this._parts.path.substring(0, end) || (this._parts.hostname ? "/" : "");
          return v ? URI.decodePath(res) : res;
        } else {
          var e = this._parts.path.length - this.filename().length;
          var directory = this._parts.path.substring(0, e);
          var replace = new RegExp("^" + escapeRegEx(directory));
          if (!this.is("relative")) {
            if (!v) {
              v = "/";
            }
            if (v.charAt(0) !== "/") {
              v = "/" + v;
            }
          }
          if (v && v.charAt(v.length - 1) !== "/") {
            v += "/";
          }
          v = URI.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
          this.build(!build);
          return this;
        }
      };
      p.filename = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (typeof v !== "string") {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var pos = this._parts.path.lastIndexOf("/");
          var res = this._parts.path.substring(pos + 1);
          return v ? URI.decodePathSegment(res) : res;
        } else {
          var mutatedDirectory = false;
          if (v.charAt(0) === "/") {
            v = v.substring(1);
          }
          if (v.match(/\.?\//)) {
            mutatedDirectory = true;
          }
          var replace = new RegExp(escapeRegEx(this.filename()) + "$");
          v = URI.recodePath(v);
          this._parts.path = this._parts.path.replace(replace, v);
          if (mutatedDirectory) {
            this.normalizePath(build);
          } else {
            this.build(!build);
          }
          return this;
        }
      };
      p.suffix = function(v, build) {
        if (this._parts.urn) {
          return v === void 0 ? "" : this;
        }
        if (v === void 0 || v === true) {
          if (!this._parts.path || this._parts.path === "/") {
            return "";
          }
          var filename = this.filename();
          var pos = filename.lastIndexOf(".");
          var s, res;
          if (pos === -1) {
            return "";
          }
          s = filename.substring(pos + 1);
          res = /^[a-z0-9%]+$/i.test(s) ? s : "";
          return v ? URI.decodePathSegment(res) : res;
        } else {
          if (v.charAt(0) === ".") {
            v = v.substring(1);
          }
          var suffix = this.suffix();
          var replace;
          if (!suffix) {
            if (!v) {
              return this;
            }
            this._parts.path += "." + URI.recodePath(v);
          } else if (!v) {
            replace = new RegExp(escapeRegEx("." + suffix) + "$");
          } else {
            replace = new RegExp(escapeRegEx(suffix) + "$");
          }
          if (replace) {
            v = URI.recodePath(v);
            this._parts.path = this._parts.path.replace(replace, v);
          }
          this.build(!build);
          return this;
        }
      };
      p.segment = function(segment, v, build) {
        var separator = this._parts.urn ? ":" : "/";
        var path = this.path();
        var absolute = path.substring(0, 1) === "/";
        var segments = path.split(separator);
        if (segment !== void 0 && typeof segment !== "number") {
          build = v;
          v = segment;
          segment = void 0;
        }
        if (segment !== void 0 && typeof segment !== "number") {
          throw new Error('Bad segment "' + segment + '", must be 0-based integer');
        }
        if (absolute) {
          segments.shift();
        }
        if (segment < 0) {
          segment = Math.max(segments.length + segment, 0);
        }
        if (v === void 0) {
          return segment === void 0 ? segments : segments[segment];
        } else if (segment === null || segments[segment] === void 0) {
          if (isArray(v)) {
            segments = [];
            for (var i = 0, l = v.length; i < l; i++) {
              if (!v[i].length && (!segments.length || !segments[segments.length - 1].length)) {
                continue;
              }
              if (segments.length && !segments[segments.length - 1].length) {
                segments.pop();
              }
              segments.push(trimSlashes(v[i]));
            }
          } else if (v || typeof v === "string") {
            v = trimSlashes(v);
            if (segments[segments.length - 1] === "") {
              segments[segments.length - 1] = v;
            } else {
              segments.push(v);
            }
          }
        } else {
          if (v) {
            segments[segment] = trimSlashes(v);
          } else {
            segments.splice(segment, 1);
          }
        }
        if (absolute) {
          segments.unshift("");
        }
        return this.path(segments.join(separator), build);
      };
      p.segmentCoded = function(segment, v, build) {
        var segments, i, l;
        if (typeof segment !== "number") {
          build = v;
          v = segment;
          segment = void 0;
        }
        if (v === void 0) {
          segments = this.segment(segment, v, build);
          if (!isArray(segments)) {
            segments = segments !== void 0 ? URI.decode(segments) : void 0;
          } else {
            for (i = 0, l = segments.length; i < l; i++) {
              segments[i] = URI.decode(segments[i]);
            }
          }
          return segments;
        }
        if (!isArray(v)) {
          v = typeof v === "string" || v instanceof String ? URI.encode(v) : v;
        } else {
          for (i = 0, l = v.length; i < l; i++) {
            v[i] = URI.encode(v[i]);
          }
        }
        return this.segment(segment, v, build);
      };
      var q = p.query;
      p.query = function(v, build) {
        if (v === true) {
          return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        } else if (typeof v === "function") {
          var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
          var result = v.call(this, data);
          this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build);
          return this;
        } else if (v !== void 0 && typeof v !== "string") {
          this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
          this.build(!build);
          return this;
        } else {
          return q.call(this, v, build);
        }
      };
      p.setQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        if (typeof name === "string" || name instanceof String) {
          data[name] = value !== void 0 ? value : null;
        } else if (typeof name === "object") {
          for (var key in name) {
            if (hasOwn.call(name, key)) {
              data[key] = name[key];
            }
          }
        } else {
          throw new TypeError("URI.addQuery() accepts an object, string as the name parameter");
        }
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.addQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI.addQuery(data, name, value === void 0 ? null : value);
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.removeQuery = function(name, value, build) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        URI.removeQuery(data, name, value);
        this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
        if (typeof name !== "string") {
          build = value;
        }
        this.build(!build);
        return this;
      };
      p.hasQuery = function(name, value, withinArray) {
        var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
        return URI.hasQuery(data, name, value, withinArray);
      };
      p.setSearch = p.setQuery;
      p.addSearch = p.addQuery;
      p.removeSearch = p.removeQuery;
      p.hasSearch = p.hasQuery;
      p.normalize = function() {
        if (this._parts.urn) {
          return this.normalizeProtocol(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
        }
        return this.normalizeProtocol(false).normalizeHostname(false).normalizePort(false).normalizePath(false).normalizeQuery(false).normalizeFragment(false).build();
      };
      p.normalizeProtocol = function(build) {
        if (typeof this._parts.protocol === "string") {
          this._parts.protocol = this._parts.protocol.toLowerCase();
          this.build(!build);
        }
        return this;
      };
      p.normalizeHostname = function(build) {
        if (this._parts.hostname) {
          if (this.is("IDN") && punycode) {
            this._parts.hostname = punycode.toASCII(this._parts.hostname);
          } else if (this.is("IPv6") && IPv6) {
            this._parts.hostname = IPv6.best(this._parts.hostname);
          }
          this._parts.hostname = this._parts.hostname.toLowerCase();
          this.build(!build);
        }
        return this;
      };
      p.normalizePort = function(build) {
        if (typeof this._parts.protocol === "string" && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
          this._parts.port = null;
          this.build(!build);
        }
        return this;
      };
      p.normalizePath = function(build) {
        var _path = this._parts.path;
        if (!_path) {
          return this;
        }
        if (this._parts.urn) {
          this._parts.path = URI.recodeUrnPath(this._parts.path);
          this.build(!build);
          return this;
        }
        if (this._parts.path === "/") {
          return this;
        }
        _path = URI.recodePath(_path);
        var _was_relative;
        var _leadingParents = "";
        var _parent, _pos;
        if (_path.charAt(0) !== "/") {
          _was_relative = true;
          _path = "/" + _path;
        }
        if (_path.slice(-3) === "/.." || _path.slice(-2) === "/.") {
          _path += "/";
        }
        _path = _path.replace(/(\/(\.\/)+)|(\/\.$)/g, "/").replace(/\/{2,}/g, "/");
        if (_was_relative) {
          _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || "";
          if (_leadingParents) {
            _leadingParents = _leadingParents[0];
          }
        }
        while (true) {
          _parent = _path.search(/\/\.\.(\/|$)/);
          if (_parent === -1) {
            break;
          } else if (_parent === 0) {
            _path = _path.substring(3);
            continue;
          }
          _pos = _path.substring(0, _parent).lastIndexOf("/");
          if (_pos === -1) {
            _pos = _parent;
          }
          _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
        }
        if (_was_relative && this.is("relative")) {
          _path = _leadingParents + _path.substring(1);
        }
        this._parts.path = _path;
        this.build(!build);
        return this;
      };
      p.normalizePathname = p.normalizePath;
      p.normalizeQuery = function(build) {
        if (typeof this._parts.query === "string") {
          if (!this._parts.query.length) {
            this._parts.query = null;
          } else {
            this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
          }
          this.build(!build);
        }
        return this;
      };
      p.normalizeFragment = function(build) {
        if (!this._parts.fragment) {
          this._parts.fragment = null;
          this.build(!build);
        }
        return this;
      };
      p.normalizeSearch = p.normalizeQuery;
      p.normalizeHash = p.normalizeFragment;
      p.iso8859 = function() {
        var e = URI.encode;
        var d = URI.decode;
        URI.encode = escape;
        URI.decode = decodeURIComponent;
        try {
          this.normalize();
        } finally {
          URI.encode = e;
          URI.decode = d;
        }
        return this;
      };
      p.unicode = function() {
        var e = URI.encode;
        var d = URI.decode;
        URI.encode = strictEncodeURIComponent;
        URI.decode = unescape;
        try {
          this.normalize();
        } finally {
          URI.encode = e;
          URI.decode = d;
        }
        return this;
      };
      p.readable = function() {
        var uri = this.clone();
        uri.username("").password("").normalize();
        var t = "";
        if (uri._parts.protocol) {
          t += uri._parts.protocol + "://";
        }
        if (uri._parts.hostname) {
          if (uri.is("punycode") && punycode) {
            t += punycode.toUnicode(uri._parts.hostname);
            if (uri._parts.port) {
              t += ":" + uri._parts.port;
            }
          } else {
            t += uri.host();
          }
        }
        if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== "/") {
          t += "/";
        }
        t += uri.path(true);
        if (uri._parts.query) {
          var q2 = "";
          for (var i = 0, qp = uri._parts.query.split("&"), l = qp.length; i < l; i++) {
            var kv = (qp[i] || "").split("=");
            q2 += "&" + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            if (kv[1] !== void 0) {
              q2 += "=" + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace).replace(/&/g, "%26");
            }
          }
          t += "?" + q2.substring(1);
        }
        t += URI.decodeQuery(uri.hash(), true);
        return t;
      };
      p.absoluteTo = function(base) {
        var resolved = this.clone();
        var properties = ["protocol", "username", "password", "hostname", "port"];
        var basedir, i, p2;
        if (this._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        if (!(base instanceof URI)) {
          base = new URI(base);
        }
        if (resolved._parts.protocol) {
          return resolved;
        } else {
          resolved._parts.protocol = base._parts.protocol;
        }
        if (this._parts.hostname) {
          return resolved;
        }
        for (i = 0; p2 = properties[i]; i++) {
          resolved._parts[p2] = base._parts[p2];
        }
        if (!resolved._parts.path) {
          resolved._parts.path = base._parts.path;
          if (!resolved._parts.query) {
            resolved._parts.query = base._parts.query;
          }
        } else {
          if (resolved._parts.path.substring(-2) === "..") {
            resolved._parts.path += "/";
          }
          if (resolved.path().charAt(0) !== "/") {
            basedir = base.directory();
            basedir = basedir ? basedir : base.path().indexOf("/") === 0 ? "/" : "";
            resolved._parts.path = (basedir ? basedir + "/" : "") + resolved._parts.path;
            resolved.normalizePath();
          }
        }
        resolved.build();
        return resolved;
      };
      p.relativeTo = function(base) {
        var relative = this.clone().normalize();
        var relativeParts, baseParts, common, relativePath, basePath;
        if (relative._parts.urn) {
          throw new Error("URNs do not have any generally defined hierarchical components");
        }
        base = new URI(base).normalize();
        relativeParts = relative._parts;
        baseParts = base._parts;
        relativePath = relative.path();
        basePath = base.path();
        if (relativePath.charAt(0) !== "/") {
          throw new Error("URI is already relative");
        }
        if (basePath.charAt(0) !== "/") {
          throw new Error("Cannot calculate a URI relative to another relative URI");
        }
        if (relativeParts.protocol === baseParts.protocol) {
          relativeParts.protocol = null;
        }
        if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
          return relative.build();
        }
        if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
          return relative.build();
        }
        if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
          relativeParts.hostname = null;
          relativeParts.port = null;
        } else {
          return relative.build();
        }
        if (relativePath === basePath) {
          relativeParts.path = "";
          return relative.build();
        }
        common = URI.commonPath(relativePath, basePath);
        if (!common) {
          return relative.build();
        }
        var parents = baseParts.path.substring(common.length).replace(/[^\/]*$/, "").replace(/.*?\//g, "../");
        relativeParts.path = parents + relativeParts.path.substring(common.length) || "./";
        return relative.build();
      };
      p.equals = function(uri) {
        var one = this.clone();
        var two = new URI(uri);
        var one_map = {};
        var two_map = {};
        var checked = {};
        var one_query, two_query, key;
        one.normalize();
        two.normalize();
        if (one.toString() === two.toString()) {
          return true;
        }
        one_query = one.query();
        two_query = two.query();
        one.query("");
        two.query("");
        if (one.toString() !== two.toString()) {
          return false;
        }
        if (one_query.length !== two_query.length) {
          return false;
        }
        one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
        two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);
        for (key in one_map) {
          if (hasOwn.call(one_map, key)) {
            if (!isArray(one_map[key])) {
              if (one_map[key] !== two_map[key]) {
                return false;
              }
            } else if (!arraysEqual(one_map[key], two_map[key])) {
              return false;
            }
            checked[key] = true;
          }
        }
        for (key in two_map) {
          if (hasOwn.call(two_map, key)) {
            if (!checked[key]) {
              return false;
            }
          }
        }
        return true;
      };
      p.preventInvalidHostname = function(v) {
        this._parts.preventInvalidHostname = !!v;
        return this;
      };
      p.duplicateQueryParameters = function(v) {
        this._parts.duplicateQueryParameters = !!v;
        return this;
      };
      p.escapeQuerySpace = function(v) {
        this._parts.escapeQuerySpace = !!v;
        return this;
      };
      return URI;
    });
  }
});

// node_modules/@stellar/js-xdr/dist/xdr.js
var require_xdr = __commonJS({
  "node_modules/@stellar/js-xdr/dist/xdr.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    !function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.XDR = e() : t.XDR = e();
    }(exports, () => (() => {
      var t = { 616: (t2, e2, r2) => {
        "use strict";
        r2.d(e2, { A: () => i });
        var n = r2(287);
        n.hp.alloc(1).subarray(0, 1) instanceof n.hp || (n.hp.prototype.subarray = function(t3, e3) {
          const r3 = Uint8Array.prototype.subarray.call(this, t3, e3);
          return Object.setPrototypeOf(r3, n.hp.prototype), r3;
        });
        const i = n.hp;
      }, 281: (t2, e2, r2) => {
        const n = r2(164);
        t2.exports = n;
      }, 164: (t2, e2, r2) => {
        "use strict";
        r2.r(e2), r2.d(e2, { Array: () => F, Bool: () => S, Double: () => L, Enum: () => q, Float: () => O, Hyper: () => U, Int: () => v, LargeInt: () => x, Opaque: () => D, Option: () => X, Quadruple: () => N, Reference: () => G, String: () => M, Struct: () => Y, Union: () => W, UnsignedHyper: () => T, UnsignedInt: () => R, VarArray: () => P, VarOpaque: () => z, Void: () => k, XdrReader: () => f, XdrWriter: () => c, config: () => it });
        class n extends TypeError {
          constructor(t3) {
            super(`XDR Write Error: ${t3}`);
          }
        }
        class i extends TypeError {
          constructor(t3) {
            super(`XDR Read Error: ${t3}`);
          }
        }
        class o extends TypeError {
          constructor(t3) {
            super(`XDR Type Definition Error: ${t3}`);
          }
        }
        class s extends o {
          constructor() {
            super("method not implemented, it should be overloaded in the descendant class.");
          }
        }
        var u = r2(616).A;
        class f {
          constructor(t3) {
            if (!u.isBuffer(t3)) {
              if (!(t3 instanceof Array || Array.isArray(t3) || ArrayBuffer.isView(t3))) throw new i(`source invalid: ${t3}`);
              t3 = u.from(t3);
            }
            this._buffer = t3, this._length = t3.length, this._index = 0;
          }
          _buffer;
          _length;
          _index;
          get eof() {
            return this._index === this._length;
          }
          advance(t3) {
            const e3 = this._index;
            if (this._index += t3, this._length < this._index) throw new i("attempt to read outside the boundary of the buffer");
            const r3 = 4 - (t3 % 4 || 4);
            if (r3 > 0) {
              for (let t4 = 0; t4 < r3; t4++) if (0 !== this._buffer[this._index + t4]) throw new i("invalid padding");
              this._index += r3;
            }
            return e3;
          }
          rewind() {
            this._index = 0;
          }
          read(t3) {
            const e3 = this.advance(t3);
            return this._buffer.subarray(e3, e3 + t3);
          }
          readInt32BE() {
            return this._buffer.readInt32BE(this.advance(4));
          }
          readUInt32BE() {
            return this._buffer.readUInt32BE(this.advance(4));
          }
          readBigInt64BE() {
            return this._buffer.readBigInt64BE(this.advance(8));
          }
          readBigUInt64BE() {
            return this._buffer.readBigUInt64BE(this.advance(8));
          }
          readFloatBE() {
            return this._buffer.readFloatBE(this.advance(4));
          }
          readDoubleBE() {
            return this._buffer.readDoubleBE(this.advance(8));
          }
          ensureInputConsumed() {
            if (this._index !== this._length) throw new i("invalid XDR contract typecast - source buffer not entirely consumed");
          }
        }
        var a = r2(616).A;
        const h = 8192;
        class c {
          constructor(t3) {
            "number" == typeof t3 ? t3 = a.allocUnsafe(t3) : t3 instanceof a || (t3 = a.allocUnsafe(h)), this._buffer = t3, this._length = t3.length;
          }
          _buffer;
          _length;
          _index = 0;
          alloc(t3) {
            const e3 = this._index;
            return this._index += t3, this._length < this._index && this.resize(this._index), e3;
          }
          resize(t3) {
            const e3 = Math.ceil(t3 / h) * h, r3 = a.allocUnsafe(e3);
            this._buffer.copy(r3, 0, 0, this._length), this._buffer = r3, this._length = e3;
          }
          finalize() {
            return this._buffer.subarray(0, this._index);
          }
          toArray() {
            return [...this.finalize()];
          }
          write(t3, e3) {
            if ("string" == typeof t3) {
              const r4 = this.alloc(e3);
              this._buffer.write(t3, r4, "utf8");
            } else {
              t3 instanceof a || (t3 = a.from(t3));
              const r4 = this.alloc(e3);
              t3.copy(this._buffer, r4, 0, e3);
            }
            const r3 = 4 - (e3 % 4 || 4);
            if (r3 > 0) {
              const t4 = this.alloc(r3);
              this._buffer.fill(0, t4, this._index);
            }
          }
          writeInt32BE(t3) {
            const e3 = this.alloc(4);
            this._buffer.writeInt32BE(t3, e3);
          }
          writeUInt32BE(t3) {
            const e3 = this.alloc(4);
            this._buffer.writeUInt32BE(t3, e3);
          }
          writeBigInt64BE(t3) {
            const e3 = this.alloc(8);
            this._buffer.writeBigInt64BE(t3, e3);
          }
          writeBigUInt64BE(t3) {
            const e3 = this.alloc(8);
            this._buffer.writeBigUInt64BE(t3, e3);
          }
          writeFloatBE(t3) {
            const e3 = this.alloc(4);
            this._buffer.writeFloatBE(t3, e3);
          }
          writeDoubleBE(t3) {
            const e3 = this.alloc(8);
            this._buffer.writeDoubleBE(t3, e3);
          }
          static bufferChunkSize = h;
        }
        var l = r2(616).A;
        class p {
          toXDR(t3 = "raw") {
            if (!this.write) return this.constructor.toXDR(this, t3);
            const e3 = new c();
            return this.write(this, e3), w(e3.finalize(), t3);
          }
          fromXDR(t3, e3 = "raw") {
            if (!this.read) return this.constructor.fromXDR(t3, e3);
            const r3 = new f(m(t3, e3)), n2 = this.read(r3);
            return r3.ensureInputConsumed(), n2;
          }
          validateXDR(t3, e3 = "raw") {
            try {
              return this.fromXDR(t3, e3), true;
            } catch (t4) {
              return false;
            }
          }
          static toXDR(t3, e3 = "raw") {
            const r3 = new c();
            return this.write(t3, r3), w(r3.finalize(), e3);
          }
          static fromXDR(t3, e3 = "raw") {
            const r3 = new f(m(t3, e3)), n2 = this.read(r3);
            return r3.ensureInputConsumed(), n2;
          }
          static validateXDR(t3, e3 = "raw") {
            try {
              return this.fromXDR(t3, e3), true;
            } catch (t4) {
              return false;
            }
          }
        }
        class d extends p {
          static read(t3) {
            throw new s();
          }
          static write(t3, e3) {
            throw new s();
          }
          static isValid(t3) {
            return false;
          }
        }
        class g extends p {
          isValid(t3) {
            return false;
          }
        }
        class y extends TypeError {
          constructor(t3) {
            super(`Invalid format ${t3}, must be one of "raw", "hex", "base64"`);
          }
        }
        function w(t3, e3) {
          switch (e3) {
            case "raw":
              return t3;
            case "hex":
              return t3.toString("hex");
            case "base64":
              return t3.toString("base64");
            default:
              throw new y(e3);
          }
        }
        function m(t3, e3) {
          switch (e3) {
            case "raw":
              return t3;
            case "hex":
              return l.from(t3, "hex");
            case "base64":
              return l.from(t3, "base64");
            default:
              throw new y(e3);
          }
        }
        function b(t3, e3) {
          return null != t3 && (t3 instanceof e3 || _(t3, e3) && "function" == typeof t3.constructor.read && "function" == typeof t3.constructor.write && _(t3, "XdrType"));
        }
        function _(t3, e3) {
          do {
            if (t3.constructor.name === e3) return true;
          } while (t3 = Object.getPrototypeOf(t3));
          return false;
        }
        const B = 2147483647, E = -2147483648;
        class v extends d {
          static read(t3) {
            return t3.readInt32BE();
          }
          static write(t3, e3) {
            if ("number" != typeof t3) throw new n("not a number");
            if ((0 | t3) !== t3) throw new n("invalid i32 value");
            e3.writeInt32BE(t3);
          }
          static isValid(t3) {
            return "number" == typeof t3 && (0 | t3) === t3 && (t3 >= E && t3 <= B);
          }
        }
        function A(t3, e3, r3) {
          if ("bigint" != typeof t3) throw new TypeError("Expected bigint 'value', got " + typeof t3);
          const n2 = e3 / r3;
          if (1 === n2) return [t3];
          if (r3 < 32 || r3 > 128 || 2 !== n2 && 4 !== n2 && 8 !== n2) throw new TypeError(`invalid bigint (${t3}) and slice size (${e3} -> ${r3}) combination`);
          const i2 = BigInt(r3), o2 = new Array(n2);
          for (let e4 = 0; e4 < n2; e4++) o2[e4] = BigInt.asIntN(r3, t3), t3 >>= i2;
          return o2;
        }
        function I(t3, e3) {
          if (e3) return [0n, (1n << BigInt(t3)) - 1n];
          const r3 = 1n << BigInt(t3 - 1);
          return [0n - r3, r3 - 1n];
        }
        v.MAX_VALUE = B, v.MIN_VALUE = 2147483648;
        class x extends d {
          constructor(t3) {
            super(), this._value = function(t4, e3, r3) {
              t4 instanceof Array ? t4.length && t4[0] instanceof Array && (t4 = t4[0]) : t4 = [t4];
              const n2 = e3 / t4.length;
              switch (n2) {
                case 32:
                case 64:
                case 128:
                case 256:
                  break;
                default:
                  throw new RangeError(`expected slices to fit in 32/64/128/256 bits, got ${t4}`);
              }
              try {
                for (let e4 = 0; e4 < t4.length; e4++) "bigint" != typeof t4[e4] && (t4[e4] = BigInt(t4[e4].valueOf()));
              } catch (e4) {
                throw new TypeError(`expected bigint-like values, got: ${t4} (${e4})`);
              }
              if (r3 && 1 === t4.length && t4[0] < 0n) throw new RangeError(`expected a positive value, got: ${t4}`);
              let i2 = BigInt.asUintN(n2, t4[0]);
              for (let e4 = 1; e4 < t4.length; e4++) i2 |= BigInt.asUintN(n2, t4[e4]) << BigInt(e4 * n2);
              r3 || (i2 = BigInt.asIntN(e3, i2));
              const [o2, s2] = I(e3, r3);
              if (i2 >= o2 && i2 <= s2) return i2;
              throw new TypeError(`bigint values [${t4}] for ${function(t5, e4) {
                return `${e4 ? "u" : "i"}${t5}`;
              }(e3, r3)} out of range [${o2}, ${s2}]: ${i2}`);
            }(t3, this.size, this.unsigned);
          }
          get unsigned() {
            throw new s();
          }
          get size() {
            throw new s();
          }
          slice(t3) {
            return A(this._value, this.size, t3);
          }
          toString() {
            return this._value.toString();
          }
          toJSON() {
            return { _value: this._value.toString() };
          }
          toBigInt() {
            return BigInt(this._value);
          }
          static read(t3) {
            const { size: e3 } = this.prototype;
            return 64 === e3 ? new this(t3.readBigUInt64BE()) : new this(...Array.from({ length: e3 / 64 }, () => t3.readBigUInt64BE()).reverse());
          }
          static write(t3, e3) {
            if (t3 instanceof this) t3 = t3._value;
            else if ("bigint" != typeof t3 || t3 > this.MAX_VALUE || t3 < this.MIN_VALUE) throw new n(`${t3} is not a ${this.name}`);
            const { unsigned: r3, size: i2 } = this.prototype;
            if (64 === i2) r3 ? e3.writeBigUInt64BE(t3) : e3.writeBigInt64BE(t3);
            else for (const n2 of A(t3, i2, 64).reverse()) r3 ? e3.writeBigUInt64BE(n2) : e3.writeBigInt64BE(n2);
          }
          static isValid(t3) {
            return "bigint" == typeof t3 || t3 instanceof this;
          }
          static fromString(t3) {
            return new this(t3);
          }
          static MAX_VALUE = 0n;
          static MIN_VALUE = 0n;
          static defineIntBoundaries() {
            const [t3, e3] = I(this.prototype.size, this.prototype.unsigned);
            this.MIN_VALUE = t3, this.MAX_VALUE = e3;
          }
        }
        class U extends x {
          constructor(...t3) {
            super(t3);
          }
          get low() {
            return Number(0xffffffffn & this._value) | 0;
          }
          get high() {
            return Number(this._value >> 32n) | 0;
          }
          get size() {
            return 64;
          }
          get unsigned() {
            return false;
          }
          static fromBits(t3, e3) {
            return new this(t3, e3);
          }
        }
        U.defineIntBoundaries();
        const $ = 4294967295;
        class R extends d {
          static read(t3) {
            return t3.readUInt32BE();
          }
          static write(t3, e3) {
            if ("number" != typeof t3 || !(t3 >= 0 && t3 <= $) || t3 % 1 != 0) throw new n("invalid u32 value");
            e3.writeUInt32BE(t3);
          }
          static isValid(t3) {
            return "number" == typeof t3 && t3 % 1 == 0 && (t3 >= 0 && t3 <= $);
          }
        }
        R.MAX_VALUE = $, R.MIN_VALUE = 0;
        class T extends x {
          constructor(...t3) {
            super(t3);
          }
          get low() {
            return Number(0xffffffffn & this._value) | 0;
          }
          get high() {
            return Number(this._value >> 32n) | 0;
          }
          get size() {
            return 64;
          }
          get unsigned() {
            return true;
          }
          static fromBits(t3, e3) {
            return new this(t3, e3);
          }
        }
        T.defineIntBoundaries();
        class O extends d {
          static read(t3) {
            return t3.readFloatBE();
          }
          static write(t3, e3) {
            if ("number" != typeof t3) throw new n("not a number");
            e3.writeFloatBE(t3);
          }
          static isValid(t3) {
            return "number" == typeof t3;
          }
        }
        class L extends d {
          static read(t3) {
            return t3.readDoubleBE();
          }
          static write(t3, e3) {
            if ("number" != typeof t3) throw new n("not a number");
            e3.writeDoubleBE(t3);
          }
          static isValid(t3) {
            return "number" == typeof t3;
          }
        }
        class N extends d {
          static read() {
            throw new o("quadruple not supported");
          }
          static write() {
            throw new o("quadruple not supported");
          }
          static isValid() {
            return false;
          }
        }
        class S extends d {
          static read(t3) {
            const e3 = v.read(t3);
            switch (e3) {
              case 0:
                return false;
              case 1:
                return true;
              default:
                throw new i(`got ${e3} when trying to read a bool`);
            }
          }
          static write(t3, e3) {
            const r3 = t3 ? 1 : 0;
            v.write(r3, e3);
          }
          static isValid(t3) {
            return "boolean" == typeof t3;
          }
        }
        var V = r2(616).A;
        class M extends g {
          constructor(t3 = R.MAX_VALUE) {
            super(), this._maxLength = t3;
          }
          read(t3) {
            const e3 = R.read(t3);
            if (e3 > this._maxLength) throw new i(`saw ${e3} length String, max allowed is ${this._maxLength}`);
            return t3.read(e3);
          }
          readString(t3) {
            return this.read(t3).toString("utf8");
          }
          write(t3, e3) {
            const r3 = "string" == typeof t3 ? V.byteLength(t3, "utf8") : t3.length;
            if (r3 > this._maxLength) throw new n(`got ${t3.length} bytes, max allowed is ${this._maxLength}`);
            R.write(r3, e3), e3.write(t3, r3);
          }
          isValid(t3) {
            return "string" == typeof t3 ? V.byteLength(t3, "utf8") <= this._maxLength : !!(t3 instanceof Array || V.isBuffer(t3)) && t3.length <= this._maxLength;
          }
        }
        var C = r2(616).A;
        class D extends g {
          constructor(t3) {
            super(), this._length = t3;
          }
          read(t3) {
            return t3.read(this._length);
          }
          write(t3, e3) {
            const { length: r3 } = t3;
            if (r3 !== this._length) throw new n(`got ${t3.length} bytes, expected ${this._length}`);
            e3.write(t3, r3);
          }
          isValid(t3) {
            return C.isBuffer(t3) && t3.length === this._length;
          }
        }
        var j = r2(616).A;
        class z extends g {
          constructor(t3 = R.MAX_VALUE) {
            super(), this._maxLength = t3;
          }
          read(t3) {
            const e3 = R.read(t3);
            if (e3 > this._maxLength) throw new i(`saw ${e3} length VarOpaque, max allowed is ${this._maxLength}`);
            return t3.read(e3);
          }
          write(t3, e3) {
            const { length: r3 } = t3;
            if (t3.length > this._maxLength) throw new n(`got ${t3.length} bytes, max allowed is ${this._maxLength}`);
            R.write(r3, e3), e3.write(t3, r3);
          }
          isValid(t3) {
            return j.isBuffer(t3) && t3.length <= this._maxLength;
          }
        }
        class F extends g {
          constructor(t3, e3) {
            super(), this._childType = t3, this._length = e3;
          }
          read(t3) {
            const e3 = new r2.g.Array(this._length);
            for (let r3 = 0; r3 < this._length; r3++) e3[r3] = this._childType.read(t3);
            return e3;
          }
          write(t3, e3) {
            if (!r2.g.Array.isArray(t3)) throw new n("value is not array");
            if (t3.length !== this._length) throw new n(`got array of size ${t3.length}, expected ${this._length}`);
            for (const r3 of t3) this._childType.write(r3, e3);
          }
          isValid(t3) {
            if (!(t3 instanceof r2.g.Array) || t3.length !== this._length) return false;
            for (const e3 of t3) if (!this._childType.isValid(e3)) return false;
            return true;
          }
        }
        class P extends g {
          constructor(t3, e3 = R.MAX_VALUE) {
            super(), this._childType = t3, this._maxLength = e3;
          }
          read(t3) {
            const e3 = R.read(t3);
            if (e3 > this._maxLength) throw new i(`saw ${e3} length VarArray, max allowed is ${this._maxLength}`);
            const r3 = new Array(e3);
            for (let n2 = 0; n2 < e3; n2++) r3[n2] = this._childType.read(t3);
            return r3;
          }
          write(t3, e3) {
            if (!(t3 instanceof Array)) throw new n("value is not array");
            if (t3.length > this._maxLength) throw new n(`got array of size ${t3.length}, max allowed is ${this._maxLength}`);
            R.write(t3.length, e3);
            for (const r3 of t3) this._childType.write(r3, e3);
          }
          isValid(t3) {
            if (!(t3 instanceof Array) || t3.length > this._maxLength) return false;
            for (const e3 of t3) if (!this._childType.isValid(e3)) return false;
            return true;
          }
        }
        class X extends d {
          constructor(t3) {
            super(), this._childType = t3;
          }
          read(t3) {
            if (S.read(t3)) return this._childType.read(t3);
          }
          write(t3, e3) {
            const r3 = null != t3;
            S.write(r3, e3), r3 && this._childType.write(t3, e3);
          }
          isValid(t3) {
            return null == t3 || this._childType.isValid(t3);
          }
        }
        class k extends d {
          static read() {
          }
          static write(t3) {
            if (void 0 !== t3) throw new n("trying to write value to a void slot");
          }
          static isValid(t3) {
            return void 0 === t3;
          }
        }
        class q extends d {
          constructor(t3, e3) {
            super(), this.name = t3, this.value = e3;
          }
          static read(t3) {
            const e3 = v.read(t3), r3 = this._byValue[e3];
            if (void 0 === r3) throw new i(`unknown ${this.enumName} member for value ${e3}`);
            return r3;
          }
          static write(t3, e3) {
            if (!this.isValid(t3)) throw new n(`${t3} has enum name ${t3?.enumName}, not ${this.enumName}: ${JSON.stringify(t3)}`);
            v.write(t3.value, e3);
          }
          static isValid(t3) {
            return t3?.constructor?.enumName === this.enumName || b(t3, this);
          }
          static members() {
            return this._members;
          }
          static values() {
            return Object.values(this._members);
          }
          static fromName(t3) {
            const e3 = this._members[t3];
            if (!e3) throw new TypeError(`${t3} is not a member of ${this.enumName}`);
            return e3;
          }
          static fromValue(t3) {
            const e3 = this._byValue[t3];
            if (void 0 === e3) throw new TypeError(`${t3} is not a value of any member of ${this.enumName}`);
            return e3;
          }
          static create(t3, e3, r3) {
            const n2 = class extends q {
            };
            n2.enumName = e3, t3.results[e3] = n2, n2._members = {}, n2._byValue = {};
            for (const [t4, e4] of Object.entries(r3)) {
              const r4 = new n2(t4, e4);
              n2._members[t4] = r4, n2._byValue[e4] = r4, n2[t4] = () => r4;
            }
            return n2;
          }
        }
        class G extends d {
          resolve() {
            throw new o('"resolve" method should be implemented in the descendant class');
          }
        }
        class Y extends g {
          constructor(t3) {
            super(), this._attributes = t3 || {};
          }
          static read(t3) {
            const e3 = {};
            for (const [r3, n2] of this._fields) e3[r3] = n2.read(t3);
            return new this(e3);
          }
          static write(t3, e3) {
            if (!this.isValid(t3)) throw new n(`${t3} has struct name ${t3?.constructor?.structName}, not ${this.structName}: ${JSON.stringify(t3)}`);
            for (const [r3, n2] of this._fields) {
              const i2 = t3._attributes[r3];
              n2.write(i2, e3);
            }
          }
          static isValid(t3) {
            return t3?.constructor?.structName === this.structName || b(t3, this);
          }
          static create(t3, e3, r3) {
            const n2 = class extends Y {
            };
            n2.structName = e3, t3.results[e3] = n2;
            const i2 = new Array(r3.length);
            for (let e4 = 0; e4 < r3.length; e4++) {
              const o2 = r3[e4], s2 = o2[0];
              let u2 = o2[1];
              u2 instanceof G && (u2 = u2.resolve(t3)), i2[e4] = [s2, u2], n2.prototype[s2] = J(s2);
            }
            return n2._fields = i2, n2;
          }
        }
        function J(t3) {
          return function(e3) {
            return void 0 !== e3 && (this._attributes[t3] = e3), this._attributes[t3];
          };
        }
        class W extends g {
          constructor(t3, e3) {
            super(), this.set(t3, e3);
          }
          set(t3, e3) {
            "string" == typeof t3 && (t3 = this.constructor._switchOn.fromName(t3)), this._switch = t3;
            const r3 = this.constructor.armForSwitch(this._switch);
            this._arm = r3, this._armType = r3 === k ? k : this.constructor._arms[r3], this._value = e3;
          }
          get(t3 = this._arm) {
            if (this._arm !== k && this._arm !== t3) throw new TypeError(`${t3} not set`);
            return this._value;
          }
          switch() {
            return this._switch;
          }
          arm() {
            return this._arm;
          }
          armType() {
            return this._armType;
          }
          value() {
            return this._value;
          }
          static armForSwitch(t3) {
            const e3 = this._switches.get(t3);
            if (void 0 !== e3) return e3;
            if (this._defaultArm) return this._defaultArm;
            throw new TypeError(`Bad union switch: ${t3}`);
          }
          static armTypeForArm(t3) {
            return t3 === k ? k : this._arms[t3];
          }
          static read(t3) {
            const e3 = this._switchOn.read(t3), r3 = this.armForSwitch(e3), n2 = r3 === k ? k : this._arms[r3];
            let i2;
            return i2 = void 0 !== n2 ? n2.read(t3) : r3.read(t3), new this(e3, i2);
          }
          static write(t3, e3) {
            if (!this.isValid(t3)) throw new n(`${t3} has union name ${t3?.unionName}, not ${this.unionName}: ${JSON.stringify(t3)}`);
            this._switchOn.write(t3.switch(), e3), t3.armType().write(t3.value(), e3);
          }
          static isValid(t3) {
            return t3?.constructor?.unionName === this.unionName || b(t3, this);
          }
          static create(t3, e3, r3) {
            const n2 = class extends W {
            };
            n2.unionName = e3, t3.results[e3] = n2, r3.switchOn instanceof G ? n2._switchOn = r3.switchOn.resolve(t3) : n2._switchOn = r3.switchOn, n2._switches = /* @__PURE__ */ new Map(), n2._arms = {};
            let i2 = r3.defaultArm;
            i2 instanceof G && (i2 = i2.resolve(t3)), n2._defaultArm = i2;
            for (const [t4, e4] of r3.switches) {
              const r4 = "string" == typeof t4 ? n2._switchOn.fromName(t4) : t4;
              n2._switches.set(r4, e4);
            }
            if (void 0 !== n2._switchOn.values) for (const t4 of n2._switchOn.values()) n2[t4.name] = function(e4) {
              return new n2(t4, e4);
            }, n2.prototype[t4.name] = function(e4) {
              return this.set(t4, e4);
            };
            if (r3.arms) for (const [e4, i3] of Object.entries(r3.arms)) n2._arms[e4] = i3 instanceof G ? i3.resolve(t3) : i3, i3 !== k && (n2.prototype[e4] = function() {
              return this.get(e4);
            });
            return n2;
          }
        }
        class H extends G {
          constructor(t3) {
            super(), this.name = t3;
          }
          resolve(t3) {
            return t3.definitions[this.name].resolve(t3);
          }
        }
        class Q extends G {
          constructor(t3, e3, r3 = false) {
            super(), this.childReference = t3, this.length = e3, this.variable = r3;
          }
          resolve(t3) {
            let e3 = this.childReference, r3 = this.length;
            return e3 instanceof G && (e3 = e3.resolve(t3)), r3 instanceof G && (r3 = r3.resolve(t3)), this.variable ? new P(e3, r3) : new F(e3, r3);
          }
        }
        class Z extends G {
          constructor(t3) {
            super(), this.childReference = t3, this.name = t3.name;
          }
          resolve(t3) {
            let e3 = this.childReference;
            return e3 instanceof G && (e3 = e3.resolve(t3)), new X(e3);
          }
        }
        class K extends G {
          constructor(t3, e3) {
            super(), this.sizedType = t3, this.length = e3;
          }
          resolve(t3) {
            let e3 = this.length;
            return e3 instanceof G && (e3 = e3.resolve(t3)), new this.sizedType(e3);
          }
        }
        class tt {
          constructor(t3, e3, r3) {
            this.constructor = t3, this.name = e3, this.config = r3;
          }
          resolve(t3) {
            return this.name in t3.results ? t3.results[this.name] : this.constructor(t3, this.name, this.config);
          }
        }
        function et(t3, e3, r3) {
          return r3 instanceof G && (r3 = r3.resolve(t3)), t3.results[e3] = r3, r3;
        }
        function rt(t3, e3, r3) {
          return t3.results[e3] = r3, r3;
        }
        class nt {
          constructor(t3) {
            this._destination = t3, this._definitions = {};
          }
          enum(t3, e3) {
            const r3 = new tt(q.create, t3, e3);
            this.define(t3, r3);
          }
          struct(t3, e3) {
            const r3 = new tt(Y.create, t3, e3);
            this.define(t3, r3);
          }
          union(t3, e3) {
            const r3 = new tt(W.create, t3, e3);
            this.define(t3, r3);
          }
          typedef(t3, e3) {
            const r3 = new tt(et, t3, e3);
            this.define(t3, r3);
          }
          const(t3, e3) {
            const r3 = new tt(rt, t3, e3);
            this.define(t3, r3);
          }
          void() {
            return k;
          }
          bool() {
            return S;
          }
          int() {
            return v;
          }
          hyper() {
            return U;
          }
          uint() {
            return R;
          }
          uhyper() {
            return T;
          }
          float() {
            return O;
          }
          double() {
            return L;
          }
          quadruple() {
            return N;
          }
          string(t3) {
            return new K(M, t3);
          }
          opaque(t3) {
            return new K(D, t3);
          }
          varOpaque(t3) {
            return new K(z, t3);
          }
          array(t3, e3) {
            return new Q(t3, e3);
          }
          varArray(t3, e3) {
            return new Q(t3, e3, true);
          }
          option(t3) {
            return new Z(t3);
          }
          define(t3, e3) {
            if (void 0 !== this._destination[t3]) throw new o(`${t3} is already defined`);
            this._definitions[t3] = e3;
          }
          lookup(t3) {
            return new H(t3);
          }
          resolve() {
            for (const t3 of Object.values(this._definitions)) t3.resolve({ definitions: this._definitions, results: this._destination });
          }
        }
        function it(t3, e3 = {}) {
          if (t3) {
            const r3 = new nt(e3);
            t3(r3), r3.resolve();
          }
          return e3;
        }
      }, 526: (t2, e2) => {
        "use strict";
        e2.byteLength = function(t3) {
          var e3 = u(t3), r3 = e3[0], n2 = e3[1];
          return 3 * (r3 + n2) / 4 - n2;
        }, e2.toByteArray = function(t3) {
          var e3, r3, o2 = u(t3), s2 = o2[0], f2 = o2[1], a = new i(function(t4, e4, r4) {
            return 3 * (e4 + r4) / 4 - r4;
          }(0, s2, f2)), h = 0, c = f2 > 0 ? s2 - 4 : s2;
          for (r3 = 0; r3 < c; r3 += 4) e3 = n[t3.charCodeAt(r3)] << 18 | n[t3.charCodeAt(r3 + 1)] << 12 | n[t3.charCodeAt(r3 + 2)] << 6 | n[t3.charCodeAt(r3 + 3)], a[h++] = e3 >> 16 & 255, a[h++] = e3 >> 8 & 255, a[h++] = 255 & e3;
          2 === f2 && (e3 = n[t3.charCodeAt(r3)] << 2 | n[t3.charCodeAt(r3 + 1)] >> 4, a[h++] = 255 & e3);
          1 === f2 && (e3 = n[t3.charCodeAt(r3)] << 10 | n[t3.charCodeAt(r3 + 1)] << 4 | n[t3.charCodeAt(r3 + 2)] >> 2, a[h++] = e3 >> 8 & 255, a[h++] = 255 & e3);
          return a;
        }, e2.fromByteArray = function(t3) {
          for (var e3, n2 = t3.length, i2 = n2 % 3, o2 = [], s2 = 16383, u2 = 0, a = n2 - i2; u2 < a; u2 += s2) o2.push(f(t3, u2, u2 + s2 > a ? a : u2 + s2));
          1 === i2 ? (e3 = t3[n2 - 1], o2.push(r2[e3 >> 2] + r2[e3 << 4 & 63] + "==")) : 2 === i2 && (e3 = (t3[n2 - 2] << 8) + t3[n2 - 1], o2.push(r2[e3 >> 10] + r2[e3 >> 4 & 63] + r2[e3 << 2 & 63] + "="));
          return o2.join("");
        };
        for (var r2 = [], n = [], i = "undefined" != typeof Uint8Array ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", s = 0; s < 64; ++s) r2[s] = o[s], n[o.charCodeAt(s)] = s;
        function u(t3) {
          var e3 = t3.length;
          if (e3 % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
          var r3 = t3.indexOf("=");
          return -1 === r3 && (r3 = e3), [r3, r3 === e3 ? 0 : 4 - r3 % 4];
        }
        function f(t3, e3, n2) {
          for (var i2, o2, s2 = [], u2 = e3; u2 < n2; u2 += 3) i2 = (t3[u2] << 16 & 16711680) + (t3[u2 + 1] << 8 & 65280) + (255 & t3[u2 + 2]), s2.push(r2[(o2 = i2) >> 18 & 63] + r2[o2 >> 12 & 63] + r2[o2 >> 6 & 63] + r2[63 & o2]);
          return s2.join("");
        }
        n["-".charCodeAt(0)] = 62, n["_".charCodeAt(0)] = 63;
      }, 287: (t2, e2, r2) => {
        "use strict";
        const n = r2(526), i = r2(251), o = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
        e2.hp = f, e2.IS = 50;
        const s = 2147483647;
        function u(t3) {
          if (t3 > s) throw new RangeError('The value "' + t3 + '" is invalid for option "size"');
          const e3 = new Uint8Array(t3);
          return Object.setPrototypeOf(e3, f.prototype), e3;
        }
        function f(t3, e3, r3) {
          if ("number" == typeof t3) {
            if ("string" == typeof e3) throw new TypeError('The "string" argument must be of type string. Received type number');
            return c(t3);
          }
          return a(t3, e3, r3);
        }
        function a(t3, e3, r3) {
          if ("string" == typeof t3) return function(t4, e4) {
            "string" == typeof e4 && "" !== e4 || (e4 = "utf8");
            if (!f.isEncoding(e4)) throw new TypeError("Unknown encoding: " + e4);
            const r4 = 0 | g(t4, e4);
            let n3 = u(r4);
            const i3 = n3.write(t4, e4);
            i3 !== r4 && (n3 = n3.slice(0, i3));
            return n3;
          }(t3, e3);
          if (ArrayBuffer.isView(t3)) return function(t4) {
            if (W(t4, Uint8Array)) {
              const e4 = new Uint8Array(t4);
              return p(e4.buffer, e4.byteOffset, e4.byteLength);
            }
            return l(t4);
          }(t3);
          if (null == t3) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t3);
          if (W(t3, ArrayBuffer) || t3 && W(t3.buffer, ArrayBuffer)) return p(t3, e3, r3);
          if ("undefined" != typeof SharedArrayBuffer && (W(t3, SharedArrayBuffer) || t3 && W(t3.buffer, SharedArrayBuffer))) return p(t3, e3, r3);
          if ("number" == typeof t3) throw new TypeError('The "value" argument must not be of type number. Received type number');
          const n2 = t3.valueOf && t3.valueOf();
          if (null != n2 && n2 !== t3) return f.from(n2, e3, r3);
          const i2 = function(t4) {
            if (f.isBuffer(t4)) {
              const e4 = 0 | d(t4.length), r4 = u(e4);
              return 0 === r4.length || t4.copy(r4, 0, 0, e4), r4;
            }
            if (void 0 !== t4.length) return "number" != typeof t4.length || H(t4.length) ? u(0) : l(t4);
            if ("Buffer" === t4.type && Array.isArray(t4.data)) return l(t4.data);
          }(t3);
          if (i2) return i2;
          if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof t3[Symbol.toPrimitive]) return f.from(t3[Symbol.toPrimitive]("string"), e3, r3);
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof t3);
        }
        function h(t3) {
          if ("number" != typeof t3) throw new TypeError('"size" argument must be of type number');
          if (t3 < 0) throw new RangeError('The value "' + t3 + '" is invalid for option "size"');
        }
        function c(t3) {
          return h(t3), u(t3 < 0 ? 0 : 0 | d(t3));
        }
        function l(t3) {
          const e3 = t3.length < 0 ? 0 : 0 | d(t3.length), r3 = u(e3);
          for (let n2 = 0; n2 < e3; n2 += 1) r3[n2] = 255 & t3[n2];
          return r3;
        }
        function p(t3, e3, r3) {
          if (e3 < 0 || t3.byteLength < e3) throw new RangeError('"offset" is outside of buffer bounds');
          if (t3.byteLength < e3 + (r3 || 0)) throw new RangeError('"length" is outside of buffer bounds');
          let n2;
          return n2 = void 0 === e3 && void 0 === r3 ? new Uint8Array(t3) : void 0 === r3 ? new Uint8Array(t3, e3) : new Uint8Array(t3, e3, r3), Object.setPrototypeOf(n2, f.prototype), n2;
        }
        function d(t3) {
          if (t3 >= s) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + s.toString(16) + " bytes");
          return 0 | t3;
        }
        function g(t3, e3) {
          if (f.isBuffer(t3)) return t3.length;
          if (ArrayBuffer.isView(t3) || W(t3, ArrayBuffer)) return t3.byteLength;
          if ("string" != typeof t3) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof t3);
          const r3 = t3.length, n2 = arguments.length > 2 && true === arguments[2];
          if (!n2 && 0 === r3) return 0;
          let i2 = false;
          for (; ; ) switch (e3) {
            case "ascii":
            case "latin1":
            case "binary":
              return r3;
            case "utf8":
            case "utf-8":
              return G(t3).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return 2 * r3;
            case "hex":
              return r3 >>> 1;
            case "base64":
              return Y(t3).length;
            default:
              if (i2) return n2 ? -1 : G(t3).length;
              e3 = ("" + e3).toLowerCase(), i2 = true;
          }
        }
        function y(t3, e3, r3) {
          let n2 = false;
          if ((void 0 === e3 || e3 < 0) && (e3 = 0), e3 > this.length) return "";
          if ((void 0 === r3 || r3 > this.length) && (r3 = this.length), r3 <= 0) return "";
          if ((r3 >>>= 0) <= (e3 >>>= 0)) return "";
          for (t3 || (t3 = "utf8"); ; ) switch (t3) {
            case "hex":
              return T(this, e3, r3);
            case "utf8":
            case "utf-8":
              return x(this, e3, r3);
            case "ascii":
              return $(this, e3, r3);
            case "latin1":
            case "binary":
              return R(this, e3, r3);
            case "base64":
              return I(this, e3, r3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return O(this, e3, r3);
            default:
              if (n2) throw new TypeError("Unknown encoding: " + t3);
              t3 = (t3 + "").toLowerCase(), n2 = true;
          }
        }
        function w(t3, e3, r3) {
          const n2 = t3[e3];
          t3[e3] = t3[r3], t3[r3] = n2;
        }
        function m(t3, e3, r3, n2, i2) {
          if (0 === t3.length) return -1;
          if ("string" == typeof r3 ? (n2 = r3, r3 = 0) : r3 > 2147483647 ? r3 = 2147483647 : r3 < -2147483648 && (r3 = -2147483648), H(r3 = +r3) && (r3 = i2 ? 0 : t3.length - 1), r3 < 0 && (r3 = t3.length + r3), r3 >= t3.length) {
            if (i2) return -1;
            r3 = t3.length - 1;
          } else if (r3 < 0) {
            if (!i2) return -1;
            r3 = 0;
          }
          if ("string" == typeof e3 && (e3 = f.from(e3, n2)), f.isBuffer(e3)) return 0 === e3.length ? -1 : b(t3, e3, r3, n2, i2);
          if ("number" == typeof e3) return e3 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? i2 ? Uint8Array.prototype.indexOf.call(t3, e3, r3) : Uint8Array.prototype.lastIndexOf.call(t3, e3, r3) : b(t3, [e3], r3, n2, i2);
          throw new TypeError("val must be string, number or Buffer");
        }
        function b(t3, e3, r3, n2, i2) {
          let o2, s2 = 1, u2 = t3.length, f2 = e3.length;
          if (void 0 !== n2 && ("ucs2" === (n2 = String(n2).toLowerCase()) || "ucs-2" === n2 || "utf16le" === n2 || "utf-16le" === n2)) {
            if (t3.length < 2 || e3.length < 2) return -1;
            s2 = 2, u2 /= 2, f2 /= 2, r3 /= 2;
          }
          function a2(t4, e4) {
            return 1 === s2 ? t4[e4] : t4.readUInt16BE(e4 * s2);
          }
          if (i2) {
            let n3 = -1;
            for (o2 = r3; o2 < u2; o2++) if (a2(t3, o2) === a2(e3, -1 === n3 ? 0 : o2 - n3)) {
              if (-1 === n3 && (n3 = o2), o2 - n3 + 1 === f2) return n3 * s2;
            } else -1 !== n3 && (o2 -= o2 - n3), n3 = -1;
          } else for (r3 + f2 > u2 && (r3 = u2 - f2), o2 = r3; o2 >= 0; o2--) {
            let r4 = true;
            for (let n3 = 0; n3 < f2; n3++) if (a2(t3, o2 + n3) !== a2(e3, n3)) {
              r4 = false;
              break;
            }
            if (r4) return o2;
          }
          return -1;
        }
        function _(t3, e3, r3, n2) {
          r3 = Number(r3) || 0;
          const i2 = t3.length - r3;
          n2 ? (n2 = Number(n2)) > i2 && (n2 = i2) : n2 = i2;
          const o2 = e3.length;
          let s2;
          for (n2 > o2 / 2 && (n2 = o2 / 2), s2 = 0; s2 < n2; ++s2) {
            const n3 = parseInt(e3.substr(2 * s2, 2), 16);
            if (H(n3)) return s2;
            t3[r3 + s2] = n3;
          }
          return s2;
        }
        function B(t3, e3, r3, n2) {
          return J(G(e3, t3.length - r3), t3, r3, n2);
        }
        function E(t3, e3, r3, n2) {
          return J(function(t4) {
            const e4 = [];
            for (let r4 = 0; r4 < t4.length; ++r4) e4.push(255 & t4.charCodeAt(r4));
            return e4;
          }(e3), t3, r3, n2);
        }
        function v(t3, e3, r3, n2) {
          return J(Y(e3), t3, r3, n2);
        }
        function A(t3, e3, r3, n2) {
          return J(function(t4, e4) {
            let r4, n3, i2;
            const o2 = [];
            for (let s2 = 0; s2 < t4.length && !((e4 -= 2) < 0); ++s2) r4 = t4.charCodeAt(s2), n3 = r4 >> 8, i2 = r4 % 256, o2.push(i2), o2.push(n3);
            return o2;
          }(e3, t3.length - r3), t3, r3, n2);
        }
        function I(t3, e3, r3) {
          return 0 === e3 && r3 === t3.length ? n.fromByteArray(t3) : n.fromByteArray(t3.slice(e3, r3));
        }
        function x(t3, e3, r3) {
          r3 = Math.min(t3.length, r3);
          const n2 = [];
          let i2 = e3;
          for (; i2 < r3; ) {
            const e4 = t3[i2];
            let o2 = null, s2 = e4 > 239 ? 4 : e4 > 223 ? 3 : e4 > 191 ? 2 : 1;
            if (i2 + s2 <= r3) {
              let r4, n3, u2, f2;
              switch (s2) {
                case 1:
                  e4 < 128 && (o2 = e4);
                  break;
                case 2:
                  r4 = t3[i2 + 1], 128 == (192 & r4) && (f2 = (31 & e4) << 6 | 63 & r4, f2 > 127 && (o2 = f2));
                  break;
                case 3:
                  r4 = t3[i2 + 1], n3 = t3[i2 + 2], 128 == (192 & r4) && 128 == (192 & n3) && (f2 = (15 & e4) << 12 | (63 & r4) << 6 | 63 & n3, f2 > 2047 && (f2 < 55296 || f2 > 57343) && (o2 = f2));
                  break;
                case 4:
                  r4 = t3[i2 + 1], n3 = t3[i2 + 2], u2 = t3[i2 + 3], 128 == (192 & r4) && 128 == (192 & n3) && 128 == (192 & u2) && (f2 = (15 & e4) << 18 | (63 & r4) << 12 | (63 & n3) << 6 | 63 & u2, f2 > 65535 && f2 < 1114112 && (o2 = f2));
              }
            }
            null === o2 ? (o2 = 65533, s2 = 1) : o2 > 65535 && (o2 -= 65536, n2.push(o2 >>> 10 & 1023 | 55296), o2 = 56320 | 1023 & o2), n2.push(o2), i2 += s2;
          }
          return function(t4) {
            const e4 = t4.length;
            if (e4 <= U) return String.fromCharCode.apply(String, t4);
            let r4 = "", n3 = 0;
            for (; n3 < e4; ) r4 += String.fromCharCode.apply(String, t4.slice(n3, n3 += U));
            return r4;
          }(n2);
        }
        f.TYPED_ARRAY_SUPPORT = function() {
          try {
            const t3 = new Uint8Array(1), e3 = { foo: function() {
              return 42;
            } };
            return Object.setPrototypeOf(e3, Uint8Array.prototype), Object.setPrototypeOf(t3, e3), 42 === t3.foo();
          } catch (t3) {
            return false;
          }
        }(), f.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(f.prototype, "parent", { enumerable: true, get: function() {
          if (f.isBuffer(this)) return this.buffer;
        } }), Object.defineProperty(f.prototype, "offset", { enumerable: true, get: function() {
          if (f.isBuffer(this)) return this.byteOffset;
        } }), f.poolSize = 8192, f.from = function(t3, e3, r3) {
          return a(t3, e3, r3);
        }, Object.setPrototypeOf(f.prototype, Uint8Array.prototype), Object.setPrototypeOf(f, Uint8Array), f.alloc = function(t3, e3, r3) {
          return function(t4, e4, r4) {
            return h(t4), t4 <= 0 ? u(t4) : void 0 !== e4 ? "string" == typeof r4 ? u(t4).fill(e4, r4) : u(t4).fill(e4) : u(t4);
          }(t3, e3, r3);
        }, f.allocUnsafe = function(t3) {
          return c(t3);
        }, f.allocUnsafeSlow = function(t3) {
          return c(t3);
        }, f.isBuffer = function(t3) {
          return null != t3 && true === t3._isBuffer && t3 !== f.prototype;
        }, f.compare = function(t3, e3) {
          if (W(t3, Uint8Array) && (t3 = f.from(t3, t3.offset, t3.byteLength)), W(e3, Uint8Array) && (e3 = f.from(e3, e3.offset, e3.byteLength)), !f.isBuffer(t3) || !f.isBuffer(e3)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
          if (t3 === e3) return 0;
          let r3 = t3.length, n2 = e3.length;
          for (let i2 = 0, o2 = Math.min(r3, n2); i2 < o2; ++i2) if (t3[i2] !== e3[i2]) {
            r3 = t3[i2], n2 = e3[i2];
            break;
          }
          return r3 < n2 ? -1 : n2 < r3 ? 1 : 0;
        }, f.isEncoding = function(t3) {
          switch (String(t3).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "latin1":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, f.concat = function(t3, e3) {
          if (!Array.isArray(t3)) throw new TypeError('"list" argument must be an Array of Buffers');
          if (0 === t3.length) return f.alloc(0);
          let r3;
          if (void 0 === e3) for (e3 = 0, r3 = 0; r3 < t3.length; ++r3) e3 += t3[r3].length;
          const n2 = f.allocUnsafe(e3);
          let i2 = 0;
          for (r3 = 0; r3 < t3.length; ++r3) {
            let e4 = t3[r3];
            if (W(e4, Uint8Array)) i2 + e4.length > n2.length ? (f.isBuffer(e4) || (e4 = f.from(e4)), e4.copy(n2, i2)) : Uint8Array.prototype.set.call(n2, e4, i2);
            else {
              if (!f.isBuffer(e4)) throw new TypeError('"list" argument must be an Array of Buffers');
              e4.copy(n2, i2);
            }
            i2 += e4.length;
          }
          return n2;
        }, f.byteLength = g, f.prototype._isBuffer = true, f.prototype.swap16 = function() {
          const t3 = this.length;
          if (t3 % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
          for (let e3 = 0; e3 < t3; e3 += 2) w(this, e3, e3 + 1);
          return this;
        }, f.prototype.swap32 = function() {
          const t3 = this.length;
          if (t3 % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
          for (let e3 = 0; e3 < t3; e3 += 4) w(this, e3, e3 + 3), w(this, e3 + 1, e3 + 2);
          return this;
        }, f.prototype.swap64 = function() {
          const t3 = this.length;
          if (t3 % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
          for (let e3 = 0; e3 < t3; e3 += 8) w(this, e3, e3 + 7), w(this, e3 + 1, e3 + 6), w(this, e3 + 2, e3 + 5), w(this, e3 + 3, e3 + 4);
          return this;
        }, f.prototype.toString = function() {
          const t3 = this.length;
          return 0 === t3 ? "" : 0 === arguments.length ? x(this, 0, t3) : y.apply(this, arguments);
        }, f.prototype.toLocaleString = f.prototype.toString, f.prototype.equals = function(t3) {
          if (!f.isBuffer(t3)) throw new TypeError("Argument must be a Buffer");
          return this === t3 || 0 === f.compare(this, t3);
        }, f.prototype.inspect = function() {
          let t3 = "";
          const r3 = e2.IS;
          return t3 = this.toString("hex", 0, r3).replace(/(.{2})/g, "$1 ").trim(), this.length > r3 && (t3 += " ... "), "<Buffer " + t3 + ">";
        }, o && (f.prototype[o] = f.prototype.inspect), f.prototype.compare = function(t3, e3, r3, n2, i2) {
          if (W(t3, Uint8Array) && (t3 = f.from(t3, t3.offset, t3.byteLength)), !f.isBuffer(t3)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t3);
          if (void 0 === e3 && (e3 = 0), void 0 === r3 && (r3 = t3 ? t3.length : 0), void 0 === n2 && (n2 = 0), void 0 === i2 && (i2 = this.length), e3 < 0 || r3 > t3.length || n2 < 0 || i2 > this.length) throw new RangeError("out of range index");
          if (n2 >= i2 && e3 >= r3) return 0;
          if (n2 >= i2) return -1;
          if (e3 >= r3) return 1;
          if (this === t3) return 0;
          let o2 = (i2 >>>= 0) - (n2 >>>= 0), s2 = (r3 >>>= 0) - (e3 >>>= 0);
          const u2 = Math.min(o2, s2), a2 = this.slice(n2, i2), h2 = t3.slice(e3, r3);
          for (let t4 = 0; t4 < u2; ++t4) if (a2[t4] !== h2[t4]) {
            o2 = a2[t4], s2 = h2[t4];
            break;
          }
          return o2 < s2 ? -1 : s2 < o2 ? 1 : 0;
        }, f.prototype.includes = function(t3, e3, r3) {
          return -1 !== this.indexOf(t3, e3, r3);
        }, f.prototype.indexOf = function(t3, e3, r3) {
          return m(this, t3, e3, r3, true);
        }, f.prototype.lastIndexOf = function(t3, e3, r3) {
          return m(this, t3, e3, r3, false);
        }, f.prototype.write = function(t3, e3, r3, n2) {
          if (void 0 === e3) n2 = "utf8", r3 = this.length, e3 = 0;
          else if (void 0 === r3 && "string" == typeof e3) n2 = e3, r3 = this.length, e3 = 0;
          else {
            if (!isFinite(e3)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
            e3 >>>= 0, isFinite(r3) ? (r3 >>>= 0, void 0 === n2 && (n2 = "utf8")) : (n2 = r3, r3 = void 0);
          }
          const i2 = this.length - e3;
          if ((void 0 === r3 || r3 > i2) && (r3 = i2), t3.length > 0 && (r3 < 0 || e3 < 0) || e3 > this.length) throw new RangeError("Attempt to write outside buffer bounds");
          n2 || (n2 = "utf8");
          let o2 = false;
          for (; ; ) switch (n2) {
            case "hex":
              return _(this, t3, e3, r3);
            case "utf8":
            case "utf-8":
              return B(this, t3, e3, r3);
            case "ascii":
            case "latin1":
            case "binary":
              return E(this, t3, e3, r3);
            case "base64":
              return v(this, t3, e3, r3);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return A(this, t3, e3, r3);
            default:
              if (o2) throw new TypeError("Unknown encoding: " + n2);
              n2 = ("" + n2).toLowerCase(), o2 = true;
          }
        }, f.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        };
        const U = 4096;
        function $(t3, e3, r3) {
          let n2 = "";
          r3 = Math.min(t3.length, r3);
          for (let i2 = e3; i2 < r3; ++i2) n2 += String.fromCharCode(127 & t3[i2]);
          return n2;
        }
        function R(t3, e3, r3) {
          let n2 = "";
          r3 = Math.min(t3.length, r3);
          for (let i2 = e3; i2 < r3; ++i2) n2 += String.fromCharCode(t3[i2]);
          return n2;
        }
        function T(t3, e3, r3) {
          const n2 = t3.length;
          (!e3 || e3 < 0) && (e3 = 0), (!r3 || r3 < 0 || r3 > n2) && (r3 = n2);
          let i2 = "";
          for (let n3 = e3; n3 < r3; ++n3) i2 += Q[t3[n3]];
          return i2;
        }
        function O(t3, e3, r3) {
          const n2 = t3.slice(e3, r3);
          let i2 = "";
          for (let t4 = 0; t4 < n2.length - 1; t4 += 2) i2 += String.fromCharCode(n2[t4] + 256 * n2[t4 + 1]);
          return i2;
        }
        function L(t3, e3, r3) {
          if (t3 % 1 != 0 || t3 < 0) throw new RangeError("offset is not uint");
          if (t3 + e3 > r3) throw new RangeError("Trying to access beyond buffer length");
        }
        function N(t3, e3, r3, n2, i2, o2) {
          if (!f.isBuffer(t3)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (e3 > i2 || e3 < o2) throw new RangeError('"value" argument is out of bounds');
          if (r3 + n2 > t3.length) throw new RangeError("Index out of range");
        }
        function S(t3, e3, r3, n2, i2) {
          P(e3, n2, i2, t3, r3, 7);
          let o2 = Number(e3 & BigInt(4294967295));
          t3[r3++] = o2, o2 >>= 8, t3[r3++] = o2, o2 >>= 8, t3[r3++] = o2, o2 >>= 8, t3[r3++] = o2;
          let s2 = Number(e3 >> BigInt(32) & BigInt(4294967295));
          return t3[r3++] = s2, s2 >>= 8, t3[r3++] = s2, s2 >>= 8, t3[r3++] = s2, s2 >>= 8, t3[r3++] = s2, r3;
        }
        function V(t3, e3, r3, n2, i2) {
          P(e3, n2, i2, t3, r3, 7);
          let o2 = Number(e3 & BigInt(4294967295));
          t3[r3 + 7] = o2, o2 >>= 8, t3[r3 + 6] = o2, o2 >>= 8, t3[r3 + 5] = o2, o2 >>= 8, t3[r3 + 4] = o2;
          let s2 = Number(e3 >> BigInt(32) & BigInt(4294967295));
          return t3[r3 + 3] = s2, s2 >>= 8, t3[r3 + 2] = s2, s2 >>= 8, t3[r3 + 1] = s2, s2 >>= 8, t3[r3] = s2, r3 + 8;
        }
        function M(t3, e3, r3, n2, i2, o2) {
          if (r3 + n2 > t3.length) throw new RangeError("Index out of range");
          if (r3 < 0) throw new RangeError("Index out of range");
        }
        function C(t3, e3, r3, n2, o2) {
          return e3 = +e3, r3 >>>= 0, o2 || M(t3, 0, r3, 4), i.write(t3, e3, r3, n2, 23, 4), r3 + 4;
        }
        function D(t3, e3, r3, n2, o2) {
          return e3 = +e3, r3 >>>= 0, o2 || M(t3, 0, r3, 8), i.write(t3, e3, r3, n2, 52, 8), r3 + 8;
        }
        f.prototype.slice = function(t3, e3) {
          const r3 = this.length;
          (t3 = ~~t3) < 0 ? (t3 += r3) < 0 && (t3 = 0) : t3 > r3 && (t3 = r3), (e3 = void 0 === e3 ? r3 : ~~e3) < 0 ? (e3 += r3) < 0 && (e3 = 0) : e3 > r3 && (e3 = r3), e3 < t3 && (e3 = t3);
          const n2 = this.subarray(t3, e3);
          return Object.setPrototypeOf(n2, f.prototype), n2;
        }, f.prototype.readUintLE = f.prototype.readUIntLE = function(t3, e3, r3) {
          t3 >>>= 0, e3 >>>= 0, r3 || L(t3, e3, this.length);
          let n2 = this[t3], i2 = 1, o2 = 0;
          for (; ++o2 < e3 && (i2 *= 256); ) n2 += this[t3 + o2] * i2;
          return n2;
        }, f.prototype.readUintBE = f.prototype.readUIntBE = function(t3, e3, r3) {
          t3 >>>= 0, e3 >>>= 0, r3 || L(t3, e3, this.length);
          let n2 = this[t3 + --e3], i2 = 1;
          for (; e3 > 0 && (i2 *= 256); ) n2 += this[t3 + --e3] * i2;
          return n2;
        }, f.prototype.readUint8 = f.prototype.readUInt8 = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 1, this.length), this[t3];
        }, f.prototype.readUint16LE = f.prototype.readUInt16LE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 2, this.length), this[t3] | this[t3 + 1] << 8;
        }, f.prototype.readUint16BE = f.prototype.readUInt16BE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 2, this.length), this[t3] << 8 | this[t3 + 1];
        }, f.prototype.readUint32LE = f.prototype.readUInt32LE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 4, this.length), (this[t3] | this[t3 + 1] << 8 | this[t3 + 2] << 16) + 16777216 * this[t3 + 3];
        }, f.prototype.readUint32BE = f.prototype.readUInt32BE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 4, this.length), 16777216 * this[t3] + (this[t3 + 1] << 16 | this[t3 + 2] << 8 | this[t3 + 3]);
        }, f.prototype.readBigUInt64LE = Z(function(t3) {
          X(t3 >>>= 0, "offset");
          const e3 = this[t3], r3 = this[t3 + 7];
          void 0 !== e3 && void 0 !== r3 || k(t3, this.length - 8);
          const n2 = e3 + 256 * this[++t3] + 65536 * this[++t3] + this[++t3] * 2 ** 24, i2 = this[++t3] + 256 * this[++t3] + 65536 * this[++t3] + r3 * 2 ** 24;
          return BigInt(n2) + (BigInt(i2) << BigInt(32));
        }), f.prototype.readBigUInt64BE = Z(function(t3) {
          X(t3 >>>= 0, "offset");
          const e3 = this[t3], r3 = this[t3 + 7];
          void 0 !== e3 && void 0 !== r3 || k(t3, this.length - 8);
          const n2 = e3 * 2 ** 24 + 65536 * this[++t3] + 256 * this[++t3] + this[++t3], i2 = this[++t3] * 2 ** 24 + 65536 * this[++t3] + 256 * this[++t3] + r3;
          return (BigInt(n2) << BigInt(32)) + BigInt(i2);
        }), f.prototype.readIntLE = function(t3, e3, r3) {
          t3 >>>= 0, e3 >>>= 0, r3 || L(t3, e3, this.length);
          let n2 = this[t3], i2 = 1, o2 = 0;
          for (; ++o2 < e3 && (i2 *= 256); ) n2 += this[t3 + o2] * i2;
          return i2 *= 128, n2 >= i2 && (n2 -= Math.pow(2, 8 * e3)), n2;
        }, f.prototype.readIntBE = function(t3, e3, r3) {
          t3 >>>= 0, e3 >>>= 0, r3 || L(t3, e3, this.length);
          let n2 = e3, i2 = 1, o2 = this[t3 + --n2];
          for (; n2 > 0 && (i2 *= 256); ) o2 += this[t3 + --n2] * i2;
          return i2 *= 128, o2 >= i2 && (o2 -= Math.pow(2, 8 * e3)), o2;
        }, f.prototype.readInt8 = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 1, this.length), 128 & this[t3] ? -1 * (255 - this[t3] + 1) : this[t3];
        }, f.prototype.readInt16LE = function(t3, e3) {
          t3 >>>= 0, e3 || L(t3, 2, this.length);
          const r3 = this[t3] | this[t3 + 1] << 8;
          return 32768 & r3 ? 4294901760 | r3 : r3;
        }, f.prototype.readInt16BE = function(t3, e3) {
          t3 >>>= 0, e3 || L(t3, 2, this.length);
          const r3 = this[t3 + 1] | this[t3] << 8;
          return 32768 & r3 ? 4294901760 | r3 : r3;
        }, f.prototype.readInt32LE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 4, this.length), this[t3] | this[t3 + 1] << 8 | this[t3 + 2] << 16 | this[t3 + 3] << 24;
        }, f.prototype.readInt32BE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 4, this.length), this[t3] << 24 | this[t3 + 1] << 16 | this[t3 + 2] << 8 | this[t3 + 3];
        }, f.prototype.readBigInt64LE = Z(function(t3) {
          X(t3 >>>= 0, "offset");
          const e3 = this[t3], r3 = this[t3 + 7];
          void 0 !== e3 && void 0 !== r3 || k(t3, this.length - 8);
          const n2 = this[t3 + 4] + 256 * this[t3 + 5] + 65536 * this[t3 + 6] + (r3 << 24);
          return (BigInt(n2) << BigInt(32)) + BigInt(e3 + 256 * this[++t3] + 65536 * this[++t3] + this[++t3] * 2 ** 24);
        }), f.prototype.readBigInt64BE = Z(function(t3) {
          X(t3 >>>= 0, "offset");
          const e3 = this[t3], r3 = this[t3 + 7];
          void 0 !== e3 && void 0 !== r3 || k(t3, this.length - 8);
          const n2 = (e3 << 24) + 65536 * this[++t3] + 256 * this[++t3] + this[++t3];
          return (BigInt(n2) << BigInt(32)) + BigInt(this[++t3] * 2 ** 24 + 65536 * this[++t3] + 256 * this[++t3] + r3);
        }), f.prototype.readFloatLE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 4, this.length), i.read(this, t3, true, 23, 4);
        }, f.prototype.readFloatBE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 4, this.length), i.read(this, t3, false, 23, 4);
        }, f.prototype.readDoubleLE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 8, this.length), i.read(this, t3, true, 52, 8);
        }, f.prototype.readDoubleBE = function(t3, e3) {
          return t3 >>>= 0, e3 || L(t3, 8, this.length), i.read(this, t3, false, 52, 8);
        }, f.prototype.writeUintLE = f.prototype.writeUIntLE = function(t3, e3, r3, n2) {
          if (t3 = +t3, e3 >>>= 0, r3 >>>= 0, !n2) {
            N(this, t3, e3, r3, Math.pow(2, 8 * r3) - 1, 0);
          }
          let i2 = 1, o2 = 0;
          for (this[e3] = 255 & t3; ++o2 < r3 && (i2 *= 256); ) this[e3 + o2] = t3 / i2 & 255;
          return e3 + r3;
        }, f.prototype.writeUintBE = f.prototype.writeUIntBE = function(t3, e3, r3, n2) {
          if (t3 = +t3, e3 >>>= 0, r3 >>>= 0, !n2) {
            N(this, t3, e3, r3, Math.pow(2, 8 * r3) - 1, 0);
          }
          let i2 = r3 - 1, o2 = 1;
          for (this[e3 + i2] = 255 & t3; --i2 >= 0 && (o2 *= 256); ) this[e3 + i2] = t3 / o2 & 255;
          return e3 + r3;
        }, f.prototype.writeUint8 = f.prototype.writeUInt8 = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 1, 255, 0), this[e3] = 255 & t3, e3 + 1;
        }, f.prototype.writeUint16LE = f.prototype.writeUInt16LE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 2, 65535, 0), this[e3] = 255 & t3, this[e3 + 1] = t3 >>> 8, e3 + 2;
        }, f.prototype.writeUint16BE = f.prototype.writeUInt16BE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 2, 65535, 0), this[e3] = t3 >>> 8, this[e3 + 1] = 255 & t3, e3 + 2;
        }, f.prototype.writeUint32LE = f.prototype.writeUInt32LE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 4, 4294967295, 0), this[e3 + 3] = t3 >>> 24, this[e3 + 2] = t3 >>> 16, this[e3 + 1] = t3 >>> 8, this[e3] = 255 & t3, e3 + 4;
        }, f.prototype.writeUint32BE = f.prototype.writeUInt32BE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 4, 4294967295, 0), this[e3] = t3 >>> 24, this[e3 + 1] = t3 >>> 16, this[e3 + 2] = t3 >>> 8, this[e3 + 3] = 255 & t3, e3 + 4;
        }, f.prototype.writeBigUInt64LE = Z(function(t3, e3 = 0) {
          return S(this, t3, e3, BigInt(0), BigInt("0xffffffffffffffff"));
        }), f.prototype.writeBigUInt64BE = Z(function(t3, e3 = 0) {
          return V(this, t3, e3, BigInt(0), BigInt("0xffffffffffffffff"));
        }), f.prototype.writeIntLE = function(t3, e3, r3, n2) {
          if (t3 = +t3, e3 >>>= 0, !n2) {
            const n3 = Math.pow(2, 8 * r3 - 1);
            N(this, t3, e3, r3, n3 - 1, -n3);
          }
          let i2 = 0, o2 = 1, s2 = 0;
          for (this[e3] = 255 & t3; ++i2 < r3 && (o2 *= 256); ) t3 < 0 && 0 === s2 && 0 !== this[e3 + i2 - 1] && (s2 = 1), this[e3 + i2] = (t3 / o2 | 0) - s2 & 255;
          return e3 + r3;
        }, f.prototype.writeIntBE = function(t3, e3, r3, n2) {
          if (t3 = +t3, e3 >>>= 0, !n2) {
            const n3 = Math.pow(2, 8 * r3 - 1);
            N(this, t3, e3, r3, n3 - 1, -n3);
          }
          let i2 = r3 - 1, o2 = 1, s2 = 0;
          for (this[e3 + i2] = 255 & t3; --i2 >= 0 && (o2 *= 256); ) t3 < 0 && 0 === s2 && 0 !== this[e3 + i2 + 1] && (s2 = 1), this[e3 + i2] = (t3 / o2 | 0) - s2 & 255;
          return e3 + r3;
        }, f.prototype.writeInt8 = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 1, 127, -128), t3 < 0 && (t3 = 255 + t3 + 1), this[e3] = 255 & t3, e3 + 1;
        }, f.prototype.writeInt16LE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 2, 32767, -32768), this[e3] = 255 & t3, this[e3 + 1] = t3 >>> 8, e3 + 2;
        }, f.prototype.writeInt16BE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 2, 32767, -32768), this[e3] = t3 >>> 8, this[e3 + 1] = 255 & t3, e3 + 2;
        }, f.prototype.writeInt32LE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 4, 2147483647, -2147483648), this[e3] = 255 & t3, this[e3 + 1] = t3 >>> 8, this[e3 + 2] = t3 >>> 16, this[e3 + 3] = t3 >>> 24, e3 + 4;
        }, f.prototype.writeInt32BE = function(t3, e3, r3) {
          return t3 = +t3, e3 >>>= 0, r3 || N(this, t3, e3, 4, 2147483647, -2147483648), t3 < 0 && (t3 = 4294967295 + t3 + 1), this[e3] = t3 >>> 24, this[e3 + 1] = t3 >>> 16, this[e3 + 2] = t3 >>> 8, this[e3 + 3] = 255 & t3, e3 + 4;
        }, f.prototype.writeBigInt64LE = Z(function(t3, e3 = 0) {
          return S(this, t3, e3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), f.prototype.writeBigInt64BE = Z(function(t3, e3 = 0) {
          return V(this, t3, e3, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
        }), f.prototype.writeFloatLE = function(t3, e3, r3) {
          return C(this, t3, e3, true, r3);
        }, f.prototype.writeFloatBE = function(t3, e3, r3) {
          return C(this, t3, e3, false, r3);
        }, f.prototype.writeDoubleLE = function(t3, e3, r3) {
          return D(this, t3, e3, true, r3);
        }, f.prototype.writeDoubleBE = function(t3, e3, r3) {
          return D(this, t3, e3, false, r3);
        }, f.prototype.copy = function(t3, e3, r3, n2) {
          if (!f.isBuffer(t3)) throw new TypeError("argument should be a Buffer");
          if (r3 || (r3 = 0), n2 || 0 === n2 || (n2 = this.length), e3 >= t3.length && (e3 = t3.length), e3 || (e3 = 0), n2 > 0 && n2 < r3 && (n2 = r3), n2 === r3) return 0;
          if (0 === t3.length || 0 === this.length) return 0;
          if (e3 < 0) throw new RangeError("targetStart out of bounds");
          if (r3 < 0 || r3 >= this.length) throw new RangeError("Index out of range");
          if (n2 < 0) throw new RangeError("sourceEnd out of bounds");
          n2 > this.length && (n2 = this.length), t3.length - e3 < n2 - r3 && (n2 = t3.length - e3 + r3);
          const i2 = n2 - r3;
          return this === t3 && "function" == typeof Uint8Array.prototype.copyWithin ? this.copyWithin(e3, r3, n2) : Uint8Array.prototype.set.call(t3, this.subarray(r3, n2), e3), i2;
        }, f.prototype.fill = function(t3, e3, r3, n2) {
          if ("string" == typeof t3) {
            if ("string" == typeof e3 ? (n2 = e3, e3 = 0, r3 = this.length) : "string" == typeof r3 && (n2 = r3, r3 = this.length), void 0 !== n2 && "string" != typeof n2) throw new TypeError("encoding must be a string");
            if ("string" == typeof n2 && !f.isEncoding(n2)) throw new TypeError("Unknown encoding: " + n2);
            if (1 === t3.length) {
              const e4 = t3.charCodeAt(0);
              ("utf8" === n2 && e4 < 128 || "latin1" === n2) && (t3 = e4);
            }
          } else "number" == typeof t3 ? t3 &= 255 : "boolean" == typeof t3 && (t3 = Number(t3));
          if (e3 < 0 || this.length < e3 || this.length < r3) throw new RangeError("Out of range index");
          if (r3 <= e3) return this;
          let i2;
          if (e3 >>>= 0, r3 = void 0 === r3 ? this.length : r3 >>> 0, t3 || (t3 = 0), "number" == typeof t3) for (i2 = e3; i2 < r3; ++i2) this[i2] = t3;
          else {
            const o2 = f.isBuffer(t3) ? t3 : f.from(t3, n2), s2 = o2.length;
            if (0 === s2) throw new TypeError('The value "' + t3 + '" is invalid for argument "value"');
            for (i2 = 0; i2 < r3 - e3; ++i2) this[i2 + e3] = o2[i2 % s2];
          }
          return this;
        };
        const j = {};
        function z(t3, e3, r3) {
          j[t3] = class extends r3 {
            constructor() {
              super(), Object.defineProperty(this, "message", { value: e3.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${t3}]`, this.stack, delete this.name;
            }
            get code() {
              return t3;
            }
            set code(t4) {
              Object.defineProperty(this, "code", { configurable: true, enumerable: true, value: t4, writable: true });
            }
            toString() {
              return `${this.name} [${t3}]: ${this.message}`;
            }
          };
        }
        function F(t3) {
          let e3 = "", r3 = t3.length;
          const n2 = "-" === t3[0] ? 1 : 0;
          for (; r3 >= n2 + 4; r3 -= 3) e3 = `_${t3.slice(r3 - 3, r3)}${e3}`;
          return `${t3.slice(0, r3)}${e3}`;
        }
        function P(t3, e3, r3, n2, i2, o2) {
          if (t3 > r3 || t3 < e3) {
            const n3 = "bigint" == typeof e3 ? "n" : "";
            let i3;
            throw i3 = o2 > 3 ? 0 === e3 || e3 === BigInt(0) ? `>= 0${n3} and < 2${n3} ** ${8 * (o2 + 1)}${n3}` : `>= -(2${n3} ** ${8 * (o2 + 1) - 1}${n3}) and < 2 ** ${8 * (o2 + 1) - 1}${n3}` : `>= ${e3}${n3} and <= ${r3}${n3}`, new j.ERR_OUT_OF_RANGE("value", i3, t3);
          }
          !function(t4, e4, r4) {
            X(e4, "offset"), void 0 !== t4[e4] && void 0 !== t4[e4 + r4] || k(e4, t4.length - (r4 + 1));
          }(n2, i2, o2);
        }
        function X(t3, e3) {
          if ("number" != typeof t3) throw new j.ERR_INVALID_ARG_TYPE(e3, "number", t3);
        }
        function k(t3, e3, r3) {
          if (Math.floor(t3) !== t3) throw X(t3, r3), new j.ERR_OUT_OF_RANGE(r3 || "offset", "an integer", t3);
          if (e3 < 0) throw new j.ERR_BUFFER_OUT_OF_BOUNDS();
          throw new j.ERR_OUT_OF_RANGE(r3 || "offset", `>= ${r3 ? 1 : 0} and <= ${e3}`, t3);
        }
        z("ERR_BUFFER_OUT_OF_BOUNDS", function(t3) {
          return t3 ? `${t3} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
        }, RangeError), z("ERR_INVALID_ARG_TYPE", function(t3, e3) {
          return `The "${t3}" argument must be of type number. Received type ${typeof e3}`;
        }, TypeError), z("ERR_OUT_OF_RANGE", function(t3, e3, r3) {
          let n2 = `The value of "${t3}" is out of range.`, i2 = r3;
          return Number.isInteger(r3) && Math.abs(r3) > 2 ** 32 ? i2 = F(String(r3)) : "bigint" == typeof r3 && (i2 = String(r3), (r3 > BigInt(2) ** BigInt(32) || r3 < -(BigInt(2) ** BigInt(32))) && (i2 = F(i2)), i2 += "n"), n2 += ` It must be ${e3}. Received ${i2}`, n2;
        }, RangeError);
        const q = /[^+/0-9A-Za-z-_]/g;
        function G(t3, e3) {
          let r3;
          e3 = e3 || 1 / 0;
          const n2 = t3.length;
          let i2 = null;
          const o2 = [];
          for (let s2 = 0; s2 < n2; ++s2) {
            if (r3 = t3.charCodeAt(s2), r3 > 55295 && r3 < 57344) {
              if (!i2) {
                if (r3 > 56319) {
                  (e3 -= 3) > -1 && o2.push(239, 191, 189);
                  continue;
                }
                if (s2 + 1 === n2) {
                  (e3 -= 3) > -1 && o2.push(239, 191, 189);
                  continue;
                }
                i2 = r3;
                continue;
              }
              if (r3 < 56320) {
                (e3 -= 3) > -1 && o2.push(239, 191, 189), i2 = r3;
                continue;
              }
              r3 = 65536 + (i2 - 55296 << 10 | r3 - 56320);
            } else i2 && (e3 -= 3) > -1 && o2.push(239, 191, 189);
            if (i2 = null, r3 < 128) {
              if ((e3 -= 1) < 0) break;
              o2.push(r3);
            } else if (r3 < 2048) {
              if ((e3 -= 2) < 0) break;
              o2.push(r3 >> 6 | 192, 63 & r3 | 128);
            } else if (r3 < 65536) {
              if ((e3 -= 3) < 0) break;
              o2.push(r3 >> 12 | 224, r3 >> 6 & 63 | 128, 63 & r3 | 128);
            } else {
              if (!(r3 < 1114112)) throw new Error("Invalid code point");
              if ((e3 -= 4) < 0) break;
              o2.push(r3 >> 18 | 240, r3 >> 12 & 63 | 128, r3 >> 6 & 63 | 128, 63 & r3 | 128);
            }
          }
          return o2;
        }
        function Y(t3) {
          return n.toByteArray(function(t4) {
            if ((t4 = (t4 = t4.split("=")[0]).trim().replace(q, "")).length < 2) return "";
            for (; t4.length % 4 != 0; ) t4 += "=";
            return t4;
          }(t3));
        }
        function J(t3, e3, r3, n2) {
          let i2;
          for (i2 = 0; i2 < n2 && !(i2 + r3 >= e3.length || i2 >= t3.length); ++i2) e3[i2 + r3] = t3[i2];
          return i2;
        }
        function W(t3, e3) {
          return t3 instanceof e3 || null != t3 && null != t3.constructor && null != t3.constructor.name && t3.constructor.name === e3.name;
        }
        function H(t3) {
          return t3 != t3;
        }
        const Q = function() {
          const t3 = "0123456789abcdef", e3 = new Array(256);
          for (let r3 = 0; r3 < 16; ++r3) {
            const n2 = 16 * r3;
            for (let i2 = 0; i2 < 16; ++i2) e3[n2 + i2] = t3[r3] + t3[i2];
          }
          return e3;
        }();
        function Z(t3) {
          return "undefined" == typeof BigInt ? K : t3;
        }
        function K() {
          throw new Error("BigInt not supported");
        }
      }, 251: (t2, e2) => {
        e2.read = function(t3, e3, r2, n, i) {
          var o, s, u = 8 * i - n - 1, f = (1 << u) - 1, a = f >> 1, h = -7, c = r2 ? i - 1 : 0, l = r2 ? -1 : 1, p = t3[e3 + c];
          for (c += l, o = p & (1 << -h) - 1, p >>= -h, h += u; h > 0; o = 256 * o + t3[e3 + c], c += l, h -= 8) ;
          for (s = o & (1 << -h) - 1, o >>= -h, h += n; h > 0; s = 256 * s + t3[e3 + c], c += l, h -= 8) ;
          if (0 === o) o = 1 - a;
          else {
            if (o === f) return s ? NaN : 1 / 0 * (p ? -1 : 1);
            s += Math.pow(2, n), o -= a;
          }
          return (p ? -1 : 1) * s * Math.pow(2, o - n);
        }, e2.write = function(t3, e3, r2, n, i, o) {
          var s, u, f, a = 8 * o - i - 1, h = (1 << a) - 1, c = h >> 1, l = 23 === i ? Math.pow(2, -24) - Math.pow(2, -77) : 0, p = n ? 0 : o - 1, d = n ? 1 : -1, g = e3 < 0 || 0 === e3 && 1 / e3 < 0 ? 1 : 0;
          for (e3 = Math.abs(e3), isNaN(e3) || e3 === 1 / 0 ? (u = isNaN(e3) ? 1 : 0, s = h) : (s = Math.floor(Math.log(e3) / Math.LN2), e3 * (f = Math.pow(2, -s)) < 1 && (s--, f *= 2), (e3 += s + c >= 1 ? l / f : l * Math.pow(2, 1 - c)) * f >= 2 && (s++, f /= 2), s + c >= h ? (u = 0, s = h) : s + c >= 1 ? (u = (e3 * f - 1) * Math.pow(2, i), s += c) : (u = e3 * Math.pow(2, c - 1) * Math.pow(2, i), s = 0)); i >= 8; t3[r2 + p] = 255 & u, p += d, u /= 256, i -= 8) ;
          for (s = s << i | u, a += i; a > 0; t3[r2 + p] = 255 & s, p += d, s /= 256, a -= 8) ;
          t3[r2 + p - d] |= 128 * g;
        };
      } }, e = {};
      function r(n) {
        var i = e[n];
        if (void 0 !== i) return i.exports;
        var o = e[n] = { exports: {} };
        return t[n](o, o.exports, r), o.exports;
      }
      return r.d = (t2, e2) => {
        for (var n in e2) r.o(e2, n) && !r.o(t2, n) && Object.defineProperty(t2, n, { enumerable: true, get: e2[n] });
      }, r.g = function() {
        if ("object" == typeof globalThis) return globalThis;
        try {
          return this || new Function("return this")();
        } catch (t2) {
          if ("object" == typeof window) return window;
        }
      }(), r.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), r.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      }, r(281);
    })());
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/generated/curr_generated.js
var require_curr_generated = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/generated/curr_generated.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var XDR = _interopRequireWildcard(require_xdr());
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n["default"] = e, t && t.set(e, n), n;
    }
    var types = XDR.config(function(xdr) {
      var SCSYMBOL_LIMIT = 32;
      var SC_SPEC_DOC_LIMIT = 1024;
      xdr.typedef("Value", xdr.varOpaque());
      xdr.struct("ScpBallot", [["counter", xdr.lookup("Uint32")], ["value", xdr.lookup("Value")]]);
      xdr["enum"]("ScpStatementType", {
        scpStPrepare: 0,
        scpStConfirm: 1,
        scpStExternalize: 2,
        scpStNominate: 3
      });
      xdr.struct("ScpNomination", [["quorumSetHash", xdr.lookup("Hash")], ["votes", xdr.varArray(xdr.lookup("Value"), 2147483647)], ["accepted", xdr.varArray(xdr.lookup("Value"), 2147483647)]]);
      xdr.struct("ScpStatementPrepare", [["quorumSetHash", xdr.lookup("Hash")], ["ballot", xdr.lookup("ScpBallot")], ["prepared", xdr.option(xdr.lookup("ScpBallot"))], ["preparedPrime", xdr.option(xdr.lookup("ScpBallot"))], ["nC", xdr.lookup("Uint32")], ["nH", xdr.lookup("Uint32")]]);
      xdr.struct("ScpStatementConfirm", [["ballot", xdr.lookup("ScpBallot")], ["nPrepared", xdr.lookup("Uint32")], ["nCommit", xdr.lookup("Uint32")], ["nH", xdr.lookup("Uint32")], ["quorumSetHash", xdr.lookup("Hash")]]);
      xdr.struct("ScpStatementExternalize", [["commit", xdr.lookup("ScpBallot")], ["nH", xdr.lookup("Uint32")], ["commitQuorumSetHash", xdr.lookup("Hash")]]);
      xdr.union("ScpStatementPledges", {
        switchOn: xdr.lookup("ScpStatementType"),
        switchName: "type",
        switches: [["scpStPrepare", "prepare"], ["scpStConfirm", "confirm"], ["scpStExternalize", "externalize"], ["scpStNominate", "nominate"]],
        arms: {
          prepare: xdr.lookup("ScpStatementPrepare"),
          confirm: xdr.lookup("ScpStatementConfirm"),
          externalize: xdr.lookup("ScpStatementExternalize"),
          nominate: xdr.lookup("ScpNomination")
        }
      });
      xdr.struct("ScpStatement", [["nodeId", xdr.lookup("NodeId")], ["slotIndex", xdr.lookup("Uint64")], ["pledges", xdr.lookup("ScpStatementPledges")]]);
      xdr.struct("ScpEnvelope", [["statement", xdr.lookup("ScpStatement")], ["signature", xdr.lookup("Signature")]]);
      xdr.struct("ScpQuorumSet", [["threshold", xdr.lookup("Uint32")], ["validators", xdr.varArray(xdr.lookup("NodeId"), 2147483647)], ["innerSets", xdr.varArray(xdr.lookup("ScpQuorumSet"), 2147483647)]]);
      xdr.typedef("Thresholds", xdr.opaque(4));
      xdr.typedef("String32", xdr.string(32));
      xdr.typedef("String64", xdr.string(64));
      xdr.typedef("SequenceNumber", xdr.lookup("Int64"));
      xdr.typedef("DataValue", xdr.varOpaque(64));
      xdr.typedef("PoolId", xdr.lookup("Hash"));
      xdr.typedef("AssetCode4", xdr.opaque(4));
      xdr.typedef("AssetCode12", xdr.opaque(12));
      xdr["enum"]("AssetType", {
        assetTypeNative: 0,
        assetTypeCreditAlphanum4: 1,
        assetTypeCreditAlphanum12: 2,
        assetTypePoolShare: 3
      });
      xdr.union("AssetCode", {
        switchOn: xdr.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeCreditAlphanum4", "assetCode4"], ["assetTypeCreditAlphanum12", "assetCode12"]],
        arms: {
          assetCode4: xdr.lookup("AssetCode4"),
          assetCode12: xdr.lookup("AssetCode12")
        }
      });
      xdr.struct("AlphaNum4", [["assetCode", xdr.lookup("AssetCode4")], ["issuer", xdr.lookup("AccountId")]]);
      xdr.struct("AlphaNum12", [["assetCode", xdr.lookup("AssetCode12")], ["issuer", xdr.lookup("AccountId")]]);
      xdr.union("Asset", {
        switchOn: xdr.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeNative", xdr["void"]()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"]],
        arms: {
          alphaNum4: xdr.lookup("AlphaNum4"),
          alphaNum12: xdr.lookup("AlphaNum12")
        }
      });
      xdr.struct("Price", [["n", xdr.lookup("Int32")], ["d", xdr.lookup("Int32")]]);
      xdr.struct("Liabilities", [["buying", xdr.lookup("Int64")], ["selling", xdr.lookup("Int64")]]);
      xdr["enum"]("ThresholdIndices", {
        thresholdMasterWeight: 0,
        thresholdLow: 1,
        thresholdMed: 2,
        thresholdHigh: 3
      });
      xdr["enum"]("LedgerEntryType", {
        account: 0,
        trustline: 1,
        offer: 2,
        data: 3,
        claimableBalance: 4,
        liquidityPool: 5,
        contractData: 6,
        contractCode: 7,
        configSetting: 8,
        ttl: 9
      });
      xdr.struct("Signer", [["key", xdr.lookup("SignerKey")], ["weight", xdr.lookup("Uint32")]]);
      xdr["enum"]("AccountFlags", {
        authRequiredFlag: 1,
        authRevocableFlag: 2,
        authImmutableFlag: 4,
        authClawbackEnabledFlag: 8
      });
      xdr["const"]("MASK_ACCOUNT_FLAGS", 7);
      xdr["const"]("MASK_ACCOUNT_FLAGS_V17", 15);
      xdr["const"]("MAX_SIGNERS", 20);
      xdr.typedef("SponsorshipDescriptor", xdr.option(xdr.lookup("AccountId")));
      xdr.struct("AccountEntryExtensionV3", [["ext", xdr.lookup("ExtensionPoint")], ["seqLedger", xdr.lookup("Uint32")], ["seqTime", xdr.lookup("TimePoint")]]);
      xdr.union("AccountEntryExtensionV2Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [3, "v3"]],
        arms: {
          v3: xdr.lookup("AccountEntryExtensionV3")
        }
      });
      xdr.struct("AccountEntryExtensionV2", [["numSponsored", xdr.lookup("Uint32")], ["numSponsoring", xdr.lookup("Uint32")], ["signerSponsoringIDs", xdr.varArray(xdr.lookup("SponsorshipDescriptor"), xdr.lookup("MAX_SIGNERS"))], ["ext", xdr.lookup("AccountEntryExtensionV2Ext")]]);
      xdr.union("AccountEntryExtensionV1Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [2, "v2"]],
        arms: {
          v2: xdr.lookup("AccountEntryExtensionV2")
        }
      });
      xdr.struct("AccountEntryExtensionV1", [["liabilities", xdr.lookup("Liabilities")], ["ext", xdr.lookup("AccountEntryExtensionV1Ext")]]);
      xdr.union("AccountEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [1, "v1"]],
        arms: {
          v1: xdr.lookup("AccountEntryExtensionV1")
        }
      });
      xdr.struct("AccountEntry", [["accountId", xdr.lookup("AccountId")], ["balance", xdr.lookup("Int64")], ["seqNum", xdr.lookup("SequenceNumber")], ["numSubEntries", xdr.lookup("Uint32")], ["inflationDest", xdr.option(xdr.lookup("AccountId"))], ["flags", xdr.lookup("Uint32")], ["homeDomain", xdr.lookup("String32")], ["thresholds", xdr.lookup("Thresholds")], ["signers", xdr.varArray(xdr.lookup("Signer"), xdr.lookup("MAX_SIGNERS"))], ["ext", xdr.lookup("AccountEntryExt")]]);
      xdr["enum"]("TrustLineFlags", {
        authorizedFlag: 1,
        authorizedToMaintainLiabilitiesFlag: 2,
        trustlineClawbackEnabledFlag: 4
      });
      xdr["const"]("MASK_TRUSTLINE_FLAGS", 1);
      xdr["const"]("MASK_TRUSTLINE_FLAGS_V13", 3);
      xdr["const"]("MASK_TRUSTLINE_FLAGS_V17", 7);
      xdr["enum"]("LiquidityPoolType", {
        liquidityPoolConstantProduct: 0
      });
      xdr.union("TrustLineAsset", {
        switchOn: xdr.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeNative", xdr["void"]()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPoolId"]],
        arms: {
          alphaNum4: xdr.lookup("AlphaNum4"),
          alphaNum12: xdr.lookup("AlphaNum12"),
          liquidityPoolId: xdr.lookup("PoolId")
        }
      });
      xdr.union("TrustLineEntryExtensionV2Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr.struct("TrustLineEntryExtensionV2", [["liquidityPoolUseCount", xdr.lookup("Int32")], ["ext", xdr.lookup("TrustLineEntryExtensionV2Ext")]]);
      xdr.union("TrustLineEntryV1Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [2, "v2"]],
        arms: {
          v2: xdr.lookup("TrustLineEntryExtensionV2")
        }
      });
      xdr.struct("TrustLineEntryV1", [["liabilities", xdr.lookup("Liabilities")], ["ext", xdr.lookup("TrustLineEntryV1Ext")]]);
      xdr.union("TrustLineEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [1, "v1"]],
        arms: {
          v1: xdr.lookup("TrustLineEntryV1")
        }
      });
      xdr.struct("TrustLineEntry", [["accountId", xdr.lookup("AccountId")], ["asset", xdr.lookup("TrustLineAsset")], ["balance", xdr.lookup("Int64")], ["limit", xdr.lookup("Int64")], ["flags", xdr.lookup("Uint32")], ["ext", xdr.lookup("TrustLineEntryExt")]]);
      xdr["enum"]("OfferEntryFlags", {
        passiveFlag: 1
      });
      xdr["const"]("MASK_OFFERENTRY_FLAGS", 1);
      xdr.union("OfferEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr.struct("OfferEntry", [["sellerId", xdr.lookup("AccountId")], ["offerId", xdr.lookup("Int64")], ["selling", xdr.lookup("Asset")], ["buying", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")], ["price", xdr.lookup("Price")], ["flags", xdr.lookup("Uint32")], ["ext", xdr.lookup("OfferEntryExt")]]);
      xdr.union("DataEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr.struct("DataEntry", [["accountId", xdr.lookup("AccountId")], ["dataName", xdr.lookup("String64")], ["dataValue", xdr.lookup("DataValue")], ["ext", xdr.lookup("DataEntryExt")]]);
      xdr["enum"]("ClaimPredicateType", {
        claimPredicateUnconditional: 0,
        claimPredicateAnd: 1,
        claimPredicateOr: 2,
        claimPredicateNot: 3,
        claimPredicateBeforeAbsoluteTime: 4,
        claimPredicateBeforeRelativeTime: 5
      });
      xdr.union("ClaimPredicate", {
        switchOn: xdr.lookup("ClaimPredicateType"),
        switchName: "type",
        switches: [["claimPredicateUnconditional", xdr["void"]()], ["claimPredicateAnd", "andPredicates"], ["claimPredicateOr", "orPredicates"], ["claimPredicateNot", "notPredicate"], ["claimPredicateBeforeAbsoluteTime", "absBefore"], ["claimPredicateBeforeRelativeTime", "relBefore"]],
        arms: {
          andPredicates: xdr.varArray(xdr.lookup("ClaimPredicate"), 2),
          orPredicates: xdr.varArray(xdr.lookup("ClaimPredicate"), 2),
          notPredicate: xdr.option(xdr.lookup("ClaimPredicate")),
          absBefore: xdr.lookup("Int64"),
          relBefore: xdr.lookup("Int64")
        }
      });
      xdr["enum"]("ClaimantType", {
        claimantTypeV0: 0
      });
      xdr.struct("ClaimantV0", [["destination", xdr.lookup("AccountId")], ["predicate", xdr.lookup("ClaimPredicate")]]);
      xdr.union("Claimant", {
        switchOn: xdr.lookup("ClaimantType"),
        switchName: "type",
        switches: [["claimantTypeV0", "v0"]],
        arms: {
          v0: xdr.lookup("ClaimantV0")
        }
      });
      xdr["enum"]("ClaimableBalanceIdType", {
        claimableBalanceIdTypeV0: 0
      });
      xdr.union("ClaimableBalanceId", {
        switchOn: xdr.lookup("ClaimableBalanceIdType"),
        switchName: "type",
        switches: [["claimableBalanceIdTypeV0", "v0"]],
        arms: {
          v0: xdr.lookup("Hash")
        }
      });
      xdr["enum"]("ClaimableBalanceFlags", {
        claimableBalanceClawbackEnabledFlag: 1
      });
      xdr["const"]("MASK_CLAIMABLE_BALANCE_FLAGS", 1);
      xdr.union("ClaimableBalanceEntryExtensionV1Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr.struct("ClaimableBalanceEntryExtensionV1", [["ext", xdr.lookup("ClaimableBalanceEntryExtensionV1Ext")], ["flags", xdr.lookup("Uint32")]]);
      xdr.union("ClaimableBalanceEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [1, "v1"]],
        arms: {
          v1: xdr.lookup("ClaimableBalanceEntryExtensionV1")
        }
      });
      xdr.struct("ClaimableBalanceEntry", [["balanceId", xdr.lookup("ClaimableBalanceId")], ["claimants", xdr.varArray(xdr.lookup("Claimant"), 10)], ["asset", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")], ["ext", xdr.lookup("ClaimableBalanceEntryExt")]]);
      xdr.struct("LiquidityPoolConstantProductParameters", [["assetA", xdr.lookup("Asset")], ["assetB", xdr.lookup("Asset")], ["fee", xdr.lookup("Int32")]]);
      xdr.struct("LiquidityPoolEntryConstantProduct", [["params", xdr.lookup("LiquidityPoolConstantProductParameters")], ["reserveA", xdr.lookup("Int64")], ["reserveB", xdr.lookup("Int64")], ["totalPoolShares", xdr.lookup("Int64")], ["poolSharesTrustLineCount", xdr.lookup("Int64")]]);
      xdr.union("LiquidityPoolEntryBody", {
        switchOn: xdr.lookup("LiquidityPoolType"),
        switchName: "type",
        switches: [["liquidityPoolConstantProduct", "constantProduct"]],
        arms: {
          constantProduct: xdr.lookup("LiquidityPoolEntryConstantProduct")
        }
      });
      xdr.struct("LiquidityPoolEntry", [["liquidityPoolId", xdr.lookup("PoolId")], ["body", xdr.lookup("LiquidityPoolEntryBody")]]);
      xdr["enum"]("ContractDataDurability", {
        temporary: 0,
        persistent: 1
      });
      xdr.struct("ContractDataEntry", [["ext", xdr.lookup("ExtensionPoint")], ["contract", xdr.lookup("ScAddress")], ["key", xdr.lookup("ScVal")], ["durability", xdr.lookup("ContractDataDurability")], ["val", xdr.lookup("ScVal")]]);
      xdr.struct("ContractCodeCostInputs", [["ext", xdr.lookup("ExtensionPoint")], ["nInstructions", xdr.lookup("Uint32")], ["nFunctions", xdr.lookup("Uint32")], ["nGlobals", xdr.lookup("Uint32")], ["nTableEntries", xdr.lookup("Uint32")], ["nTypes", xdr.lookup("Uint32")], ["nDataSegments", xdr.lookup("Uint32")], ["nElemSegments", xdr.lookup("Uint32")], ["nImports", xdr.lookup("Uint32")], ["nExports", xdr.lookup("Uint32")], ["nDataSegmentBytes", xdr.lookup("Uint32")]]);
      xdr.struct("ContractCodeEntryV1", [["ext", xdr.lookup("ExtensionPoint")], ["costInputs", xdr.lookup("ContractCodeCostInputs")]]);
      xdr.union("ContractCodeEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [1, "v1"]],
        arms: {
          v1: xdr.lookup("ContractCodeEntryV1")
        }
      });
      xdr.struct("ContractCodeEntry", [["ext", xdr.lookup("ContractCodeEntryExt")], ["hash", xdr.lookup("Hash")], ["code", xdr.varOpaque()]]);
      xdr.struct("TtlEntry", [["keyHash", xdr.lookup("Hash")], ["liveUntilLedgerSeq", xdr.lookup("Uint32")]]);
      xdr.union("LedgerEntryExtensionV1Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr.struct("LedgerEntryExtensionV1", [["sponsoringId", xdr.lookup("SponsorshipDescriptor")], ["ext", xdr.lookup("LedgerEntryExtensionV1Ext")]]);
      xdr.union("LedgerEntryData", {
        switchOn: xdr.lookup("LedgerEntryType"),
        switchName: "type",
        switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]],
        arms: {
          account: xdr.lookup("AccountEntry"),
          trustLine: xdr.lookup("TrustLineEntry"),
          offer: xdr.lookup("OfferEntry"),
          data: xdr.lookup("DataEntry"),
          claimableBalance: xdr.lookup("ClaimableBalanceEntry"),
          liquidityPool: xdr.lookup("LiquidityPoolEntry"),
          contractData: xdr.lookup("ContractDataEntry"),
          contractCode: xdr.lookup("ContractCodeEntry"),
          configSetting: xdr.lookup("ConfigSettingEntry"),
          ttl: xdr.lookup("TtlEntry")
        }
      });
      xdr.union("LedgerEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [1, "v1"]],
        arms: {
          v1: xdr.lookup("LedgerEntryExtensionV1")
        }
      });
      xdr.struct("LedgerEntry", [["lastModifiedLedgerSeq", xdr.lookup("Uint32")], ["data", xdr.lookup("LedgerEntryData")], ["ext", xdr.lookup("LedgerEntryExt")]]);
      xdr.struct("LedgerKeyAccount", [["accountId", xdr.lookup("AccountId")]]);
      xdr.struct("LedgerKeyTrustLine", [["accountId", xdr.lookup("AccountId")], ["asset", xdr.lookup("TrustLineAsset")]]);
      xdr.struct("LedgerKeyOffer", [["sellerId", xdr.lookup("AccountId")], ["offerId", xdr.lookup("Int64")]]);
      xdr.struct("LedgerKeyData", [["accountId", xdr.lookup("AccountId")], ["dataName", xdr.lookup("String64")]]);
      xdr.struct("LedgerKeyClaimableBalance", [["balanceId", xdr.lookup("ClaimableBalanceId")]]);
      xdr.struct("LedgerKeyLiquidityPool", [["liquidityPoolId", xdr.lookup("PoolId")]]);
      xdr.struct("LedgerKeyContractData", [["contract", xdr.lookup("ScAddress")], ["key", xdr.lookup("ScVal")], ["durability", xdr.lookup("ContractDataDurability")]]);
      xdr.struct("LedgerKeyContractCode", [["hash", xdr.lookup("Hash")]]);
      xdr.struct("LedgerKeyConfigSetting", [["configSettingId", xdr.lookup("ConfigSettingId")]]);
      xdr.struct("LedgerKeyTtl", [["keyHash", xdr.lookup("Hash")]]);
      xdr.union("LedgerKey", {
        switchOn: xdr.lookup("LedgerEntryType"),
        switchName: "type",
        switches: [["account", "account"], ["trustline", "trustLine"], ["offer", "offer"], ["data", "data"], ["claimableBalance", "claimableBalance"], ["liquidityPool", "liquidityPool"], ["contractData", "contractData"], ["contractCode", "contractCode"], ["configSetting", "configSetting"], ["ttl", "ttl"]],
        arms: {
          account: xdr.lookup("LedgerKeyAccount"),
          trustLine: xdr.lookup("LedgerKeyTrustLine"),
          offer: xdr.lookup("LedgerKeyOffer"),
          data: xdr.lookup("LedgerKeyData"),
          claimableBalance: xdr.lookup("LedgerKeyClaimableBalance"),
          liquidityPool: xdr.lookup("LedgerKeyLiquidityPool"),
          contractData: xdr.lookup("LedgerKeyContractData"),
          contractCode: xdr.lookup("LedgerKeyContractCode"),
          configSetting: xdr.lookup("LedgerKeyConfigSetting"),
          ttl: xdr.lookup("LedgerKeyTtl")
        }
      });
      xdr["enum"]("EnvelopeType", {
        envelopeTypeTxV0: 0,
        envelopeTypeScp: 1,
        envelopeTypeTx: 2,
        envelopeTypeAuth: 3,
        envelopeTypeScpvalue: 4,
        envelopeTypeTxFeeBump: 5,
        envelopeTypeOpId: 6,
        envelopeTypePoolRevokeOpId: 7,
        envelopeTypeContractId: 8,
        envelopeTypeSorobanAuthorization: 9
      });
      xdr["enum"]("BucketListType", {
        live: 0,
        hotArchive: 1,
        coldArchive: 2
      });
      xdr["enum"]("BucketEntryType", {
        metaentry: -1,
        liveentry: 0,
        deadentry: 1,
        initentry: 2
      });
      xdr["enum"]("HotArchiveBucketEntryType", {
        hotArchiveMetaentry: -1,
        hotArchiveArchived: 0,
        hotArchiveLive: 1,
        hotArchiveDeleted: 2
      });
      xdr["enum"]("ColdArchiveBucketEntryType", {
        coldArchiveMetaentry: -1,
        coldArchiveArchivedLeaf: 0,
        coldArchiveDeletedLeaf: 1,
        coldArchiveBoundaryLeaf: 2,
        coldArchiveHash: 3
      });
      xdr.union("BucketMetadataExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [1, "bucketListType"]],
        arms: {
          bucketListType: xdr.lookup("BucketListType")
        }
      });
      xdr.struct("BucketMetadata", [["ledgerVersion", xdr.lookup("Uint32")], ["ext", xdr.lookup("BucketMetadataExt")]]);
      xdr.union("BucketEntry", {
        switchOn: xdr.lookup("BucketEntryType"),
        switchName: "type",
        switches: [["liveentry", "liveEntry"], ["initentry", "liveEntry"], ["deadentry", "deadEntry"], ["metaentry", "metaEntry"]],
        arms: {
          liveEntry: xdr.lookup("LedgerEntry"),
          deadEntry: xdr.lookup("LedgerKey"),
          metaEntry: xdr.lookup("BucketMetadata")
        }
      });
      xdr.union("HotArchiveBucketEntry", {
        switchOn: xdr.lookup("HotArchiveBucketEntryType"),
        switchName: "type",
        switches: [["hotArchiveArchived", "archivedEntry"], ["hotArchiveLive", "key"], ["hotArchiveDeleted", "key"], ["hotArchiveMetaentry", "metaEntry"]],
        arms: {
          archivedEntry: xdr.lookup("LedgerEntry"),
          key: xdr.lookup("LedgerKey"),
          metaEntry: xdr.lookup("BucketMetadata")
        }
      });
      xdr.struct("ColdArchiveArchivedLeaf", [["index", xdr.lookup("Uint32")], ["archivedEntry", xdr.lookup("LedgerEntry")]]);
      xdr.struct("ColdArchiveDeletedLeaf", [["index", xdr.lookup("Uint32")], ["deletedKey", xdr.lookup("LedgerKey")]]);
      xdr.struct("ColdArchiveBoundaryLeaf", [["index", xdr.lookup("Uint32")], ["isLowerBound", xdr.bool()]]);
      xdr.struct("ColdArchiveHashEntry", [["index", xdr.lookup("Uint32")], ["level", xdr.lookup("Uint32")], ["hash", xdr.lookup("Hash")]]);
      xdr.union("ColdArchiveBucketEntry", {
        switchOn: xdr.lookup("ColdArchiveBucketEntryType"),
        switchName: "type",
        switches: [["coldArchiveMetaentry", "metaEntry"], ["coldArchiveArchivedLeaf", "archivedLeaf"], ["coldArchiveDeletedLeaf", "deletedLeaf"], ["coldArchiveBoundaryLeaf", "boundaryLeaf"], ["coldArchiveHash", "hashEntry"]],
        arms: {
          metaEntry: xdr.lookup("BucketMetadata"),
          archivedLeaf: xdr.lookup("ColdArchiveArchivedLeaf"),
          deletedLeaf: xdr.lookup("ColdArchiveDeletedLeaf"),
          boundaryLeaf: xdr.lookup("ColdArchiveBoundaryLeaf"),
          hashEntry: xdr.lookup("ColdArchiveHashEntry")
        }
      });
      xdr.typedef("UpgradeType", xdr.varOpaque(128));
      xdr["enum"]("StellarValueType", {
        stellarValueBasic: 0,
        stellarValueSigned: 1
      });
      xdr.struct("LedgerCloseValueSignature", [["nodeId", xdr.lookup("NodeId")], ["signature", xdr.lookup("Signature")]]);
      xdr.union("StellarValueExt", {
        switchOn: xdr.lookup("StellarValueType"),
        switchName: "v",
        switches: [["stellarValueBasic", xdr["void"]()], ["stellarValueSigned", "lcValueSignature"]],
        arms: {
          lcValueSignature: xdr.lookup("LedgerCloseValueSignature")
        }
      });
      xdr.struct("StellarValue", [["txSetHash", xdr.lookup("Hash")], ["closeTime", xdr.lookup("TimePoint")], ["upgrades", xdr.varArray(xdr.lookup("UpgradeType"), 6)], ["ext", xdr.lookup("StellarValueExt")]]);
      xdr["const"]("MASK_LEDGER_HEADER_FLAGS", 7);
      xdr["enum"]("LedgerHeaderFlags", {
        disableLiquidityPoolTradingFlag: 1,
        disableLiquidityPoolDepositFlag: 2,
        disableLiquidityPoolWithdrawalFlag: 4
      });
      xdr.union("LedgerHeaderExtensionV1Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr.struct("LedgerHeaderExtensionV1", [["flags", xdr.lookup("Uint32")], ["ext", xdr.lookup("LedgerHeaderExtensionV1Ext")]]);
      xdr.union("LedgerHeaderExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [1, "v1"]],
        arms: {
          v1: xdr.lookup("LedgerHeaderExtensionV1")
        }
      });
      xdr.struct("LedgerHeader", [["ledgerVersion", xdr.lookup("Uint32")], ["previousLedgerHash", xdr.lookup("Hash")], ["scpValue", xdr.lookup("StellarValue")], ["txSetResultHash", xdr.lookup("Hash")], ["bucketListHash", xdr.lookup("Hash")], ["ledgerSeq", xdr.lookup("Uint32")], ["totalCoins", xdr.lookup("Int64")], ["feePool", xdr.lookup("Int64")], ["inflationSeq", xdr.lookup("Uint32")], ["idPool", xdr.lookup("Uint64")], ["baseFee", xdr.lookup("Uint32")], ["baseReserve", xdr.lookup("Uint32")], ["maxTxSetSize", xdr.lookup("Uint32")], ["skipList", xdr.array(xdr.lookup("Hash"), 4)], ["ext", xdr.lookup("LedgerHeaderExt")]]);
      xdr["enum"]("LedgerUpgradeType", {
        ledgerUpgradeVersion: 1,
        ledgerUpgradeBaseFee: 2,
        ledgerUpgradeMaxTxSetSize: 3,
        ledgerUpgradeBaseReserve: 4,
        ledgerUpgradeFlags: 5,
        ledgerUpgradeConfig: 6,
        ledgerUpgradeMaxSorobanTxSetSize: 7
      });
      xdr.struct("ConfigUpgradeSetKey", [["contractId", xdr.lookup("Hash")], ["contentHash", xdr.lookup("Hash")]]);
      xdr.union("LedgerUpgrade", {
        switchOn: xdr.lookup("LedgerUpgradeType"),
        switchName: "type",
        switches: [["ledgerUpgradeVersion", "newLedgerVersion"], ["ledgerUpgradeBaseFee", "newBaseFee"], ["ledgerUpgradeMaxTxSetSize", "newMaxTxSetSize"], ["ledgerUpgradeBaseReserve", "newBaseReserve"], ["ledgerUpgradeFlags", "newFlags"], ["ledgerUpgradeConfig", "newConfig"], ["ledgerUpgradeMaxSorobanTxSetSize", "newMaxSorobanTxSetSize"]],
        arms: {
          newLedgerVersion: xdr.lookup("Uint32"),
          newBaseFee: xdr.lookup("Uint32"),
          newMaxTxSetSize: xdr.lookup("Uint32"),
          newBaseReserve: xdr.lookup("Uint32"),
          newFlags: xdr.lookup("Uint32"),
          newConfig: xdr.lookup("ConfigUpgradeSetKey"),
          newMaxSorobanTxSetSize: xdr.lookup("Uint32")
        }
      });
      xdr.struct("ConfigUpgradeSet", [["updatedEntry", xdr.varArray(xdr.lookup("ConfigSettingEntry"), 2147483647)]]);
      xdr["enum"]("TxSetComponentType", {
        txsetCompTxsMaybeDiscountedFee: 0
      });
      xdr.struct("TxSetComponentTxsMaybeDiscountedFee", [["baseFee", xdr.option(xdr.lookup("Int64"))], ["txes", xdr.varArray(xdr.lookup("TransactionEnvelope"), 2147483647)]]);
      xdr.union("TxSetComponent", {
        switchOn: xdr.lookup("TxSetComponentType"),
        switchName: "type",
        switches: [["txsetCompTxsMaybeDiscountedFee", "txsMaybeDiscountedFee"]],
        arms: {
          txsMaybeDiscountedFee: xdr.lookup("TxSetComponentTxsMaybeDiscountedFee")
        }
      });
      xdr.union("TransactionPhase", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, "v0Components"]],
        arms: {
          v0Components: xdr.varArray(xdr.lookup("TxSetComponent"), 2147483647)
        }
      });
      xdr.struct("TransactionSet", [["previousLedgerHash", xdr.lookup("Hash")], ["txes", xdr.varArray(xdr.lookup("TransactionEnvelope"), 2147483647)]]);
      xdr.struct("TransactionSetV1", [["previousLedgerHash", xdr.lookup("Hash")], ["phases", xdr.varArray(xdr.lookup("TransactionPhase"), 2147483647)]]);
      xdr.union("GeneralizedTransactionSet", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[1, "v1TxSet"]],
        arms: {
          v1TxSet: xdr.lookup("TransactionSetV1")
        }
      });
      xdr.struct("TransactionResultPair", [["transactionHash", xdr.lookup("Hash")], ["result", xdr.lookup("TransactionResult")]]);
      xdr.struct("TransactionResultSet", [["results", xdr.varArray(xdr.lookup("TransactionResultPair"), 2147483647)]]);
      xdr.union("TransactionHistoryEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [1, "generalizedTxSet"]],
        arms: {
          generalizedTxSet: xdr.lookup("GeneralizedTransactionSet")
        }
      });
      xdr.struct("TransactionHistoryEntry", [["ledgerSeq", xdr.lookup("Uint32")], ["txSet", xdr.lookup("TransactionSet")], ["ext", xdr.lookup("TransactionHistoryEntryExt")]]);
      xdr.union("TransactionHistoryResultEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr.struct("TransactionHistoryResultEntry", [["ledgerSeq", xdr.lookup("Uint32")], ["txResultSet", xdr.lookup("TransactionResultSet")], ["ext", xdr.lookup("TransactionHistoryResultEntryExt")]]);
      xdr.union("LedgerHeaderHistoryEntryExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr.struct("LedgerHeaderHistoryEntry", [["hash", xdr.lookup("Hash")], ["header", xdr.lookup("LedgerHeader")], ["ext", xdr.lookup("LedgerHeaderHistoryEntryExt")]]);
      xdr.struct("LedgerScpMessages", [["ledgerSeq", xdr.lookup("Uint32")], ["messages", xdr.varArray(xdr.lookup("ScpEnvelope"), 2147483647)]]);
      xdr.struct("ScpHistoryEntryV0", [["quorumSets", xdr.varArray(xdr.lookup("ScpQuorumSet"), 2147483647)], ["ledgerMessages", xdr.lookup("LedgerScpMessages")]]);
      xdr.union("ScpHistoryEntry", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, "v0"]],
        arms: {
          v0: xdr.lookup("ScpHistoryEntryV0")
        }
      });
      xdr["enum"]("LedgerEntryChangeType", {
        ledgerEntryCreated: 0,
        ledgerEntryUpdated: 1,
        ledgerEntryRemoved: 2,
        ledgerEntryState: 3
      });
      xdr.union("LedgerEntryChange", {
        switchOn: xdr.lookup("LedgerEntryChangeType"),
        switchName: "type",
        switches: [["ledgerEntryCreated", "created"], ["ledgerEntryUpdated", "updated"], ["ledgerEntryRemoved", "removed"], ["ledgerEntryState", "state"]],
        arms: {
          created: xdr.lookup("LedgerEntry"),
          updated: xdr.lookup("LedgerEntry"),
          removed: xdr.lookup("LedgerKey"),
          state: xdr.lookup("LedgerEntry")
        }
      });
      xdr.typedef("LedgerEntryChanges", xdr.varArray(xdr.lookup("LedgerEntryChange"), 2147483647));
      xdr.struct("OperationMeta", [["changes", xdr.lookup("LedgerEntryChanges")]]);
      xdr.struct("TransactionMetaV1", [["txChanges", xdr.lookup("LedgerEntryChanges")], ["operations", xdr.varArray(xdr.lookup("OperationMeta"), 2147483647)]]);
      xdr.struct("TransactionMetaV2", [["txChangesBefore", xdr.lookup("LedgerEntryChanges")], ["operations", xdr.varArray(xdr.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", xdr.lookup("LedgerEntryChanges")]]);
      xdr["enum"]("ContractEventType", {
        system: 0,
        contract: 1,
        diagnostic: 2
      });
      xdr.struct("ContractEventV0", [["topics", xdr.varArray(xdr.lookup("ScVal"), 2147483647)], ["data", xdr.lookup("ScVal")]]);
      xdr.union("ContractEventBody", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, "v0"]],
        arms: {
          v0: xdr.lookup("ContractEventV0")
        }
      });
      xdr.struct("ContractEvent", [["ext", xdr.lookup("ExtensionPoint")], ["contractId", xdr.option(xdr.lookup("Hash"))], ["type", xdr.lookup("ContractEventType")], ["body", xdr.lookup("ContractEventBody")]]);
      xdr.struct("DiagnosticEvent", [["inSuccessfulContractCall", xdr.bool()], ["event", xdr.lookup("ContractEvent")]]);
      xdr.typedef("DiagnosticEvents", xdr.varArray(xdr.lookup("DiagnosticEvent"), 2147483647));
      xdr.struct("SorobanTransactionMetaExtV1", [["ext", xdr.lookup("ExtensionPoint")], ["totalNonRefundableResourceFeeCharged", xdr.lookup("Int64")], ["totalRefundableResourceFeeCharged", xdr.lookup("Int64")], ["rentFeeCharged", xdr.lookup("Int64")]]);
      xdr.union("SorobanTransactionMetaExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [1, "v1"]],
        arms: {
          v1: xdr.lookup("SorobanTransactionMetaExtV1")
        }
      });
      xdr.struct("SorobanTransactionMeta", [["ext", xdr.lookup("SorobanTransactionMetaExt")], ["events", xdr.varArray(xdr.lookup("ContractEvent"), 2147483647)], ["returnValue", xdr.lookup("ScVal")], ["diagnosticEvents", xdr.varArray(xdr.lookup("DiagnosticEvent"), 2147483647)]]);
      xdr.struct("TransactionMetaV3", [["ext", xdr.lookup("ExtensionPoint")], ["txChangesBefore", xdr.lookup("LedgerEntryChanges")], ["operations", xdr.varArray(xdr.lookup("OperationMeta"), 2147483647)], ["txChangesAfter", xdr.lookup("LedgerEntryChanges")], ["sorobanMeta", xdr.option(xdr.lookup("SorobanTransactionMeta"))]]);
      xdr.struct("InvokeHostFunctionSuccessPreImage", [["returnValue", xdr.lookup("ScVal")], ["events", xdr.varArray(xdr.lookup("ContractEvent"), 2147483647)]]);
      xdr.union("TransactionMeta", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, "operations"], [1, "v1"], [2, "v2"], [3, "v3"]],
        arms: {
          operations: xdr.varArray(xdr.lookup("OperationMeta"), 2147483647),
          v1: xdr.lookup("TransactionMetaV1"),
          v2: xdr.lookup("TransactionMetaV2"),
          v3: xdr.lookup("TransactionMetaV3")
        }
      });
      xdr.struct("TransactionResultMeta", [["result", xdr.lookup("TransactionResultPair")], ["feeProcessing", xdr.lookup("LedgerEntryChanges")], ["txApplyProcessing", xdr.lookup("TransactionMeta")]]);
      xdr.struct("UpgradeEntryMeta", [["upgrade", xdr.lookup("LedgerUpgrade")], ["changes", xdr.lookup("LedgerEntryChanges")]]);
      xdr.struct("LedgerCloseMetaV0", [["ledgerHeader", xdr.lookup("LedgerHeaderHistoryEntry")], ["txSet", xdr.lookup("TransactionSet")], ["txProcessing", xdr.varArray(xdr.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", xdr.varArray(xdr.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", xdr.varArray(xdr.lookup("ScpHistoryEntry"), 2147483647)]]);
      xdr.struct("LedgerCloseMetaExtV1", [["ext", xdr.lookup("ExtensionPoint")], ["sorobanFeeWrite1Kb", xdr.lookup("Int64")]]);
      xdr.union("LedgerCloseMetaExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [1, "v1"]],
        arms: {
          v1: xdr.lookup("LedgerCloseMetaExtV1")
        }
      });
      xdr.struct("LedgerCloseMetaV1", [["ext", xdr.lookup("LedgerCloseMetaExt")], ["ledgerHeader", xdr.lookup("LedgerHeaderHistoryEntry")], ["txSet", xdr.lookup("GeneralizedTransactionSet")], ["txProcessing", xdr.varArray(xdr.lookup("TransactionResultMeta"), 2147483647)], ["upgradesProcessing", xdr.varArray(xdr.lookup("UpgradeEntryMeta"), 2147483647)], ["scpInfo", xdr.varArray(xdr.lookup("ScpHistoryEntry"), 2147483647)], ["totalByteSizeOfBucketList", xdr.lookup("Uint64")], ["evictedTemporaryLedgerKeys", xdr.varArray(xdr.lookup("LedgerKey"), 2147483647)], ["evictedPersistentLedgerEntries", xdr.varArray(xdr.lookup("LedgerEntry"), 2147483647)]]);
      xdr.union("LedgerCloseMeta", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, "v0"], [1, "v1"]],
        arms: {
          v0: xdr.lookup("LedgerCloseMetaV0"),
          v1: xdr.lookup("LedgerCloseMetaV1")
        }
      });
      xdr["enum"]("ErrorCode", {
        errMisc: 0,
        errData: 1,
        errConf: 2,
        errAuth: 3,
        errLoad: 4
      });
      xdr.struct("Error", [["code", xdr.lookup("ErrorCode")], ["msg", xdr.string(100)]]);
      xdr.struct("SendMore", [["numMessages", xdr.lookup("Uint32")]]);
      xdr.struct("SendMoreExtended", [["numMessages", xdr.lookup("Uint32")], ["numBytes", xdr.lookup("Uint32")]]);
      xdr.struct("AuthCert", [["pubkey", xdr.lookup("Curve25519Public")], ["expiration", xdr.lookup("Uint64")], ["sig", xdr.lookup("Signature")]]);
      xdr.struct("Hello", [["ledgerVersion", xdr.lookup("Uint32")], ["overlayVersion", xdr.lookup("Uint32")], ["overlayMinVersion", xdr.lookup("Uint32")], ["networkId", xdr.lookup("Hash")], ["versionStr", xdr.string(100)], ["listeningPort", xdr["int"]()], ["peerId", xdr.lookup("NodeId")], ["cert", xdr.lookup("AuthCert")], ["nonce", xdr.lookup("Uint256")]]);
      xdr["const"]("AUTH_MSG_FLAG_FLOW_CONTROL_BYTES_REQUESTED", 200);
      xdr.struct("Auth", [["flags", xdr["int"]()]]);
      xdr["enum"]("IpAddrType", {
        iPv4: 0,
        iPv6: 1
      });
      xdr.union("PeerAddressIp", {
        switchOn: xdr.lookup("IpAddrType"),
        switchName: "type",
        switches: [["iPv4", "ipv4"], ["iPv6", "ipv6"]],
        arms: {
          ipv4: xdr.opaque(4),
          ipv6: xdr.opaque(16)
        }
      });
      xdr.struct("PeerAddress", [["ip", xdr.lookup("PeerAddressIp")], ["port", xdr.lookup("Uint32")], ["numFailures", xdr.lookup("Uint32")]]);
      xdr["enum"]("MessageType", {
        errorMsg: 0,
        auth: 2,
        dontHave: 3,
        getPeers: 4,
        peers: 5,
        getTxSet: 6,
        txSet: 7,
        generalizedTxSet: 17,
        transaction: 8,
        getScpQuorumset: 9,
        scpQuorumset: 10,
        scpMessage: 11,
        getScpState: 12,
        hello: 13,
        surveyRequest: 14,
        surveyResponse: 15,
        sendMore: 16,
        sendMoreExtended: 20,
        floodAdvert: 18,
        floodDemand: 19,
        timeSlicedSurveyRequest: 21,
        timeSlicedSurveyResponse: 22,
        timeSlicedSurveyStartCollecting: 23,
        timeSlicedSurveyStopCollecting: 24
      });
      xdr.struct("DontHave", [["type", xdr.lookup("MessageType")], ["reqHash", xdr.lookup("Uint256")]]);
      xdr["enum"]("SurveyMessageCommandType", {
        surveyTopology: 0,
        timeSlicedSurveyTopology: 1
      });
      xdr["enum"]("SurveyMessageResponseType", {
        surveyTopologyResponseV0: 0,
        surveyTopologyResponseV1: 1,
        surveyTopologyResponseV2: 2
      });
      xdr.struct("TimeSlicedSurveyStartCollectingMessage", [["surveyorId", xdr.lookup("NodeId")], ["nonce", xdr.lookup("Uint32")], ["ledgerNum", xdr.lookup("Uint32")]]);
      xdr.struct("SignedTimeSlicedSurveyStartCollectingMessage", [["signature", xdr.lookup("Signature")], ["startCollecting", xdr.lookup("TimeSlicedSurveyStartCollectingMessage")]]);
      xdr.struct("TimeSlicedSurveyStopCollectingMessage", [["surveyorId", xdr.lookup("NodeId")], ["nonce", xdr.lookup("Uint32")], ["ledgerNum", xdr.lookup("Uint32")]]);
      xdr.struct("SignedTimeSlicedSurveyStopCollectingMessage", [["signature", xdr.lookup("Signature")], ["stopCollecting", xdr.lookup("TimeSlicedSurveyStopCollectingMessage")]]);
      xdr.struct("SurveyRequestMessage", [["surveyorPeerId", xdr.lookup("NodeId")], ["surveyedPeerId", xdr.lookup("NodeId")], ["ledgerNum", xdr.lookup("Uint32")], ["encryptionKey", xdr.lookup("Curve25519Public")], ["commandType", xdr.lookup("SurveyMessageCommandType")]]);
      xdr.struct("TimeSlicedSurveyRequestMessage", [["request", xdr.lookup("SurveyRequestMessage")], ["nonce", xdr.lookup("Uint32")], ["inboundPeersIndex", xdr.lookup("Uint32")], ["outboundPeersIndex", xdr.lookup("Uint32")]]);
      xdr.struct("SignedSurveyRequestMessage", [["requestSignature", xdr.lookup("Signature")], ["request", xdr.lookup("SurveyRequestMessage")]]);
      xdr.struct("SignedTimeSlicedSurveyRequestMessage", [["requestSignature", xdr.lookup("Signature")], ["request", xdr.lookup("TimeSlicedSurveyRequestMessage")]]);
      xdr.typedef("EncryptedBody", xdr.varOpaque(64e3));
      xdr.struct("SurveyResponseMessage", [["surveyorPeerId", xdr.lookup("NodeId")], ["surveyedPeerId", xdr.lookup("NodeId")], ["ledgerNum", xdr.lookup("Uint32")], ["commandType", xdr.lookup("SurveyMessageCommandType")], ["encryptedBody", xdr.lookup("EncryptedBody")]]);
      xdr.struct("TimeSlicedSurveyResponseMessage", [["response", xdr.lookup("SurveyResponseMessage")], ["nonce", xdr.lookup("Uint32")]]);
      xdr.struct("SignedSurveyResponseMessage", [["responseSignature", xdr.lookup("Signature")], ["response", xdr.lookup("SurveyResponseMessage")]]);
      xdr.struct("SignedTimeSlicedSurveyResponseMessage", [["responseSignature", xdr.lookup("Signature")], ["response", xdr.lookup("TimeSlicedSurveyResponseMessage")]]);
      xdr.struct("PeerStats", [["id", xdr.lookup("NodeId")], ["versionStr", xdr.string(100)], ["messagesRead", xdr.lookup("Uint64")], ["messagesWritten", xdr.lookup("Uint64")], ["bytesRead", xdr.lookup("Uint64")], ["bytesWritten", xdr.lookup("Uint64")], ["secondsConnected", xdr.lookup("Uint64")], ["uniqueFloodBytesRecv", xdr.lookup("Uint64")], ["duplicateFloodBytesRecv", xdr.lookup("Uint64")], ["uniqueFetchBytesRecv", xdr.lookup("Uint64")], ["duplicateFetchBytesRecv", xdr.lookup("Uint64")], ["uniqueFloodMessageRecv", xdr.lookup("Uint64")], ["duplicateFloodMessageRecv", xdr.lookup("Uint64")], ["uniqueFetchMessageRecv", xdr.lookup("Uint64")], ["duplicateFetchMessageRecv", xdr.lookup("Uint64")]]);
      xdr.typedef("PeerStatList", xdr.varArray(xdr.lookup("PeerStats"), 25));
      xdr.struct("TimeSlicedNodeData", [["addedAuthenticatedPeers", xdr.lookup("Uint32")], ["droppedAuthenticatedPeers", xdr.lookup("Uint32")], ["totalInboundPeerCount", xdr.lookup("Uint32")], ["totalOutboundPeerCount", xdr.lookup("Uint32")], ["p75ScpFirstToSelfLatencyMs", xdr.lookup("Uint32")], ["p75ScpSelfToOtherLatencyMs", xdr.lookup("Uint32")], ["lostSyncCount", xdr.lookup("Uint32")], ["isValidator", xdr.bool()], ["maxInboundPeerCount", xdr.lookup("Uint32")], ["maxOutboundPeerCount", xdr.lookup("Uint32")]]);
      xdr.struct("TimeSlicedPeerData", [["peerStats", xdr.lookup("PeerStats")], ["averageLatencyMs", xdr.lookup("Uint32")]]);
      xdr.typedef("TimeSlicedPeerDataList", xdr.varArray(xdr.lookup("TimeSlicedPeerData"), 25));
      xdr.struct("TopologyResponseBodyV0", [["inboundPeers", xdr.lookup("PeerStatList")], ["outboundPeers", xdr.lookup("PeerStatList")], ["totalInboundPeerCount", xdr.lookup("Uint32")], ["totalOutboundPeerCount", xdr.lookup("Uint32")]]);
      xdr.struct("TopologyResponseBodyV1", [["inboundPeers", xdr.lookup("PeerStatList")], ["outboundPeers", xdr.lookup("PeerStatList")], ["totalInboundPeerCount", xdr.lookup("Uint32")], ["totalOutboundPeerCount", xdr.lookup("Uint32")], ["maxInboundPeerCount", xdr.lookup("Uint32")], ["maxOutboundPeerCount", xdr.lookup("Uint32")]]);
      xdr.struct("TopologyResponseBodyV2", [["inboundPeers", xdr.lookup("TimeSlicedPeerDataList")], ["outboundPeers", xdr.lookup("TimeSlicedPeerDataList")], ["nodeData", xdr.lookup("TimeSlicedNodeData")]]);
      xdr.union("SurveyResponseBody", {
        switchOn: xdr.lookup("SurveyMessageResponseType"),
        switchName: "type",
        switches: [["surveyTopologyResponseV0", "topologyResponseBodyV0"], ["surveyTopologyResponseV1", "topologyResponseBodyV1"], ["surveyTopologyResponseV2", "topologyResponseBodyV2"]],
        arms: {
          topologyResponseBodyV0: xdr.lookup("TopologyResponseBodyV0"),
          topologyResponseBodyV1: xdr.lookup("TopologyResponseBodyV1"),
          topologyResponseBodyV2: xdr.lookup("TopologyResponseBodyV2")
        }
      });
      xdr["const"]("TX_ADVERT_VECTOR_MAX_SIZE", 1e3);
      xdr.typedef("TxAdvertVector", xdr.varArray(xdr.lookup("Hash"), xdr.lookup("TX_ADVERT_VECTOR_MAX_SIZE")));
      xdr.struct("FloodAdvert", [["txHashes", xdr.lookup("TxAdvertVector")]]);
      xdr["const"]("TX_DEMAND_VECTOR_MAX_SIZE", 1e3);
      xdr.typedef("TxDemandVector", xdr.varArray(xdr.lookup("Hash"), xdr.lookup("TX_DEMAND_VECTOR_MAX_SIZE")));
      xdr.struct("FloodDemand", [["txHashes", xdr.lookup("TxDemandVector")]]);
      xdr.union("StellarMessage", {
        switchOn: xdr.lookup("MessageType"),
        switchName: "type",
        switches: [["errorMsg", "error"], ["hello", "hello"], ["auth", "auth"], ["dontHave", "dontHave"], ["getPeers", xdr["void"]()], ["peers", "peers"], ["getTxSet", "txSetHash"], ["txSet", "txSet"], ["generalizedTxSet", "generalizedTxSet"], ["transaction", "transaction"], ["surveyRequest", "signedSurveyRequestMessage"], ["surveyResponse", "signedSurveyResponseMessage"], ["timeSlicedSurveyRequest", "signedTimeSlicedSurveyRequestMessage"], ["timeSlicedSurveyResponse", "signedTimeSlicedSurveyResponseMessage"], ["timeSlicedSurveyStartCollecting", "signedTimeSlicedSurveyStartCollectingMessage"], ["timeSlicedSurveyStopCollecting", "signedTimeSlicedSurveyStopCollectingMessage"], ["getScpQuorumset", "qSetHash"], ["scpQuorumset", "qSet"], ["scpMessage", "envelope"], ["getScpState", "getScpLedgerSeq"], ["sendMore", "sendMoreMessage"], ["sendMoreExtended", "sendMoreExtendedMessage"], ["floodAdvert", "floodAdvert"], ["floodDemand", "floodDemand"]],
        arms: {
          error: xdr.lookup("Error"),
          hello: xdr.lookup("Hello"),
          auth: xdr.lookup("Auth"),
          dontHave: xdr.lookup("DontHave"),
          peers: xdr.varArray(xdr.lookup("PeerAddress"), 100),
          txSetHash: xdr.lookup("Uint256"),
          txSet: xdr.lookup("TransactionSet"),
          generalizedTxSet: xdr.lookup("GeneralizedTransactionSet"),
          transaction: xdr.lookup("TransactionEnvelope"),
          signedSurveyRequestMessage: xdr.lookup("SignedSurveyRequestMessage"),
          signedSurveyResponseMessage: xdr.lookup("SignedSurveyResponseMessage"),
          signedTimeSlicedSurveyRequestMessage: xdr.lookup("SignedTimeSlicedSurveyRequestMessage"),
          signedTimeSlicedSurveyResponseMessage: xdr.lookup("SignedTimeSlicedSurveyResponseMessage"),
          signedTimeSlicedSurveyStartCollectingMessage: xdr.lookup("SignedTimeSlicedSurveyStartCollectingMessage"),
          signedTimeSlicedSurveyStopCollectingMessage: xdr.lookup("SignedTimeSlicedSurveyStopCollectingMessage"),
          qSetHash: xdr.lookup("Uint256"),
          qSet: xdr.lookup("ScpQuorumSet"),
          envelope: xdr.lookup("ScpEnvelope"),
          getScpLedgerSeq: xdr.lookup("Uint32"),
          sendMoreMessage: xdr.lookup("SendMore"),
          sendMoreExtendedMessage: xdr.lookup("SendMoreExtended"),
          floodAdvert: xdr.lookup("FloodAdvert"),
          floodDemand: xdr.lookup("FloodDemand")
        }
      });
      xdr.struct("AuthenticatedMessageV0", [["sequence", xdr.lookup("Uint64")], ["message", xdr.lookup("StellarMessage")], ["mac", xdr.lookup("HmacSha256Mac")]]);
      xdr.union("AuthenticatedMessage", {
        switchOn: xdr.lookup("Uint32"),
        switchName: "v",
        switches: [[0, "v0"]],
        arms: {
          v0: xdr.lookup("AuthenticatedMessageV0")
        }
      });
      xdr["const"]("MAX_OPS_PER_TX", 100);
      xdr.union("LiquidityPoolParameters", {
        switchOn: xdr.lookup("LiquidityPoolType"),
        switchName: "type",
        switches: [["liquidityPoolConstantProduct", "constantProduct"]],
        arms: {
          constantProduct: xdr.lookup("LiquidityPoolConstantProductParameters")
        }
      });
      xdr.struct("MuxedAccountMed25519", [["id", xdr.lookup("Uint64")], ["ed25519", xdr.lookup("Uint256")]]);
      xdr.union("MuxedAccount", {
        switchOn: xdr.lookup("CryptoKeyType"),
        switchName: "type",
        switches: [["keyTypeEd25519", "ed25519"], ["keyTypeMuxedEd25519", "med25519"]],
        arms: {
          ed25519: xdr.lookup("Uint256"),
          med25519: xdr.lookup("MuxedAccountMed25519")
        }
      });
      xdr.struct("DecoratedSignature", [["hint", xdr.lookup("SignatureHint")], ["signature", xdr.lookup("Signature")]]);
      xdr["enum"]("OperationType", {
        createAccount: 0,
        payment: 1,
        pathPaymentStrictReceive: 2,
        manageSellOffer: 3,
        createPassiveSellOffer: 4,
        setOptions: 5,
        changeTrust: 6,
        allowTrust: 7,
        accountMerge: 8,
        inflation: 9,
        manageData: 10,
        bumpSequence: 11,
        manageBuyOffer: 12,
        pathPaymentStrictSend: 13,
        createClaimableBalance: 14,
        claimClaimableBalance: 15,
        beginSponsoringFutureReserves: 16,
        endSponsoringFutureReserves: 17,
        revokeSponsorship: 18,
        clawback: 19,
        clawbackClaimableBalance: 20,
        setTrustLineFlags: 21,
        liquidityPoolDeposit: 22,
        liquidityPoolWithdraw: 23,
        invokeHostFunction: 24,
        extendFootprintTtl: 25,
        restoreFootprint: 26
      });
      xdr.struct("CreateAccountOp", [["destination", xdr.lookup("AccountId")], ["startingBalance", xdr.lookup("Int64")]]);
      xdr.struct("PaymentOp", [["destination", xdr.lookup("MuxedAccount")], ["asset", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")]]);
      xdr.struct("PathPaymentStrictReceiveOp", [["sendAsset", xdr.lookup("Asset")], ["sendMax", xdr.lookup("Int64")], ["destination", xdr.lookup("MuxedAccount")], ["destAsset", xdr.lookup("Asset")], ["destAmount", xdr.lookup("Int64")], ["path", xdr.varArray(xdr.lookup("Asset"), 5)]]);
      xdr.struct("PathPaymentStrictSendOp", [["sendAsset", xdr.lookup("Asset")], ["sendAmount", xdr.lookup("Int64")], ["destination", xdr.lookup("MuxedAccount")], ["destAsset", xdr.lookup("Asset")], ["destMin", xdr.lookup("Int64")], ["path", xdr.varArray(xdr.lookup("Asset"), 5)]]);
      xdr.struct("ManageSellOfferOp", [["selling", xdr.lookup("Asset")], ["buying", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")], ["price", xdr.lookup("Price")], ["offerId", xdr.lookup("Int64")]]);
      xdr.struct("ManageBuyOfferOp", [["selling", xdr.lookup("Asset")], ["buying", xdr.lookup("Asset")], ["buyAmount", xdr.lookup("Int64")], ["price", xdr.lookup("Price")], ["offerId", xdr.lookup("Int64")]]);
      xdr.struct("CreatePassiveSellOfferOp", [["selling", xdr.lookup("Asset")], ["buying", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")], ["price", xdr.lookup("Price")]]);
      xdr.struct("SetOptionsOp", [["inflationDest", xdr.option(xdr.lookup("AccountId"))], ["clearFlags", xdr.option(xdr.lookup("Uint32"))], ["setFlags", xdr.option(xdr.lookup("Uint32"))], ["masterWeight", xdr.option(xdr.lookup("Uint32"))], ["lowThreshold", xdr.option(xdr.lookup("Uint32"))], ["medThreshold", xdr.option(xdr.lookup("Uint32"))], ["highThreshold", xdr.option(xdr.lookup("Uint32"))], ["homeDomain", xdr.option(xdr.lookup("String32"))], ["signer", xdr.option(xdr.lookup("Signer"))]]);
      xdr.union("ChangeTrustAsset", {
        switchOn: xdr.lookup("AssetType"),
        switchName: "type",
        switches: [["assetTypeNative", xdr["void"]()], ["assetTypeCreditAlphanum4", "alphaNum4"], ["assetTypeCreditAlphanum12", "alphaNum12"], ["assetTypePoolShare", "liquidityPool"]],
        arms: {
          alphaNum4: xdr.lookup("AlphaNum4"),
          alphaNum12: xdr.lookup("AlphaNum12"),
          liquidityPool: xdr.lookup("LiquidityPoolParameters")
        }
      });
      xdr.struct("ChangeTrustOp", [["line", xdr.lookup("ChangeTrustAsset")], ["limit", xdr.lookup("Int64")]]);
      xdr.struct("AllowTrustOp", [["trustor", xdr.lookup("AccountId")], ["asset", xdr.lookup("AssetCode")], ["authorize", xdr.lookup("Uint32")]]);
      xdr.struct("ManageDataOp", [["dataName", xdr.lookup("String64")], ["dataValue", xdr.option(xdr.lookup("DataValue"))]]);
      xdr.struct("BumpSequenceOp", [["bumpTo", xdr.lookup("SequenceNumber")]]);
      xdr.struct("CreateClaimableBalanceOp", [["asset", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")], ["claimants", xdr.varArray(xdr.lookup("Claimant"), 10)]]);
      xdr.struct("ClaimClaimableBalanceOp", [["balanceId", xdr.lookup("ClaimableBalanceId")]]);
      xdr.struct("BeginSponsoringFutureReservesOp", [["sponsoredId", xdr.lookup("AccountId")]]);
      xdr["enum"]("RevokeSponsorshipType", {
        revokeSponsorshipLedgerEntry: 0,
        revokeSponsorshipSigner: 1
      });
      xdr.struct("RevokeSponsorshipOpSigner", [["accountId", xdr.lookup("AccountId")], ["signerKey", xdr.lookup("SignerKey")]]);
      xdr.union("RevokeSponsorshipOp", {
        switchOn: xdr.lookup("RevokeSponsorshipType"),
        switchName: "type",
        switches: [["revokeSponsorshipLedgerEntry", "ledgerKey"], ["revokeSponsorshipSigner", "signer"]],
        arms: {
          ledgerKey: xdr.lookup("LedgerKey"),
          signer: xdr.lookup("RevokeSponsorshipOpSigner")
        }
      });
      xdr.struct("ClawbackOp", [["asset", xdr.lookup("Asset")], ["from", xdr.lookup("MuxedAccount")], ["amount", xdr.lookup("Int64")]]);
      xdr.struct("ClawbackClaimableBalanceOp", [["balanceId", xdr.lookup("ClaimableBalanceId")]]);
      xdr.struct("SetTrustLineFlagsOp", [["trustor", xdr.lookup("AccountId")], ["asset", xdr.lookup("Asset")], ["clearFlags", xdr.lookup("Uint32")], ["setFlags", xdr.lookup("Uint32")]]);
      xdr["const"]("LIQUIDITY_POOL_FEE_V18", 30);
      xdr.struct("LiquidityPoolDepositOp", [["liquidityPoolId", xdr.lookup("PoolId")], ["maxAmountA", xdr.lookup("Int64")], ["maxAmountB", xdr.lookup("Int64")], ["minPrice", xdr.lookup("Price")], ["maxPrice", xdr.lookup("Price")]]);
      xdr.struct("LiquidityPoolWithdrawOp", [["liquidityPoolId", xdr.lookup("PoolId")], ["amount", xdr.lookup("Int64")], ["minAmountA", xdr.lookup("Int64")], ["minAmountB", xdr.lookup("Int64")]]);
      xdr["enum"]("HostFunctionType", {
        hostFunctionTypeInvokeContract: 0,
        hostFunctionTypeCreateContract: 1,
        hostFunctionTypeUploadContractWasm: 2,
        hostFunctionTypeCreateContractV2: 3
      });
      xdr["enum"]("ContractIdPreimageType", {
        contractIdPreimageFromAddress: 0,
        contractIdPreimageFromAsset: 1
      });
      xdr.struct("ContractIdPreimageFromAddress", [["address", xdr.lookup("ScAddress")], ["salt", xdr.lookup("Uint256")]]);
      xdr.union("ContractIdPreimage", {
        switchOn: xdr.lookup("ContractIdPreimageType"),
        switchName: "type",
        switches: [["contractIdPreimageFromAddress", "fromAddress"], ["contractIdPreimageFromAsset", "fromAsset"]],
        arms: {
          fromAddress: xdr.lookup("ContractIdPreimageFromAddress"),
          fromAsset: xdr.lookup("Asset")
        }
      });
      xdr.struct("CreateContractArgs", [["contractIdPreimage", xdr.lookup("ContractIdPreimage")], ["executable", xdr.lookup("ContractExecutable")]]);
      xdr.struct("CreateContractArgsV2", [["contractIdPreimage", xdr.lookup("ContractIdPreimage")], ["executable", xdr.lookup("ContractExecutable")], ["constructorArgs", xdr.varArray(xdr.lookup("ScVal"), 2147483647)]]);
      xdr.struct("InvokeContractArgs", [["contractAddress", xdr.lookup("ScAddress")], ["functionName", xdr.lookup("ScSymbol")], ["args", xdr.varArray(xdr.lookup("ScVal"), 2147483647)]]);
      xdr.union("HostFunction", {
        switchOn: xdr.lookup("HostFunctionType"),
        switchName: "type",
        switches: [["hostFunctionTypeInvokeContract", "invokeContract"], ["hostFunctionTypeCreateContract", "createContract"], ["hostFunctionTypeUploadContractWasm", "wasm"], ["hostFunctionTypeCreateContractV2", "createContractV2"]],
        arms: {
          invokeContract: xdr.lookup("InvokeContractArgs"),
          createContract: xdr.lookup("CreateContractArgs"),
          wasm: xdr.varOpaque(),
          createContractV2: xdr.lookup("CreateContractArgsV2")
        }
      });
      xdr["enum"]("SorobanAuthorizedFunctionType", {
        sorobanAuthorizedFunctionTypeContractFn: 0,
        sorobanAuthorizedFunctionTypeCreateContractHostFn: 1,
        sorobanAuthorizedFunctionTypeCreateContractV2HostFn: 2
      });
      xdr.union("SorobanAuthorizedFunction", {
        switchOn: xdr.lookup("SorobanAuthorizedFunctionType"),
        switchName: "type",
        switches: [["sorobanAuthorizedFunctionTypeContractFn", "contractFn"], ["sorobanAuthorizedFunctionTypeCreateContractHostFn", "createContractHostFn"], ["sorobanAuthorizedFunctionTypeCreateContractV2HostFn", "createContractV2HostFn"]],
        arms: {
          contractFn: xdr.lookup("InvokeContractArgs"),
          createContractHostFn: xdr.lookup("CreateContractArgs"),
          createContractV2HostFn: xdr.lookup("CreateContractArgsV2")
        }
      });
      xdr.struct("SorobanAuthorizedInvocation", [["function", xdr.lookup("SorobanAuthorizedFunction")], ["subInvocations", xdr.varArray(xdr.lookup("SorobanAuthorizedInvocation"), 2147483647)]]);
      xdr.struct("SorobanAddressCredentials", [["address", xdr.lookup("ScAddress")], ["nonce", xdr.lookup("Int64")], ["signatureExpirationLedger", xdr.lookup("Uint32")], ["signature", xdr.lookup("ScVal")]]);
      xdr["enum"]("SorobanCredentialsType", {
        sorobanCredentialsSourceAccount: 0,
        sorobanCredentialsAddress: 1
      });
      xdr.union("SorobanCredentials", {
        switchOn: xdr.lookup("SorobanCredentialsType"),
        switchName: "type",
        switches: [["sorobanCredentialsSourceAccount", xdr["void"]()], ["sorobanCredentialsAddress", "address"]],
        arms: {
          address: xdr.lookup("SorobanAddressCredentials")
        }
      });
      xdr.struct("SorobanAuthorizationEntry", [["credentials", xdr.lookup("SorobanCredentials")], ["rootInvocation", xdr.lookup("SorobanAuthorizedInvocation")]]);
      xdr.struct("InvokeHostFunctionOp", [["hostFunction", xdr.lookup("HostFunction")], ["auth", xdr.varArray(xdr.lookup("SorobanAuthorizationEntry"), 2147483647)]]);
      xdr.struct("ExtendFootprintTtlOp", [["ext", xdr.lookup("ExtensionPoint")], ["extendTo", xdr.lookup("Uint32")]]);
      xdr.struct("RestoreFootprintOp", [["ext", xdr.lookup("ExtensionPoint")]]);
      xdr.union("OperationBody", {
        switchOn: xdr.lookup("OperationType"),
        switchName: "type",
        switches: [["createAccount", "createAccountOp"], ["payment", "paymentOp"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveOp"], ["manageSellOffer", "manageSellOfferOp"], ["createPassiveSellOffer", "createPassiveSellOfferOp"], ["setOptions", "setOptionsOp"], ["changeTrust", "changeTrustOp"], ["allowTrust", "allowTrustOp"], ["accountMerge", "destination"], ["inflation", xdr["void"]()], ["manageData", "manageDataOp"], ["bumpSequence", "bumpSequenceOp"], ["manageBuyOffer", "manageBuyOfferOp"], ["pathPaymentStrictSend", "pathPaymentStrictSendOp"], ["createClaimableBalance", "createClaimableBalanceOp"], ["claimClaimableBalance", "claimClaimableBalanceOp"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesOp"], ["endSponsoringFutureReserves", xdr["void"]()], ["revokeSponsorship", "revokeSponsorshipOp"], ["clawback", "clawbackOp"], ["clawbackClaimableBalance", "clawbackClaimableBalanceOp"], ["setTrustLineFlags", "setTrustLineFlagsOp"], ["liquidityPoolDeposit", "liquidityPoolDepositOp"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawOp"], ["invokeHostFunction", "invokeHostFunctionOp"], ["extendFootprintTtl", "extendFootprintTtlOp"], ["restoreFootprint", "restoreFootprintOp"]],
        arms: {
          createAccountOp: xdr.lookup("CreateAccountOp"),
          paymentOp: xdr.lookup("PaymentOp"),
          pathPaymentStrictReceiveOp: xdr.lookup("PathPaymentStrictReceiveOp"),
          manageSellOfferOp: xdr.lookup("ManageSellOfferOp"),
          createPassiveSellOfferOp: xdr.lookup("CreatePassiveSellOfferOp"),
          setOptionsOp: xdr.lookup("SetOptionsOp"),
          changeTrustOp: xdr.lookup("ChangeTrustOp"),
          allowTrustOp: xdr.lookup("AllowTrustOp"),
          destination: xdr.lookup("MuxedAccount"),
          manageDataOp: xdr.lookup("ManageDataOp"),
          bumpSequenceOp: xdr.lookup("BumpSequenceOp"),
          manageBuyOfferOp: xdr.lookup("ManageBuyOfferOp"),
          pathPaymentStrictSendOp: xdr.lookup("PathPaymentStrictSendOp"),
          createClaimableBalanceOp: xdr.lookup("CreateClaimableBalanceOp"),
          claimClaimableBalanceOp: xdr.lookup("ClaimClaimableBalanceOp"),
          beginSponsoringFutureReservesOp: xdr.lookup("BeginSponsoringFutureReservesOp"),
          revokeSponsorshipOp: xdr.lookup("RevokeSponsorshipOp"),
          clawbackOp: xdr.lookup("ClawbackOp"),
          clawbackClaimableBalanceOp: xdr.lookup("ClawbackClaimableBalanceOp"),
          setTrustLineFlagsOp: xdr.lookup("SetTrustLineFlagsOp"),
          liquidityPoolDepositOp: xdr.lookup("LiquidityPoolDepositOp"),
          liquidityPoolWithdrawOp: xdr.lookup("LiquidityPoolWithdrawOp"),
          invokeHostFunctionOp: xdr.lookup("InvokeHostFunctionOp"),
          extendFootprintTtlOp: xdr.lookup("ExtendFootprintTtlOp"),
          restoreFootprintOp: xdr.lookup("RestoreFootprintOp")
        }
      });
      xdr.struct("Operation", [["sourceAccount", xdr.option(xdr.lookup("MuxedAccount"))], ["body", xdr.lookup("OperationBody")]]);
      xdr.struct("HashIdPreimageOperationId", [["sourceAccount", xdr.lookup("AccountId")], ["seqNum", xdr.lookup("SequenceNumber")], ["opNum", xdr.lookup("Uint32")]]);
      xdr.struct("HashIdPreimageRevokeId", [["sourceAccount", xdr.lookup("AccountId")], ["seqNum", xdr.lookup("SequenceNumber")], ["opNum", xdr.lookup("Uint32")], ["liquidityPoolId", xdr.lookup("PoolId")], ["asset", xdr.lookup("Asset")]]);
      xdr.struct("HashIdPreimageContractId", [["networkId", xdr.lookup("Hash")], ["contractIdPreimage", xdr.lookup("ContractIdPreimage")]]);
      xdr.struct("HashIdPreimageSorobanAuthorization", [["networkId", xdr.lookup("Hash")], ["nonce", xdr.lookup("Int64")], ["signatureExpirationLedger", xdr.lookup("Uint32")], ["invocation", xdr.lookup("SorobanAuthorizedInvocation")]]);
      xdr.union("HashIdPreimage", {
        switchOn: xdr.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeOpId", "operationId"], ["envelopeTypePoolRevokeOpId", "revokeId"], ["envelopeTypeContractId", "contractId"], ["envelopeTypeSorobanAuthorization", "sorobanAuthorization"]],
        arms: {
          operationId: xdr.lookup("HashIdPreimageOperationId"),
          revokeId: xdr.lookup("HashIdPreimageRevokeId"),
          contractId: xdr.lookup("HashIdPreimageContractId"),
          sorobanAuthorization: xdr.lookup("HashIdPreimageSorobanAuthorization")
        }
      });
      xdr["enum"]("MemoType", {
        memoNone: 0,
        memoText: 1,
        memoId: 2,
        memoHash: 3,
        memoReturn: 4
      });
      xdr.union("Memo", {
        switchOn: xdr.lookup("MemoType"),
        switchName: "type",
        switches: [["memoNone", xdr["void"]()], ["memoText", "text"], ["memoId", "id"], ["memoHash", "hash"], ["memoReturn", "retHash"]],
        arms: {
          text: xdr.string(28),
          id: xdr.lookup("Uint64"),
          hash: xdr.lookup("Hash"),
          retHash: xdr.lookup("Hash")
        }
      });
      xdr.struct("TimeBounds", [["minTime", xdr.lookup("TimePoint")], ["maxTime", xdr.lookup("TimePoint")]]);
      xdr.struct("LedgerBounds", [["minLedger", xdr.lookup("Uint32")], ["maxLedger", xdr.lookup("Uint32")]]);
      xdr.struct("PreconditionsV2", [["timeBounds", xdr.option(xdr.lookup("TimeBounds"))], ["ledgerBounds", xdr.option(xdr.lookup("LedgerBounds"))], ["minSeqNum", xdr.option(xdr.lookup("SequenceNumber"))], ["minSeqAge", xdr.lookup("Duration")], ["minSeqLedgerGap", xdr.lookup("Uint32")], ["extraSigners", xdr.varArray(xdr.lookup("SignerKey"), 2)]]);
      xdr["enum"]("PreconditionType", {
        precondNone: 0,
        precondTime: 1,
        precondV2: 2
      });
      xdr.union("Preconditions", {
        switchOn: xdr.lookup("PreconditionType"),
        switchName: "type",
        switches: [["precondNone", xdr["void"]()], ["precondTime", "timeBounds"], ["precondV2", "v2"]],
        arms: {
          timeBounds: xdr.lookup("TimeBounds"),
          v2: xdr.lookup("PreconditionsV2")
        }
      });
      xdr.struct("LedgerFootprint", [["readOnly", xdr.varArray(xdr.lookup("LedgerKey"), 2147483647)], ["readWrite", xdr.varArray(xdr.lookup("LedgerKey"), 2147483647)]]);
      xdr["enum"]("ArchivalProofType", {
        existence: 0,
        nonexistence: 1
      });
      xdr.struct("ArchivalProofNode", [["index", xdr.lookup("Uint32")], ["hash", xdr.lookup("Hash")]]);
      xdr.typedef("ProofLevel", xdr.varArray(xdr.lookup("ArchivalProofNode"), 2147483647));
      xdr.struct("NonexistenceProofBody", [["entriesToProve", xdr.varArray(xdr.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", xdr.varArray(xdr.lookup("ProofLevel"), 2147483647)]]);
      xdr.struct("ExistenceProofBody", [["keysToProve", xdr.varArray(xdr.lookup("LedgerKey"), 2147483647)], ["lowBoundEntries", xdr.varArray(xdr.lookup("ColdArchiveBucketEntry"), 2147483647)], ["highBoundEntries", xdr.varArray(xdr.lookup("ColdArchiveBucketEntry"), 2147483647)], ["proofLevels", xdr.varArray(xdr.lookup("ProofLevel"), 2147483647)]]);
      xdr.union("ArchivalProofBody", {
        switchOn: xdr.lookup("ArchivalProofType"),
        switchName: "t",
        switches: [["existence", "nonexistenceProof"], ["nonexistence", "existenceProof"]],
        arms: {
          nonexistenceProof: xdr.lookup("NonexistenceProofBody"),
          existenceProof: xdr.lookup("ExistenceProofBody")
        }
      });
      xdr.struct("ArchivalProof", [["epoch", xdr.lookup("Uint32")], ["body", xdr.lookup("ArchivalProofBody")]]);
      xdr.struct("SorobanResources", [["footprint", xdr.lookup("LedgerFootprint")], ["instructions", xdr.lookup("Uint32")], ["readBytes", xdr.lookup("Uint32")], ["writeBytes", xdr.lookup("Uint32")]]);
      xdr.struct("SorobanTransactionData", [["ext", xdr.lookup("ExtensionPoint")], ["resources", xdr.lookup("SorobanResources")], ["resourceFee", xdr.lookup("Int64")]]);
      xdr.union("TransactionV0Ext", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr.struct("TransactionV0", [["sourceAccountEd25519", xdr.lookup("Uint256")], ["fee", xdr.lookup("Uint32")], ["seqNum", xdr.lookup("SequenceNumber")], ["timeBounds", xdr.option(xdr.lookup("TimeBounds"))], ["memo", xdr.lookup("Memo")], ["operations", xdr.varArray(xdr.lookup("Operation"), xdr.lookup("MAX_OPS_PER_TX"))], ["ext", xdr.lookup("TransactionV0Ext")]]);
      xdr.struct("TransactionV0Envelope", [["tx", xdr.lookup("TransactionV0")], ["signatures", xdr.varArray(xdr.lookup("DecoratedSignature"), 20)]]);
      xdr.union("TransactionExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()], [1, "sorobanData"]],
        arms: {
          sorobanData: xdr.lookup("SorobanTransactionData")
        }
      });
      xdr.struct("Transaction", [["sourceAccount", xdr.lookup("MuxedAccount")], ["fee", xdr.lookup("Uint32")], ["seqNum", xdr.lookup("SequenceNumber")], ["cond", xdr.lookup("Preconditions")], ["memo", xdr.lookup("Memo")], ["operations", xdr.varArray(xdr.lookup("Operation"), xdr.lookup("MAX_OPS_PER_TX"))], ["ext", xdr.lookup("TransactionExt")]]);
      xdr.struct("TransactionV1Envelope", [["tx", xdr.lookup("Transaction")], ["signatures", xdr.varArray(xdr.lookup("DecoratedSignature"), 20)]]);
      xdr.union("FeeBumpTransactionInnerTx", {
        switchOn: xdr.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeTx", "v1"]],
        arms: {
          v1: xdr.lookup("TransactionV1Envelope")
        }
      });
      xdr.union("FeeBumpTransactionExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr.struct("FeeBumpTransaction", [["feeSource", xdr.lookup("MuxedAccount")], ["fee", xdr.lookup("Int64")], ["innerTx", xdr.lookup("FeeBumpTransactionInnerTx")], ["ext", xdr.lookup("FeeBumpTransactionExt")]]);
      xdr.struct("FeeBumpTransactionEnvelope", [["tx", xdr.lookup("FeeBumpTransaction")], ["signatures", xdr.varArray(xdr.lookup("DecoratedSignature"), 20)]]);
      xdr.union("TransactionEnvelope", {
        switchOn: xdr.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeTxV0", "v0"], ["envelopeTypeTx", "v1"], ["envelopeTypeTxFeeBump", "feeBump"]],
        arms: {
          v0: xdr.lookup("TransactionV0Envelope"),
          v1: xdr.lookup("TransactionV1Envelope"),
          feeBump: xdr.lookup("FeeBumpTransactionEnvelope")
        }
      });
      xdr.union("TransactionSignaturePayloadTaggedTransaction", {
        switchOn: xdr.lookup("EnvelopeType"),
        switchName: "type",
        switches: [["envelopeTypeTx", "tx"], ["envelopeTypeTxFeeBump", "feeBump"]],
        arms: {
          tx: xdr.lookup("Transaction"),
          feeBump: xdr.lookup("FeeBumpTransaction")
        }
      });
      xdr.struct("TransactionSignaturePayload", [["networkId", xdr.lookup("Hash")], ["taggedTransaction", xdr.lookup("TransactionSignaturePayloadTaggedTransaction")]]);
      xdr["enum"]("ClaimAtomType", {
        claimAtomTypeV0: 0,
        claimAtomTypeOrderBook: 1,
        claimAtomTypeLiquidityPool: 2
      });
      xdr.struct("ClaimOfferAtomV0", [["sellerEd25519", xdr.lookup("Uint256")], ["offerId", xdr.lookup("Int64")], ["assetSold", xdr.lookup("Asset")], ["amountSold", xdr.lookup("Int64")], ["assetBought", xdr.lookup("Asset")], ["amountBought", xdr.lookup("Int64")]]);
      xdr.struct("ClaimOfferAtom", [["sellerId", xdr.lookup("AccountId")], ["offerId", xdr.lookup("Int64")], ["assetSold", xdr.lookup("Asset")], ["amountSold", xdr.lookup("Int64")], ["assetBought", xdr.lookup("Asset")], ["amountBought", xdr.lookup("Int64")]]);
      xdr.struct("ClaimLiquidityAtom", [["liquidityPoolId", xdr.lookup("PoolId")], ["assetSold", xdr.lookup("Asset")], ["amountSold", xdr.lookup("Int64")], ["assetBought", xdr.lookup("Asset")], ["amountBought", xdr.lookup("Int64")]]);
      xdr.union("ClaimAtom", {
        switchOn: xdr.lookup("ClaimAtomType"),
        switchName: "type",
        switches: [["claimAtomTypeV0", "v0"], ["claimAtomTypeOrderBook", "orderBook"], ["claimAtomTypeLiquidityPool", "liquidityPool"]],
        arms: {
          v0: xdr.lookup("ClaimOfferAtomV0"),
          orderBook: xdr.lookup("ClaimOfferAtom"),
          liquidityPool: xdr.lookup("ClaimLiquidityAtom")
        }
      });
      xdr["enum"]("CreateAccountResultCode", {
        createAccountSuccess: 0,
        createAccountMalformed: -1,
        createAccountUnderfunded: -2,
        createAccountLowReserve: -3,
        createAccountAlreadyExist: -4
      });
      xdr.union("CreateAccountResult", {
        switchOn: xdr.lookup("CreateAccountResultCode"),
        switchName: "code",
        switches: [["createAccountSuccess", xdr["void"]()], ["createAccountMalformed", xdr["void"]()], ["createAccountUnderfunded", xdr["void"]()], ["createAccountLowReserve", xdr["void"]()], ["createAccountAlreadyExist", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("PaymentResultCode", {
        paymentSuccess: 0,
        paymentMalformed: -1,
        paymentUnderfunded: -2,
        paymentSrcNoTrust: -3,
        paymentSrcNotAuthorized: -4,
        paymentNoDestination: -5,
        paymentNoTrust: -6,
        paymentNotAuthorized: -7,
        paymentLineFull: -8,
        paymentNoIssuer: -9
      });
      xdr.union("PaymentResult", {
        switchOn: xdr.lookup("PaymentResultCode"),
        switchName: "code",
        switches: [["paymentSuccess", xdr["void"]()], ["paymentMalformed", xdr["void"]()], ["paymentUnderfunded", xdr["void"]()], ["paymentSrcNoTrust", xdr["void"]()], ["paymentSrcNotAuthorized", xdr["void"]()], ["paymentNoDestination", xdr["void"]()], ["paymentNoTrust", xdr["void"]()], ["paymentNotAuthorized", xdr["void"]()], ["paymentLineFull", xdr["void"]()], ["paymentNoIssuer", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("PathPaymentStrictReceiveResultCode", {
        pathPaymentStrictReceiveSuccess: 0,
        pathPaymentStrictReceiveMalformed: -1,
        pathPaymentStrictReceiveUnderfunded: -2,
        pathPaymentStrictReceiveSrcNoTrust: -3,
        pathPaymentStrictReceiveSrcNotAuthorized: -4,
        pathPaymentStrictReceiveNoDestination: -5,
        pathPaymentStrictReceiveNoTrust: -6,
        pathPaymentStrictReceiveNotAuthorized: -7,
        pathPaymentStrictReceiveLineFull: -8,
        pathPaymentStrictReceiveNoIssuer: -9,
        pathPaymentStrictReceiveTooFewOffers: -10,
        pathPaymentStrictReceiveOfferCrossSelf: -11,
        pathPaymentStrictReceiveOverSendmax: -12
      });
      xdr.struct("SimplePaymentResult", [["destination", xdr.lookup("AccountId")], ["asset", xdr.lookup("Asset")], ["amount", xdr.lookup("Int64")]]);
      xdr.struct("PathPaymentStrictReceiveResultSuccess", [["offers", xdr.varArray(xdr.lookup("ClaimAtom"), 2147483647)], ["last", xdr.lookup("SimplePaymentResult")]]);
      xdr.union("PathPaymentStrictReceiveResult", {
        switchOn: xdr.lookup("PathPaymentStrictReceiveResultCode"),
        switchName: "code",
        switches: [["pathPaymentStrictReceiveSuccess", "success"], ["pathPaymentStrictReceiveMalformed", xdr["void"]()], ["pathPaymentStrictReceiveUnderfunded", xdr["void"]()], ["pathPaymentStrictReceiveSrcNoTrust", xdr["void"]()], ["pathPaymentStrictReceiveSrcNotAuthorized", xdr["void"]()], ["pathPaymentStrictReceiveNoDestination", xdr["void"]()], ["pathPaymentStrictReceiveNoTrust", xdr["void"]()], ["pathPaymentStrictReceiveNotAuthorized", xdr["void"]()], ["pathPaymentStrictReceiveLineFull", xdr["void"]()], ["pathPaymentStrictReceiveNoIssuer", "noIssuer"], ["pathPaymentStrictReceiveTooFewOffers", xdr["void"]()], ["pathPaymentStrictReceiveOfferCrossSelf", xdr["void"]()], ["pathPaymentStrictReceiveOverSendmax", xdr["void"]()]],
        arms: {
          success: xdr.lookup("PathPaymentStrictReceiveResultSuccess"),
          noIssuer: xdr.lookup("Asset")
        }
      });
      xdr["enum"]("PathPaymentStrictSendResultCode", {
        pathPaymentStrictSendSuccess: 0,
        pathPaymentStrictSendMalformed: -1,
        pathPaymentStrictSendUnderfunded: -2,
        pathPaymentStrictSendSrcNoTrust: -3,
        pathPaymentStrictSendSrcNotAuthorized: -4,
        pathPaymentStrictSendNoDestination: -5,
        pathPaymentStrictSendNoTrust: -6,
        pathPaymentStrictSendNotAuthorized: -7,
        pathPaymentStrictSendLineFull: -8,
        pathPaymentStrictSendNoIssuer: -9,
        pathPaymentStrictSendTooFewOffers: -10,
        pathPaymentStrictSendOfferCrossSelf: -11,
        pathPaymentStrictSendUnderDestmin: -12
      });
      xdr.struct("PathPaymentStrictSendResultSuccess", [["offers", xdr.varArray(xdr.lookup("ClaimAtom"), 2147483647)], ["last", xdr.lookup("SimplePaymentResult")]]);
      xdr.union("PathPaymentStrictSendResult", {
        switchOn: xdr.lookup("PathPaymentStrictSendResultCode"),
        switchName: "code",
        switches: [["pathPaymentStrictSendSuccess", "success"], ["pathPaymentStrictSendMalformed", xdr["void"]()], ["pathPaymentStrictSendUnderfunded", xdr["void"]()], ["pathPaymentStrictSendSrcNoTrust", xdr["void"]()], ["pathPaymentStrictSendSrcNotAuthorized", xdr["void"]()], ["pathPaymentStrictSendNoDestination", xdr["void"]()], ["pathPaymentStrictSendNoTrust", xdr["void"]()], ["pathPaymentStrictSendNotAuthorized", xdr["void"]()], ["pathPaymentStrictSendLineFull", xdr["void"]()], ["pathPaymentStrictSendNoIssuer", "noIssuer"], ["pathPaymentStrictSendTooFewOffers", xdr["void"]()], ["pathPaymentStrictSendOfferCrossSelf", xdr["void"]()], ["pathPaymentStrictSendUnderDestmin", xdr["void"]()]],
        arms: {
          success: xdr.lookup("PathPaymentStrictSendResultSuccess"),
          noIssuer: xdr.lookup("Asset")
        }
      });
      xdr["enum"]("ManageSellOfferResultCode", {
        manageSellOfferSuccess: 0,
        manageSellOfferMalformed: -1,
        manageSellOfferSellNoTrust: -2,
        manageSellOfferBuyNoTrust: -3,
        manageSellOfferSellNotAuthorized: -4,
        manageSellOfferBuyNotAuthorized: -5,
        manageSellOfferLineFull: -6,
        manageSellOfferUnderfunded: -7,
        manageSellOfferCrossSelf: -8,
        manageSellOfferSellNoIssuer: -9,
        manageSellOfferBuyNoIssuer: -10,
        manageSellOfferNotFound: -11,
        manageSellOfferLowReserve: -12
      });
      xdr["enum"]("ManageOfferEffect", {
        manageOfferCreated: 0,
        manageOfferUpdated: 1,
        manageOfferDeleted: 2
      });
      xdr.union("ManageOfferSuccessResultOffer", {
        switchOn: xdr.lookup("ManageOfferEffect"),
        switchName: "effect",
        switches: [["manageOfferCreated", "offer"], ["manageOfferUpdated", "offer"], ["manageOfferDeleted", xdr["void"]()]],
        arms: {
          offer: xdr.lookup("OfferEntry")
        }
      });
      xdr.struct("ManageOfferSuccessResult", [["offersClaimed", xdr.varArray(xdr.lookup("ClaimAtom"), 2147483647)], ["offer", xdr.lookup("ManageOfferSuccessResultOffer")]]);
      xdr.union("ManageSellOfferResult", {
        switchOn: xdr.lookup("ManageSellOfferResultCode"),
        switchName: "code",
        switches: [["manageSellOfferSuccess", "success"], ["manageSellOfferMalformed", xdr["void"]()], ["manageSellOfferSellNoTrust", xdr["void"]()], ["manageSellOfferBuyNoTrust", xdr["void"]()], ["manageSellOfferSellNotAuthorized", xdr["void"]()], ["manageSellOfferBuyNotAuthorized", xdr["void"]()], ["manageSellOfferLineFull", xdr["void"]()], ["manageSellOfferUnderfunded", xdr["void"]()], ["manageSellOfferCrossSelf", xdr["void"]()], ["manageSellOfferSellNoIssuer", xdr["void"]()], ["manageSellOfferBuyNoIssuer", xdr["void"]()], ["manageSellOfferNotFound", xdr["void"]()], ["manageSellOfferLowReserve", xdr["void"]()]],
        arms: {
          success: xdr.lookup("ManageOfferSuccessResult")
        }
      });
      xdr["enum"]("ManageBuyOfferResultCode", {
        manageBuyOfferSuccess: 0,
        manageBuyOfferMalformed: -1,
        manageBuyOfferSellNoTrust: -2,
        manageBuyOfferBuyNoTrust: -3,
        manageBuyOfferSellNotAuthorized: -4,
        manageBuyOfferBuyNotAuthorized: -5,
        manageBuyOfferLineFull: -6,
        manageBuyOfferUnderfunded: -7,
        manageBuyOfferCrossSelf: -8,
        manageBuyOfferSellNoIssuer: -9,
        manageBuyOfferBuyNoIssuer: -10,
        manageBuyOfferNotFound: -11,
        manageBuyOfferLowReserve: -12
      });
      xdr.union("ManageBuyOfferResult", {
        switchOn: xdr.lookup("ManageBuyOfferResultCode"),
        switchName: "code",
        switches: [["manageBuyOfferSuccess", "success"], ["manageBuyOfferMalformed", xdr["void"]()], ["manageBuyOfferSellNoTrust", xdr["void"]()], ["manageBuyOfferBuyNoTrust", xdr["void"]()], ["manageBuyOfferSellNotAuthorized", xdr["void"]()], ["manageBuyOfferBuyNotAuthorized", xdr["void"]()], ["manageBuyOfferLineFull", xdr["void"]()], ["manageBuyOfferUnderfunded", xdr["void"]()], ["manageBuyOfferCrossSelf", xdr["void"]()], ["manageBuyOfferSellNoIssuer", xdr["void"]()], ["manageBuyOfferBuyNoIssuer", xdr["void"]()], ["manageBuyOfferNotFound", xdr["void"]()], ["manageBuyOfferLowReserve", xdr["void"]()]],
        arms: {
          success: xdr.lookup("ManageOfferSuccessResult")
        }
      });
      xdr["enum"]("SetOptionsResultCode", {
        setOptionsSuccess: 0,
        setOptionsLowReserve: -1,
        setOptionsTooManySigners: -2,
        setOptionsBadFlags: -3,
        setOptionsInvalidInflation: -4,
        setOptionsCantChange: -5,
        setOptionsUnknownFlag: -6,
        setOptionsThresholdOutOfRange: -7,
        setOptionsBadSigner: -8,
        setOptionsInvalidHomeDomain: -9,
        setOptionsAuthRevocableRequired: -10
      });
      xdr.union("SetOptionsResult", {
        switchOn: xdr.lookup("SetOptionsResultCode"),
        switchName: "code",
        switches: [["setOptionsSuccess", xdr["void"]()], ["setOptionsLowReserve", xdr["void"]()], ["setOptionsTooManySigners", xdr["void"]()], ["setOptionsBadFlags", xdr["void"]()], ["setOptionsInvalidInflation", xdr["void"]()], ["setOptionsCantChange", xdr["void"]()], ["setOptionsUnknownFlag", xdr["void"]()], ["setOptionsThresholdOutOfRange", xdr["void"]()], ["setOptionsBadSigner", xdr["void"]()], ["setOptionsInvalidHomeDomain", xdr["void"]()], ["setOptionsAuthRevocableRequired", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("ChangeTrustResultCode", {
        changeTrustSuccess: 0,
        changeTrustMalformed: -1,
        changeTrustNoIssuer: -2,
        changeTrustInvalidLimit: -3,
        changeTrustLowReserve: -4,
        changeTrustSelfNotAllowed: -5,
        changeTrustTrustLineMissing: -6,
        changeTrustCannotDelete: -7,
        changeTrustNotAuthMaintainLiabilities: -8
      });
      xdr.union("ChangeTrustResult", {
        switchOn: xdr.lookup("ChangeTrustResultCode"),
        switchName: "code",
        switches: [["changeTrustSuccess", xdr["void"]()], ["changeTrustMalformed", xdr["void"]()], ["changeTrustNoIssuer", xdr["void"]()], ["changeTrustInvalidLimit", xdr["void"]()], ["changeTrustLowReserve", xdr["void"]()], ["changeTrustSelfNotAllowed", xdr["void"]()], ["changeTrustTrustLineMissing", xdr["void"]()], ["changeTrustCannotDelete", xdr["void"]()], ["changeTrustNotAuthMaintainLiabilities", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("AllowTrustResultCode", {
        allowTrustSuccess: 0,
        allowTrustMalformed: -1,
        allowTrustNoTrustLine: -2,
        allowTrustTrustNotRequired: -3,
        allowTrustCantRevoke: -4,
        allowTrustSelfNotAllowed: -5,
        allowTrustLowReserve: -6
      });
      xdr.union("AllowTrustResult", {
        switchOn: xdr.lookup("AllowTrustResultCode"),
        switchName: "code",
        switches: [["allowTrustSuccess", xdr["void"]()], ["allowTrustMalformed", xdr["void"]()], ["allowTrustNoTrustLine", xdr["void"]()], ["allowTrustTrustNotRequired", xdr["void"]()], ["allowTrustCantRevoke", xdr["void"]()], ["allowTrustSelfNotAllowed", xdr["void"]()], ["allowTrustLowReserve", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("AccountMergeResultCode", {
        accountMergeSuccess: 0,
        accountMergeMalformed: -1,
        accountMergeNoAccount: -2,
        accountMergeImmutableSet: -3,
        accountMergeHasSubEntries: -4,
        accountMergeSeqnumTooFar: -5,
        accountMergeDestFull: -6,
        accountMergeIsSponsor: -7
      });
      xdr.union("AccountMergeResult", {
        switchOn: xdr.lookup("AccountMergeResultCode"),
        switchName: "code",
        switches: [["accountMergeSuccess", "sourceAccountBalance"], ["accountMergeMalformed", xdr["void"]()], ["accountMergeNoAccount", xdr["void"]()], ["accountMergeImmutableSet", xdr["void"]()], ["accountMergeHasSubEntries", xdr["void"]()], ["accountMergeSeqnumTooFar", xdr["void"]()], ["accountMergeDestFull", xdr["void"]()], ["accountMergeIsSponsor", xdr["void"]()]],
        arms: {
          sourceAccountBalance: xdr.lookup("Int64")
        }
      });
      xdr["enum"]("InflationResultCode", {
        inflationSuccess: 0,
        inflationNotTime: -1
      });
      xdr.struct("InflationPayout", [["destination", xdr.lookup("AccountId")], ["amount", xdr.lookup("Int64")]]);
      xdr.union("InflationResult", {
        switchOn: xdr.lookup("InflationResultCode"),
        switchName: "code",
        switches: [["inflationSuccess", "payouts"], ["inflationNotTime", xdr["void"]()]],
        arms: {
          payouts: xdr.varArray(xdr.lookup("InflationPayout"), 2147483647)
        }
      });
      xdr["enum"]("ManageDataResultCode", {
        manageDataSuccess: 0,
        manageDataNotSupportedYet: -1,
        manageDataNameNotFound: -2,
        manageDataLowReserve: -3,
        manageDataInvalidName: -4
      });
      xdr.union("ManageDataResult", {
        switchOn: xdr.lookup("ManageDataResultCode"),
        switchName: "code",
        switches: [["manageDataSuccess", xdr["void"]()], ["manageDataNotSupportedYet", xdr["void"]()], ["manageDataNameNotFound", xdr["void"]()], ["manageDataLowReserve", xdr["void"]()], ["manageDataInvalidName", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("BumpSequenceResultCode", {
        bumpSequenceSuccess: 0,
        bumpSequenceBadSeq: -1
      });
      xdr.union("BumpSequenceResult", {
        switchOn: xdr.lookup("BumpSequenceResultCode"),
        switchName: "code",
        switches: [["bumpSequenceSuccess", xdr["void"]()], ["bumpSequenceBadSeq", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("CreateClaimableBalanceResultCode", {
        createClaimableBalanceSuccess: 0,
        createClaimableBalanceMalformed: -1,
        createClaimableBalanceLowReserve: -2,
        createClaimableBalanceNoTrust: -3,
        createClaimableBalanceNotAuthorized: -4,
        createClaimableBalanceUnderfunded: -5
      });
      xdr.union("CreateClaimableBalanceResult", {
        switchOn: xdr.lookup("CreateClaimableBalanceResultCode"),
        switchName: "code",
        switches: [["createClaimableBalanceSuccess", "balanceId"], ["createClaimableBalanceMalformed", xdr["void"]()], ["createClaimableBalanceLowReserve", xdr["void"]()], ["createClaimableBalanceNoTrust", xdr["void"]()], ["createClaimableBalanceNotAuthorized", xdr["void"]()], ["createClaimableBalanceUnderfunded", xdr["void"]()]],
        arms: {
          balanceId: xdr.lookup("ClaimableBalanceId")
        }
      });
      xdr["enum"]("ClaimClaimableBalanceResultCode", {
        claimClaimableBalanceSuccess: 0,
        claimClaimableBalanceDoesNotExist: -1,
        claimClaimableBalanceCannotClaim: -2,
        claimClaimableBalanceLineFull: -3,
        claimClaimableBalanceNoTrust: -4,
        claimClaimableBalanceNotAuthorized: -5
      });
      xdr.union("ClaimClaimableBalanceResult", {
        switchOn: xdr.lookup("ClaimClaimableBalanceResultCode"),
        switchName: "code",
        switches: [["claimClaimableBalanceSuccess", xdr["void"]()], ["claimClaimableBalanceDoesNotExist", xdr["void"]()], ["claimClaimableBalanceCannotClaim", xdr["void"]()], ["claimClaimableBalanceLineFull", xdr["void"]()], ["claimClaimableBalanceNoTrust", xdr["void"]()], ["claimClaimableBalanceNotAuthorized", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("BeginSponsoringFutureReservesResultCode", {
        beginSponsoringFutureReservesSuccess: 0,
        beginSponsoringFutureReservesMalformed: -1,
        beginSponsoringFutureReservesAlreadySponsored: -2,
        beginSponsoringFutureReservesRecursive: -3
      });
      xdr.union("BeginSponsoringFutureReservesResult", {
        switchOn: xdr.lookup("BeginSponsoringFutureReservesResultCode"),
        switchName: "code",
        switches: [["beginSponsoringFutureReservesSuccess", xdr["void"]()], ["beginSponsoringFutureReservesMalformed", xdr["void"]()], ["beginSponsoringFutureReservesAlreadySponsored", xdr["void"]()], ["beginSponsoringFutureReservesRecursive", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("EndSponsoringFutureReservesResultCode", {
        endSponsoringFutureReservesSuccess: 0,
        endSponsoringFutureReservesNotSponsored: -1
      });
      xdr.union("EndSponsoringFutureReservesResult", {
        switchOn: xdr.lookup("EndSponsoringFutureReservesResultCode"),
        switchName: "code",
        switches: [["endSponsoringFutureReservesSuccess", xdr["void"]()], ["endSponsoringFutureReservesNotSponsored", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("RevokeSponsorshipResultCode", {
        revokeSponsorshipSuccess: 0,
        revokeSponsorshipDoesNotExist: -1,
        revokeSponsorshipNotSponsor: -2,
        revokeSponsorshipLowReserve: -3,
        revokeSponsorshipOnlyTransferable: -4,
        revokeSponsorshipMalformed: -5
      });
      xdr.union("RevokeSponsorshipResult", {
        switchOn: xdr.lookup("RevokeSponsorshipResultCode"),
        switchName: "code",
        switches: [["revokeSponsorshipSuccess", xdr["void"]()], ["revokeSponsorshipDoesNotExist", xdr["void"]()], ["revokeSponsorshipNotSponsor", xdr["void"]()], ["revokeSponsorshipLowReserve", xdr["void"]()], ["revokeSponsorshipOnlyTransferable", xdr["void"]()], ["revokeSponsorshipMalformed", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("ClawbackResultCode", {
        clawbackSuccess: 0,
        clawbackMalformed: -1,
        clawbackNotClawbackEnabled: -2,
        clawbackNoTrust: -3,
        clawbackUnderfunded: -4
      });
      xdr.union("ClawbackResult", {
        switchOn: xdr.lookup("ClawbackResultCode"),
        switchName: "code",
        switches: [["clawbackSuccess", xdr["void"]()], ["clawbackMalformed", xdr["void"]()], ["clawbackNotClawbackEnabled", xdr["void"]()], ["clawbackNoTrust", xdr["void"]()], ["clawbackUnderfunded", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("ClawbackClaimableBalanceResultCode", {
        clawbackClaimableBalanceSuccess: 0,
        clawbackClaimableBalanceDoesNotExist: -1,
        clawbackClaimableBalanceNotIssuer: -2,
        clawbackClaimableBalanceNotClawbackEnabled: -3
      });
      xdr.union("ClawbackClaimableBalanceResult", {
        switchOn: xdr.lookup("ClawbackClaimableBalanceResultCode"),
        switchName: "code",
        switches: [["clawbackClaimableBalanceSuccess", xdr["void"]()], ["clawbackClaimableBalanceDoesNotExist", xdr["void"]()], ["clawbackClaimableBalanceNotIssuer", xdr["void"]()], ["clawbackClaimableBalanceNotClawbackEnabled", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("SetTrustLineFlagsResultCode", {
        setTrustLineFlagsSuccess: 0,
        setTrustLineFlagsMalformed: -1,
        setTrustLineFlagsNoTrustLine: -2,
        setTrustLineFlagsCantRevoke: -3,
        setTrustLineFlagsInvalidState: -4,
        setTrustLineFlagsLowReserve: -5
      });
      xdr.union("SetTrustLineFlagsResult", {
        switchOn: xdr.lookup("SetTrustLineFlagsResultCode"),
        switchName: "code",
        switches: [["setTrustLineFlagsSuccess", xdr["void"]()], ["setTrustLineFlagsMalformed", xdr["void"]()], ["setTrustLineFlagsNoTrustLine", xdr["void"]()], ["setTrustLineFlagsCantRevoke", xdr["void"]()], ["setTrustLineFlagsInvalidState", xdr["void"]()], ["setTrustLineFlagsLowReserve", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("LiquidityPoolDepositResultCode", {
        liquidityPoolDepositSuccess: 0,
        liquidityPoolDepositMalformed: -1,
        liquidityPoolDepositNoTrust: -2,
        liquidityPoolDepositNotAuthorized: -3,
        liquidityPoolDepositUnderfunded: -4,
        liquidityPoolDepositLineFull: -5,
        liquidityPoolDepositBadPrice: -6,
        liquidityPoolDepositPoolFull: -7
      });
      xdr.union("LiquidityPoolDepositResult", {
        switchOn: xdr.lookup("LiquidityPoolDepositResultCode"),
        switchName: "code",
        switches: [["liquidityPoolDepositSuccess", xdr["void"]()], ["liquidityPoolDepositMalformed", xdr["void"]()], ["liquidityPoolDepositNoTrust", xdr["void"]()], ["liquidityPoolDepositNotAuthorized", xdr["void"]()], ["liquidityPoolDepositUnderfunded", xdr["void"]()], ["liquidityPoolDepositLineFull", xdr["void"]()], ["liquidityPoolDepositBadPrice", xdr["void"]()], ["liquidityPoolDepositPoolFull", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("LiquidityPoolWithdrawResultCode", {
        liquidityPoolWithdrawSuccess: 0,
        liquidityPoolWithdrawMalformed: -1,
        liquidityPoolWithdrawNoTrust: -2,
        liquidityPoolWithdrawUnderfunded: -3,
        liquidityPoolWithdrawLineFull: -4,
        liquidityPoolWithdrawUnderMinimum: -5
      });
      xdr.union("LiquidityPoolWithdrawResult", {
        switchOn: xdr.lookup("LiquidityPoolWithdrawResultCode"),
        switchName: "code",
        switches: [["liquidityPoolWithdrawSuccess", xdr["void"]()], ["liquidityPoolWithdrawMalformed", xdr["void"]()], ["liquidityPoolWithdrawNoTrust", xdr["void"]()], ["liquidityPoolWithdrawUnderfunded", xdr["void"]()], ["liquidityPoolWithdrawLineFull", xdr["void"]()], ["liquidityPoolWithdrawUnderMinimum", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("InvokeHostFunctionResultCode", {
        invokeHostFunctionSuccess: 0,
        invokeHostFunctionMalformed: -1,
        invokeHostFunctionTrapped: -2,
        invokeHostFunctionResourceLimitExceeded: -3,
        invokeHostFunctionEntryArchived: -4,
        invokeHostFunctionInsufficientRefundableFee: -5
      });
      xdr.union("InvokeHostFunctionResult", {
        switchOn: xdr.lookup("InvokeHostFunctionResultCode"),
        switchName: "code",
        switches: [["invokeHostFunctionSuccess", "success"], ["invokeHostFunctionMalformed", xdr["void"]()], ["invokeHostFunctionTrapped", xdr["void"]()], ["invokeHostFunctionResourceLimitExceeded", xdr["void"]()], ["invokeHostFunctionEntryArchived", xdr["void"]()], ["invokeHostFunctionInsufficientRefundableFee", xdr["void"]()]],
        arms: {
          success: xdr.lookup("Hash")
        }
      });
      xdr["enum"]("ExtendFootprintTtlResultCode", {
        extendFootprintTtlSuccess: 0,
        extendFootprintTtlMalformed: -1,
        extendFootprintTtlResourceLimitExceeded: -2,
        extendFootprintTtlInsufficientRefundableFee: -3
      });
      xdr.union("ExtendFootprintTtlResult", {
        switchOn: xdr.lookup("ExtendFootprintTtlResultCode"),
        switchName: "code",
        switches: [["extendFootprintTtlSuccess", xdr["void"]()], ["extendFootprintTtlMalformed", xdr["void"]()], ["extendFootprintTtlResourceLimitExceeded", xdr["void"]()], ["extendFootprintTtlInsufficientRefundableFee", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("RestoreFootprintResultCode", {
        restoreFootprintSuccess: 0,
        restoreFootprintMalformed: -1,
        restoreFootprintResourceLimitExceeded: -2,
        restoreFootprintInsufficientRefundableFee: -3
      });
      xdr.union("RestoreFootprintResult", {
        switchOn: xdr.lookup("RestoreFootprintResultCode"),
        switchName: "code",
        switches: [["restoreFootprintSuccess", xdr["void"]()], ["restoreFootprintMalformed", xdr["void"]()], ["restoreFootprintResourceLimitExceeded", xdr["void"]()], ["restoreFootprintInsufficientRefundableFee", xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("OperationResultCode", {
        opInner: 0,
        opBadAuth: -1,
        opNoAccount: -2,
        opNotSupported: -3,
        opTooManySubentries: -4,
        opExceededWorkLimit: -5,
        opTooManySponsoring: -6
      });
      xdr.union("OperationResultTr", {
        switchOn: xdr.lookup("OperationType"),
        switchName: "type",
        switches: [["createAccount", "createAccountResult"], ["payment", "paymentResult"], ["pathPaymentStrictReceive", "pathPaymentStrictReceiveResult"], ["manageSellOffer", "manageSellOfferResult"], ["createPassiveSellOffer", "createPassiveSellOfferResult"], ["setOptions", "setOptionsResult"], ["changeTrust", "changeTrustResult"], ["allowTrust", "allowTrustResult"], ["accountMerge", "accountMergeResult"], ["inflation", "inflationResult"], ["manageData", "manageDataResult"], ["bumpSequence", "bumpSeqResult"], ["manageBuyOffer", "manageBuyOfferResult"], ["pathPaymentStrictSend", "pathPaymentStrictSendResult"], ["createClaimableBalance", "createClaimableBalanceResult"], ["claimClaimableBalance", "claimClaimableBalanceResult"], ["beginSponsoringFutureReserves", "beginSponsoringFutureReservesResult"], ["endSponsoringFutureReserves", "endSponsoringFutureReservesResult"], ["revokeSponsorship", "revokeSponsorshipResult"], ["clawback", "clawbackResult"], ["clawbackClaimableBalance", "clawbackClaimableBalanceResult"], ["setTrustLineFlags", "setTrustLineFlagsResult"], ["liquidityPoolDeposit", "liquidityPoolDepositResult"], ["liquidityPoolWithdraw", "liquidityPoolWithdrawResult"], ["invokeHostFunction", "invokeHostFunctionResult"], ["extendFootprintTtl", "extendFootprintTtlResult"], ["restoreFootprint", "restoreFootprintResult"]],
        arms: {
          createAccountResult: xdr.lookup("CreateAccountResult"),
          paymentResult: xdr.lookup("PaymentResult"),
          pathPaymentStrictReceiveResult: xdr.lookup("PathPaymentStrictReceiveResult"),
          manageSellOfferResult: xdr.lookup("ManageSellOfferResult"),
          createPassiveSellOfferResult: xdr.lookup("ManageSellOfferResult"),
          setOptionsResult: xdr.lookup("SetOptionsResult"),
          changeTrustResult: xdr.lookup("ChangeTrustResult"),
          allowTrustResult: xdr.lookup("AllowTrustResult"),
          accountMergeResult: xdr.lookup("AccountMergeResult"),
          inflationResult: xdr.lookup("InflationResult"),
          manageDataResult: xdr.lookup("ManageDataResult"),
          bumpSeqResult: xdr.lookup("BumpSequenceResult"),
          manageBuyOfferResult: xdr.lookup("ManageBuyOfferResult"),
          pathPaymentStrictSendResult: xdr.lookup("PathPaymentStrictSendResult"),
          createClaimableBalanceResult: xdr.lookup("CreateClaimableBalanceResult"),
          claimClaimableBalanceResult: xdr.lookup("ClaimClaimableBalanceResult"),
          beginSponsoringFutureReservesResult: xdr.lookup("BeginSponsoringFutureReservesResult"),
          endSponsoringFutureReservesResult: xdr.lookup("EndSponsoringFutureReservesResult"),
          revokeSponsorshipResult: xdr.lookup("RevokeSponsorshipResult"),
          clawbackResult: xdr.lookup("ClawbackResult"),
          clawbackClaimableBalanceResult: xdr.lookup("ClawbackClaimableBalanceResult"),
          setTrustLineFlagsResult: xdr.lookup("SetTrustLineFlagsResult"),
          liquidityPoolDepositResult: xdr.lookup("LiquidityPoolDepositResult"),
          liquidityPoolWithdrawResult: xdr.lookup("LiquidityPoolWithdrawResult"),
          invokeHostFunctionResult: xdr.lookup("InvokeHostFunctionResult"),
          extendFootprintTtlResult: xdr.lookup("ExtendFootprintTtlResult"),
          restoreFootprintResult: xdr.lookup("RestoreFootprintResult")
        }
      });
      xdr.union("OperationResult", {
        switchOn: xdr.lookup("OperationResultCode"),
        switchName: "code",
        switches: [["opInner", "tr"], ["opBadAuth", xdr["void"]()], ["opNoAccount", xdr["void"]()], ["opNotSupported", xdr["void"]()], ["opTooManySubentries", xdr["void"]()], ["opExceededWorkLimit", xdr["void"]()], ["opTooManySponsoring", xdr["void"]()]],
        arms: {
          tr: xdr.lookup("OperationResultTr")
        }
      });
      xdr["enum"]("TransactionResultCode", {
        txFeeBumpInnerSuccess: 1,
        txSuccess: 0,
        txFailed: -1,
        txTooEarly: -2,
        txTooLate: -3,
        txMissingOperation: -4,
        txBadSeq: -5,
        txBadAuth: -6,
        txInsufficientBalance: -7,
        txNoAccount: -8,
        txInsufficientFee: -9,
        txBadAuthExtra: -10,
        txInternalError: -11,
        txNotSupported: -12,
        txFeeBumpInnerFailed: -13,
        txBadSponsorship: -14,
        txBadMinSeqAgeOrGap: -15,
        txMalformed: -16,
        txSorobanInvalid: -17
      });
      xdr.union("InnerTransactionResultResult", {
        switchOn: xdr.lookup("TransactionResultCode"),
        switchName: "code",
        switches: [["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", xdr["void"]()], ["txTooLate", xdr["void"]()], ["txMissingOperation", xdr["void"]()], ["txBadSeq", xdr["void"]()], ["txBadAuth", xdr["void"]()], ["txInsufficientBalance", xdr["void"]()], ["txNoAccount", xdr["void"]()], ["txInsufficientFee", xdr["void"]()], ["txBadAuthExtra", xdr["void"]()], ["txInternalError", xdr["void"]()], ["txNotSupported", xdr["void"]()], ["txBadSponsorship", xdr["void"]()], ["txBadMinSeqAgeOrGap", xdr["void"]()], ["txMalformed", xdr["void"]()], ["txSorobanInvalid", xdr["void"]()]],
        arms: {
          results: xdr.varArray(xdr.lookup("OperationResult"), 2147483647)
        }
      });
      xdr.union("InnerTransactionResultExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr.struct("InnerTransactionResult", [["feeCharged", xdr.lookup("Int64")], ["result", xdr.lookup("InnerTransactionResultResult")], ["ext", xdr.lookup("InnerTransactionResultExt")]]);
      xdr.struct("InnerTransactionResultPair", [["transactionHash", xdr.lookup("Hash")], ["result", xdr.lookup("InnerTransactionResult")]]);
      xdr.union("TransactionResultResult", {
        switchOn: xdr.lookup("TransactionResultCode"),
        switchName: "code",
        switches: [["txFeeBumpInnerSuccess", "innerResultPair"], ["txFeeBumpInnerFailed", "innerResultPair"], ["txSuccess", "results"], ["txFailed", "results"], ["txTooEarly", xdr["void"]()], ["txTooLate", xdr["void"]()], ["txMissingOperation", xdr["void"]()], ["txBadSeq", xdr["void"]()], ["txBadAuth", xdr["void"]()], ["txInsufficientBalance", xdr["void"]()], ["txNoAccount", xdr["void"]()], ["txInsufficientFee", xdr["void"]()], ["txBadAuthExtra", xdr["void"]()], ["txInternalError", xdr["void"]()], ["txNotSupported", xdr["void"]()], ["txBadSponsorship", xdr["void"]()], ["txBadMinSeqAgeOrGap", xdr["void"]()], ["txMalformed", xdr["void"]()], ["txSorobanInvalid", xdr["void"]()]],
        arms: {
          innerResultPair: xdr.lookup("InnerTransactionResultPair"),
          results: xdr.varArray(xdr.lookup("OperationResult"), 2147483647)
        }
      });
      xdr.union("TransactionResultExt", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr.struct("TransactionResult", [["feeCharged", xdr.lookup("Int64")], ["result", xdr.lookup("TransactionResultResult")], ["ext", xdr.lookup("TransactionResultExt")]]);
      xdr.typedef("Hash", xdr.opaque(32));
      xdr.typedef("Uint256", xdr.opaque(32));
      xdr.typedef("Uint32", xdr.uint());
      xdr.typedef("Int32", xdr["int"]());
      xdr.typedef("Uint64", xdr.uhyper());
      xdr.typedef("Int64", xdr.hyper());
      xdr.typedef("TimePoint", xdr.lookup("Uint64"));
      xdr.typedef("Duration", xdr.lookup("Uint64"));
      xdr.union("ExtensionPoint", {
        switchOn: xdr["int"](),
        switchName: "v",
        switches: [[0, xdr["void"]()]],
        arms: {}
      });
      xdr["enum"]("CryptoKeyType", {
        keyTypeEd25519: 0,
        keyTypePreAuthTx: 1,
        keyTypeHashX: 2,
        keyTypeEd25519SignedPayload: 3,
        keyTypeMuxedEd25519: 256
      });
      xdr["enum"]("PublicKeyType", {
        publicKeyTypeEd25519: 0
      });
      xdr["enum"]("SignerKeyType", {
        signerKeyTypeEd25519: 0,
        signerKeyTypePreAuthTx: 1,
        signerKeyTypeHashX: 2,
        signerKeyTypeEd25519SignedPayload: 3
      });
      xdr.union("PublicKey", {
        switchOn: xdr.lookup("PublicKeyType"),
        switchName: "type",
        switches: [["publicKeyTypeEd25519", "ed25519"]],
        arms: {
          ed25519: xdr.lookup("Uint256")
        }
      });
      xdr.struct("SignerKeyEd25519SignedPayload", [["ed25519", xdr.lookup("Uint256")], ["payload", xdr.varOpaque(64)]]);
      xdr.union("SignerKey", {
        switchOn: xdr.lookup("SignerKeyType"),
        switchName: "type",
        switches: [["signerKeyTypeEd25519", "ed25519"], ["signerKeyTypePreAuthTx", "preAuthTx"], ["signerKeyTypeHashX", "hashX"], ["signerKeyTypeEd25519SignedPayload", "ed25519SignedPayload"]],
        arms: {
          ed25519: xdr.lookup("Uint256"),
          preAuthTx: xdr.lookup("Uint256"),
          hashX: xdr.lookup("Uint256"),
          ed25519SignedPayload: xdr.lookup("SignerKeyEd25519SignedPayload")
        }
      });
      xdr.typedef("Signature", xdr.varOpaque(64));
      xdr.typedef("SignatureHint", xdr.opaque(4));
      xdr.typedef("NodeId", xdr.lookup("PublicKey"));
      xdr.typedef("AccountId", xdr.lookup("PublicKey"));
      xdr.struct("Curve25519Secret", [["key", xdr.opaque(32)]]);
      xdr.struct("Curve25519Public", [["key", xdr.opaque(32)]]);
      xdr.struct("HmacSha256Key", [["key", xdr.opaque(32)]]);
      xdr.struct("HmacSha256Mac", [["mac", xdr.opaque(32)]]);
      xdr.struct("ShortHashSeed", [["seed", xdr.opaque(16)]]);
      xdr["enum"]("BinaryFuseFilterType", {
        binaryFuseFilter8Bit: 0,
        binaryFuseFilter16Bit: 1,
        binaryFuseFilter32Bit: 2
      });
      xdr.struct("SerializedBinaryFuseFilter", [["type", xdr.lookup("BinaryFuseFilterType")], ["inputHashSeed", xdr.lookup("ShortHashSeed")], ["filterSeed", xdr.lookup("ShortHashSeed")], ["segmentLength", xdr.lookup("Uint32")], ["segementLengthMask", xdr.lookup("Uint32")], ["segmentCount", xdr.lookup("Uint32")], ["segmentCountLength", xdr.lookup("Uint32")], ["fingerprintLength", xdr.lookup("Uint32")], ["fingerprints", xdr.varOpaque()]]);
      xdr["enum"]("ScValType", {
        scvBool: 0,
        scvVoid: 1,
        scvError: 2,
        scvU32: 3,
        scvI32: 4,
        scvU64: 5,
        scvI64: 6,
        scvTimepoint: 7,
        scvDuration: 8,
        scvU128: 9,
        scvI128: 10,
        scvU256: 11,
        scvI256: 12,
        scvBytes: 13,
        scvString: 14,
        scvSymbol: 15,
        scvVec: 16,
        scvMap: 17,
        scvAddress: 18,
        scvContractInstance: 19,
        scvLedgerKeyContractInstance: 20,
        scvLedgerKeyNonce: 21
      });
      xdr["enum"]("ScErrorType", {
        sceContract: 0,
        sceWasmVm: 1,
        sceContext: 2,
        sceStorage: 3,
        sceObject: 4,
        sceCrypto: 5,
        sceEvents: 6,
        sceBudget: 7,
        sceValue: 8,
        sceAuth: 9
      });
      xdr["enum"]("ScErrorCode", {
        scecArithDomain: 0,
        scecIndexBounds: 1,
        scecInvalidInput: 2,
        scecMissingValue: 3,
        scecExistingValue: 4,
        scecExceededLimit: 5,
        scecInvalidAction: 6,
        scecInternalError: 7,
        scecUnexpectedType: 8,
        scecUnexpectedSize: 9
      });
      xdr.union("ScError", {
        switchOn: xdr.lookup("ScErrorType"),
        switchName: "type",
        switches: [["sceContract", "contractCode"], ["sceWasmVm", "code"], ["sceContext", "code"], ["sceStorage", "code"], ["sceObject", "code"], ["sceCrypto", "code"], ["sceEvents", "code"], ["sceBudget", "code"], ["sceValue", "code"], ["sceAuth", "code"]],
        arms: {
          contractCode: xdr.lookup("Uint32"),
          code: xdr.lookup("ScErrorCode")
        }
      });
      xdr.struct("UInt128Parts", [["hi", xdr.lookup("Uint64")], ["lo", xdr.lookup("Uint64")]]);
      xdr.struct("Int128Parts", [["hi", xdr.lookup("Int64")], ["lo", xdr.lookup("Uint64")]]);
      xdr.struct("UInt256Parts", [["hiHi", xdr.lookup("Uint64")], ["hiLo", xdr.lookup("Uint64")], ["loHi", xdr.lookup("Uint64")], ["loLo", xdr.lookup("Uint64")]]);
      xdr.struct("Int256Parts", [["hiHi", xdr.lookup("Int64")], ["hiLo", xdr.lookup("Uint64")], ["loHi", xdr.lookup("Uint64")], ["loLo", xdr.lookup("Uint64")]]);
      xdr["enum"]("ContractExecutableType", {
        contractExecutableWasm: 0,
        contractExecutableStellarAsset: 1
      });
      xdr.union("ContractExecutable", {
        switchOn: xdr.lookup("ContractExecutableType"),
        switchName: "type",
        switches: [["contractExecutableWasm", "wasmHash"], ["contractExecutableStellarAsset", xdr["void"]()]],
        arms: {
          wasmHash: xdr.lookup("Hash")
        }
      });
      xdr["enum"]("ScAddressType", {
        scAddressTypeAccount: 0,
        scAddressTypeContract: 1
      });
      xdr.union("ScAddress", {
        switchOn: xdr.lookup("ScAddressType"),
        switchName: "type",
        switches: [["scAddressTypeAccount", "accountId"], ["scAddressTypeContract", "contractId"]],
        arms: {
          accountId: xdr.lookup("AccountId"),
          contractId: xdr.lookup("Hash")
        }
      });
      xdr["const"]("SCSYMBOL_LIMIT", 32);
      xdr.typedef("ScVec", xdr.varArray(xdr.lookup("ScVal"), 2147483647));
      xdr.typedef("ScMap", xdr.varArray(xdr.lookup("ScMapEntry"), 2147483647));
      xdr.typedef("ScBytes", xdr.varOpaque());
      xdr.typedef("ScString", xdr.string());
      xdr.typedef("ScSymbol", xdr.string(SCSYMBOL_LIMIT));
      xdr.struct("ScNonceKey", [["nonce", xdr.lookup("Int64")]]);
      xdr.struct("ScContractInstance", [["executable", xdr.lookup("ContractExecutable")], ["storage", xdr.option(xdr.lookup("ScMap"))]]);
      xdr.union("ScVal", {
        switchOn: xdr.lookup("ScValType"),
        switchName: "type",
        switches: [["scvBool", "b"], ["scvVoid", xdr["void"]()], ["scvError", "error"], ["scvU32", "u32"], ["scvI32", "i32"], ["scvU64", "u64"], ["scvI64", "i64"], ["scvTimepoint", "timepoint"], ["scvDuration", "duration"], ["scvU128", "u128"], ["scvI128", "i128"], ["scvU256", "u256"], ["scvI256", "i256"], ["scvBytes", "bytes"], ["scvString", "str"], ["scvSymbol", "sym"], ["scvVec", "vec"], ["scvMap", "map"], ["scvAddress", "address"], ["scvLedgerKeyContractInstance", xdr["void"]()], ["scvLedgerKeyNonce", "nonceKey"], ["scvContractInstance", "instance"]],
        arms: {
          b: xdr.bool(),
          error: xdr.lookup("ScError"),
          u32: xdr.lookup("Uint32"),
          i32: xdr.lookup("Int32"),
          u64: xdr.lookup("Uint64"),
          i64: xdr.lookup("Int64"),
          timepoint: xdr.lookup("TimePoint"),
          duration: xdr.lookup("Duration"),
          u128: xdr.lookup("UInt128Parts"),
          i128: xdr.lookup("Int128Parts"),
          u256: xdr.lookup("UInt256Parts"),
          i256: xdr.lookup("Int256Parts"),
          bytes: xdr.lookup("ScBytes"),
          str: xdr.lookup("ScString"),
          sym: xdr.lookup("ScSymbol"),
          vec: xdr.option(xdr.lookup("ScVec")),
          map: xdr.option(xdr.lookup("ScMap")),
          address: xdr.lookup("ScAddress"),
          nonceKey: xdr.lookup("ScNonceKey"),
          instance: xdr.lookup("ScContractInstance")
        }
      });
      xdr.struct("ScMapEntry", [["key", xdr.lookup("ScVal")], ["val", xdr.lookup("ScVal")]]);
      xdr["enum"]("ScEnvMetaKind", {
        scEnvMetaKindInterfaceVersion: 0
      });
      xdr.struct("ScEnvMetaEntryInterfaceVersion", [["protocol", xdr.lookup("Uint32")], ["preRelease", xdr.lookup("Uint32")]]);
      xdr.union("ScEnvMetaEntry", {
        switchOn: xdr.lookup("ScEnvMetaKind"),
        switchName: "kind",
        switches: [["scEnvMetaKindInterfaceVersion", "interfaceVersion"]],
        arms: {
          interfaceVersion: xdr.lookup("ScEnvMetaEntryInterfaceVersion")
        }
      });
      xdr.struct("ScMetaV0", [["key", xdr.string()], ["val", xdr.string()]]);
      xdr["enum"]("ScMetaKind", {
        scMetaV0: 0
      });
      xdr.union("ScMetaEntry", {
        switchOn: xdr.lookup("ScMetaKind"),
        switchName: "kind",
        switches: [["scMetaV0", "v0"]],
        arms: {
          v0: xdr.lookup("ScMetaV0")
        }
      });
      xdr["const"]("SC_SPEC_DOC_LIMIT", 1024);
      xdr["enum"]("ScSpecType", {
        scSpecTypeVal: 0,
        scSpecTypeBool: 1,
        scSpecTypeVoid: 2,
        scSpecTypeError: 3,
        scSpecTypeU32: 4,
        scSpecTypeI32: 5,
        scSpecTypeU64: 6,
        scSpecTypeI64: 7,
        scSpecTypeTimepoint: 8,
        scSpecTypeDuration: 9,
        scSpecTypeU128: 10,
        scSpecTypeI128: 11,
        scSpecTypeU256: 12,
        scSpecTypeI256: 13,
        scSpecTypeBytes: 14,
        scSpecTypeString: 16,
        scSpecTypeSymbol: 17,
        scSpecTypeAddress: 19,
        scSpecTypeOption: 1e3,
        scSpecTypeResult: 1001,
        scSpecTypeVec: 1002,
        scSpecTypeMap: 1004,
        scSpecTypeTuple: 1005,
        scSpecTypeBytesN: 1006,
        scSpecTypeUdt: 2e3
      });
      xdr.struct("ScSpecTypeOption", [["valueType", xdr.lookup("ScSpecTypeDef")]]);
      xdr.struct("ScSpecTypeResult", [["okType", xdr.lookup("ScSpecTypeDef")], ["errorType", xdr.lookup("ScSpecTypeDef")]]);
      xdr.struct("ScSpecTypeVec", [["elementType", xdr.lookup("ScSpecTypeDef")]]);
      xdr.struct("ScSpecTypeMap", [["keyType", xdr.lookup("ScSpecTypeDef")], ["valueType", xdr.lookup("ScSpecTypeDef")]]);
      xdr.struct("ScSpecTypeTuple", [["valueTypes", xdr.varArray(xdr.lookup("ScSpecTypeDef"), 12)]]);
      xdr.struct("ScSpecTypeBytesN", [["n", xdr.lookup("Uint32")]]);
      xdr.struct("ScSpecTypeUdt", [["name", xdr.string(60)]]);
      xdr.union("ScSpecTypeDef", {
        switchOn: xdr.lookup("ScSpecType"),
        switchName: "type",
        switches: [["scSpecTypeVal", xdr["void"]()], ["scSpecTypeBool", xdr["void"]()], ["scSpecTypeVoid", xdr["void"]()], ["scSpecTypeError", xdr["void"]()], ["scSpecTypeU32", xdr["void"]()], ["scSpecTypeI32", xdr["void"]()], ["scSpecTypeU64", xdr["void"]()], ["scSpecTypeI64", xdr["void"]()], ["scSpecTypeTimepoint", xdr["void"]()], ["scSpecTypeDuration", xdr["void"]()], ["scSpecTypeU128", xdr["void"]()], ["scSpecTypeI128", xdr["void"]()], ["scSpecTypeU256", xdr["void"]()], ["scSpecTypeI256", xdr["void"]()], ["scSpecTypeBytes", xdr["void"]()], ["scSpecTypeString", xdr["void"]()], ["scSpecTypeSymbol", xdr["void"]()], ["scSpecTypeAddress", xdr["void"]()], ["scSpecTypeOption", "option"], ["scSpecTypeResult", "result"], ["scSpecTypeVec", "vec"], ["scSpecTypeMap", "map"], ["scSpecTypeTuple", "tuple"], ["scSpecTypeBytesN", "bytesN"], ["scSpecTypeUdt", "udt"]],
        arms: {
          option: xdr.lookup("ScSpecTypeOption"),
          result: xdr.lookup("ScSpecTypeResult"),
          vec: xdr.lookup("ScSpecTypeVec"),
          map: xdr.lookup("ScSpecTypeMap"),
          tuple: xdr.lookup("ScSpecTypeTuple"),
          bytesN: xdr.lookup("ScSpecTypeBytesN"),
          udt: xdr.lookup("ScSpecTypeUdt")
        }
      });
      xdr.struct("ScSpecUdtStructFieldV0", [["doc", xdr.string(SC_SPEC_DOC_LIMIT)], ["name", xdr.string(30)], ["type", xdr.lookup("ScSpecTypeDef")]]);
      xdr.struct("ScSpecUdtStructV0", [["doc", xdr.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr.string(80)], ["name", xdr.string(60)], ["fields", xdr.varArray(xdr.lookup("ScSpecUdtStructFieldV0"), 40)]]);
      xdr.struct("ScSpecUdtUnionCaseVoidV0", [["doc", xdr.string(SC_SPEC_DOC_LIMIT)], ["name", xdr.string(60)]]);
      xdr.struct("ScSpecUdtUnionCaseTupleV0", [["doc", xdr.string(SC_SPEC_DOC_LIMIT)], ["name", xdr.string(60)], ["type", xdr.varArray(xdr.lookup("ScSpecTypeDef"), 12)]]);
      xdr["enum"]("ScSpecUdtUnionCaseV0Kind", {
        scSpecUdtUnionCaseVoidV0: 0,
        scSpecUdtUnionCaseTupleV0: 1
      });
      xdr.union("ScSpecUdtUnionCaseV0", {
        switchOn: xdr.lookup("ScSpecUdtUnionCaseV0Kind"),
        switchName: "kind",
        switches: [["scSpecUdtUnionCaseVoidV0", "voidCase"], ["scSpecUdtUnionCaseTupleV0", "tupleCase"]],
        arms: {
          voidCase: xdr.lookup("ScSpecUdtUnionCaseVoidV0"),
          tupleCase: xdr.lookup("ScSpecUdtUnionCaseTupleV0")
        }
      });
      xdr.struct("ScSpecUdtUnionV0", [["doc", xdr.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr.string(80)], ["name", xdr.string(60)], ["cases", xdr.varArray(xdr.lookup("ScSpecUdtUnionCaseV0"), 50)]]);
      xdr.struct("ScSpecUdtEnumCaseV0", [["doc", xdr.string(SC_SPEC_DOC_LIMIT)], ["name", xdr.string(60)], ["value", xdr.lookup("Uint32")]]);
      xdr.struct("ScSpecUdtEnumV0", [["doc", xdr.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr.string(80)], ["name", xdr.string(60)], ["cases", xdr.varArray(xdr.lookup("ScSpecUdtEnumCaseV0"), 50)]]);
      xdr.struct("ScSpecUdtErrorEnumCaseV0", [["doc", xdr.string(SC_SPEC_DOC_LIMIT)], ["name", xdr.string(60)], ["value", xdr.lookup("Uint32")]]);
      xdr.struct("ScSpecUdtErrorEnumV0", [["doc", xdr.string(SC_SPEC_DOC_LIMIT)], ["lib", xdr.string(80)], ["name", xdr.string(60)], ["cases", xdr.varArray(xdr.lookup("ScSpecUdtErrorEnumCaseV0"), 50)]]);
      xdr.struct("ScSpecFunctionInputV0", [["doc", xdr.string(SC_SPEC_DOC_LIMIT)], ["name", xdr.string(30)], ["type", xdr.lookup("ScSpecTypeDef")]]);
      xdr.struct("ScSpecFunctionV0", [["doc", xdr.string(SC_SPEC_DOC_LIMIT)], ["name", xdr.lookup("ScSymbol")], ["inputs", xdr.varArray(xdr.lookup("ScSpecFunctionInputV0"), 10)], ["outputs", xdr.varArray(xdr.lookup("ScSpecTypeDef"), 1)]]);
      xdr["enum"]("ScSpecEntryKind", {
        scSpecEntryFunctionV0: 0,
        scSpecEntryUdtStructV0: 1,
        scSpecEntryUdtUnionV0: 2,
        scSpecEntryUdtEnumV0: 3,
        scSpecEntryUdtErrorEnumV0: 4
      });
      xdr.union("ScSpecEntry", {
        switchOn: xdr.lookup("ScSpecEntryKind"),
        switchName: "kind",
        switches: [["scSpecEntryFunctionV0", "functionV0"], ["scSpecEntryUdtStructV0", "udtStructV0"], ["scSpecEntryUdtUnionV0", "udtUnionV0"], ["scSpecEntryUdtEnumV0", "udtEnumV0"], ["scSpecEntryUdtErrorEnumV0", "udtErrorEnumV0"]],
        arms: {
          functionV0: xdr.lookup("ScSpecFunctionV0"),
          udtStructV0: xdr.lookup("ScSpecUdtStructV0"),
          udtUnionV0: xdr.lookup("ScSpecUdtUnionV0"),
          udtEnumV0: xdr.lookup("ScSpecUdtEnumV0"),
          udtErrorEnumV0: xdr.lookup("ScSpecUdtErrorEnumV0")
        }
      });
      xdr.struct("ConfigSettingContractExecutionLanesV0", [["ledgerMaxTxCount", xdr.lookup("Uint32")]]);
      xdr.struct("ConfigSettingContractComputeV0", [["ledgerMaxInstructions", xdr.lookup("Int64")], ["txMaxInstructions", xdr.lookup("Int64")], ["feeRatePerInstructionsIncrement", xdr.lookup("Int64")], ["txMemoryLimit", xdr.lookup("Uint32")]]);
      xdr.struct("ConfigSettingContractLedgerCostV0", [["ledgerMaxReadLedgerEntries", xdr.lookup("Uint32")], ["ledgerMaxReadBytes", xdr.lookup("Uint32")], ["ledgerMaxWriteLedgerEntries", xdr.lookup("Uint32")], ["ledgerMaxWriteBytes", xdr.lookup("Uint32")], ["txMaxReadLedgerEntries", xdr.lookup("Uint32")], ["txMaxReadBytes", xdr.lookup("Uint32")], ["txMaxWriteLedgerEntries", xdr.lookup("Uint32")], ["txMaxWriteBytes", xdr.lookup("Uint32")], ["feeReadLedgerEntry", xdr.lookup("Int64")], ["feeWriteLedgerEntry", xdr.lookup("Int64")], ["feeRead1Kb", xdr.lookup("Int64")], ["bucketListTargetSizeBytes", xdr.lookup("Int64")], ["writeFee1KbBucketListLow", xdr.lookup("Int64")], ["writeFee1KbBucketListHigh", xdr.lookup("Int64")], ["bucketListWriteFeeGrowthFactor", xdr.lookup("Uint32")]]);
      xdr.struct("ConfigSettingContractHistoricalDataV0", [["feeHistorical1Kb", xdr.lookup("Int64")]]);
      xdr.struct("ConfigSettingContractEventsV0", [["txMaxContractEventsSizeBytes", xdr.lookup("Uint32")], ["feeContractEvents1Kb", xdr.lookup("Int64")]]);
      xdr.struct("ConfigSettingContractBandwidthV0", [["ledgerMaxTxsSizeBytes", xdr.lookup("Uint32")], ["txMaxSizeBytes", xdr.lookup("Uint32")], ["feeTxSize1Kb", xdr.lookup("Int64")]]);
      xdr["enum"]("ContractCostType", {
        wasmInsnExec: 0,
        memAlloc: 1,
        memCpy: 2,
        memCmp: 3,
        dispatchHostFunction: 4,
        visitObject: 5,
        valSer: 6,
        valDeser: 7,
        computeSha256Hash: 8,
        computeEd25519PubKey: 9,
        verifyEd25519Sig: 10,
        vmInstantiation: 11,
        vmCachedInstantiation: 12,
        invokeVmFunction: 13,
        computeKeccak256Hash: 14,
        decodeEcdsaCurve256Sig: 15,
        recoverEcdsaSecp256k1Key: 16,
        int256AddSub: 17,
        int256Mul: 18,
        int256Div: 19,
        int256Pow: 20,
        int256Shift: 21,
        chaCha20DrawBytes: 22,
        parseWasmInstructions: 23,
        parseWasmFunctions: 24,
        parseWasmGlobals: 25,
        parseWasmTableEntries: 26,
        parseWasmTypes: 27,
        parseWasmDataSegments: 28,
        parseWasmElemSegments: 29,
        parseWasmImports: 30,
        parseWasmExports: 31,
        parseWasmDataSegmentBytes: 32,
        instantiateWasmInstructions: 33,
        instantiateWasmFunctions: 34,
        instantiateWasmGlobals: 35,
        instantiateWasmTableEntries: 36,
        instantiateWasmTypes: 37,
        instantiateWasmDataSegments: 38,
        instantiateWasmElemSegments: 39,
        instantiateWasmImports: 40,
        instantiateWasmExports: 41,
        instantiateWasmDataSegmentBytes: 42,
        sec1DecodePointUncompressed: 43,
        verifyEcdsaSecp256r1Sig: 44,
        bls12381EncodeFp: 45,
        bls12381DecodeFp: 46,
        bls12381G1CheckPointOnCurve: 47,
        bls12381G1CheckPointInSubgroup: 48,
        bls12381G2CheckPointOnCurve: 49,
        bls12381G2CheckPointInSubgroup: 50,
        bls12381G1ProjectiveToAffine: 51,
        bls12381G2ProjectiveToAffine: 52,
        bls12381G1Add: 53,
        bls12381G1Mul: 54,
        bls12381G1Msm: 55,
        bls12381MapFpToG1: 56,
        bls12381HashToG1: 57,
        bls12381G2Add: 58,
        bls12381G2Mul: 59,
        bls12381G2Msm: 60,
        bls12381MapFp2ToG2: 61,
        bls12381HashToG2: 62,
        bls12381Pairing: 63,
        bls12381FrFromU256: 64,
        bls12381FrToU256: 65,
        bls12381FrAddSub: 66,
        bls12381FrMul: 67,
        bls12381FrPow: 68,
        bls12381FrInv: 69
      });
      xdr.struct("ContractCostParamEntry", [["ext", xdr.lookup("ExtensionPoint")], ["constTerm", xdr.lookup("Int64")], ["linearTerm", xdr.lookup("Int64")]]);
      xdr.struct("StateArchivalSettings", [["maxEntryTtl", xdr.lookup("Uint32")], ["minTemporaryTtl", xdr.lookup("Uint32")], ["minPersistentTtl", xdr.lookup("Uint32")], ["persistentRentRateDenominator", xdr.lookup("Int64")], ["tempRentRateDenominator", xdr.lookup("Int64")], ["maxEntriesToArchive", xdr.lookup("Uint32")], ["bucketListSizeWindowSampleSize", xdr.lookup("Uint32")], ["bucketListWindowSamplePeriod", xdr.lookup("Uint32")], ["evictionScanSize", xdr.lookup("Uint32")], ["startingEvictionScanLevel", xdr.lookup("Uint32")]]);
      xdr.struct("EvictionIterator", [["bucketListLevel", xdr.lookup("Uint32")], ["isCurrBucket", xdr.bool()], ["bucketFileOffset", xdr.lookup("Uint64")]]);
      xdr["const"]("CONTRACT_COST_COUNT_LIMIT", 1024);
      xdr.typedef("ContractCostParams", xdr.varArray(xdr.lookup("ContractCostParamEntry"), xdr.lookup("CONTRACT_COST_COUNT_LIMIT")));
      xdr["enum"]("ConfigSettingId", {
        configSettingContractMaxSizeBytes: 0,
        configSettingContractComputeV0: 1,
        configSettingContractLedgerCostV0: 2,
        configSettingContractHistoricalDataV0: 3,
        configSettingContractEventsV0: 4,
        configSettingContractBandwidthV0: 5,
        configSettingContractCostParamsCpuInstructions: 6,
        configSettingContractCostParamsMemoryBytes: 7,
        configSettingContractDataKeySizeBytes: 8,
        configSettingContractDataEntrySizeBytes: 9,
        configSettingStateArchival: 10,
        configSettingContractExecutionLanes: 11,
        configSettingBucketlistSizeWindow: 12,
        configSettingEvictionIterator: 13
      });
      xdr.union("ConfigSettingEntry", {
        switchOn: xdr.lookup("ConfigSettingId"),
        switchName: "configSettingId",
        switches: [["configSettingContractMaxSizeBytes", "contractMaxSizeBytes"], ["configSettingContractComputeV0", "contractCompute"], ["configSettingContractLedgerCostV0", "contractLedgerCost"], ["configSettingContractHistoricalDataV0", "contractHistoricalData"], ["configSettingContractEventsV0", "contractEvents"], ["configSettingContractBandwidthV0", "contractBandwidth"], ["configSettingContractCostParamsCpuInstructions", "contractCostParamsCpuInsns"], ["configSettingContractCostParamsMemoryBytes", "contractCostParamsMemBytes"], ["configSettingContractDataKeySizeBytes", "contractDataKeySizeBytes"], ["configSettingContractDataEntrySizeBytes", "contractDataEntrySizeBytes"], ["configSettingStateArchival", "stateArchivalSettings"], ["configSettingContractExecutionLanes", "contractExecutionLanes"], ["configSettingBucketlistSizeWindow", "bucketListSizeWindow"], ["configSettingEvictionIterator", "evictionIterator"]],
        arms: {
          contractMaxSizeBytes: xdr.lookup("Uint32"),
          contractCompute: xdr.lookup("ConfigSettingContractComputeV0"),
          contractLedgerCost: xdr.lookup("ConfigSettingContractLedgerCostV0"),
          contractHistoricalData: xdr.lookup("ConfigSettingContractHistoricalDataV0"),
          contractEvents: xdr.lookup("ConfigSettingContractEventsV0"),
          contractBandwidth: xdr.lookup("ConfigSettingContractBandwidthV0"),
          contractCostParamsCpuInsns: xdr.lookup("ContractCostParams"),
          contractCostParamsMemBytes: xdr.lookup("ContractCostParams"),
          contractDataKeySizeBytes: xdr.lookup("Uint32"),
          contractDataEntrySizeBytes: xdr.lookup("Uint32"),
          stateArchivalSettings: xdr.lookup("StateArchivalSettings"),
          contractExecutionLanes: xdr.lookup("ConfigSettingContractExecutionLanesV0"),
          bucketListSizeWindow: xdr.varArray(xdr.lookup("Uint64"), 2147483647),
          evictionIterator: xdr.lookup("EvictionIterator")
        }
      });
    });
    var _default = exports["default"] = types;
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/xdr.js
var require_xdr2 = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/xdr.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _curr_generated = _interopRequireDefault(require_curr_generated());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var _default = exports["default"] = _curr_generated["default"];
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/jsxdr.js
var require_jsxdr = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/jsxdr.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _jsXdr = require_xdr();
    var cereal = {
      XdrWriter: _jsXdr.XdrWriter,
      XdrReader: _jsXdr.XdrReader
    };
    var _default = exports["default"] = cereal;
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = TypeError;
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Number.isNaN || function isNaN2(a) {
      return a !== a;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var $isNaN = require_isNaN();
    module.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e) {
      if (!e || typeof e !== "object" || !("code" in e) || e.code !== "ERR_PROTO_ACCESS") {
        throw e;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? function getProto(O) {
      return reflectGetProto(O);
    } : originalGetProto ? function getProto(O) {
      if (!O || typeof O !== "object" && typeof O !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O);
    } : getDunderProto ? function getProto(O) {
      return getDunderProto(O);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/call-bound/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e) {
        if (e !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
          if (receiver == null) {
            iterator(array[i], i, array);
          } else {
            iterator.call(receiver, array[i], i, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i = 0, len = string.length; i < len; i++) {
        if (receiver == null) {
          iterator(string.charAt(i), i, string);
        } else {
          iterator.call(receiver, string.charAt(i), i, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
          if (receiver == null) {
            iterator(object[k], k, object);
          } else {
            iterator.call(receiver, object[k], k, object);
          }
        }
      }
    };
    function isArray(x) {
      return toStr.call(x) === "[object Array]";
    }
    module.exports = function forEach(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (isArray(list)) {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
  }
});

// node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "node_modules/possible-typed-array-names/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = [
      "Float16Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var possibleNames = require_possible_typed_array_names();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "node_modules/call-bind-apply-helpers/applyBind.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_call_bound();
    var gOPD = require_gopd();
    var getProto = require_get_proto();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i = 0; i < array.length; i += 1) {
        if (array[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getProto) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr && getProto) {
          var proto = getProto(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor && proto) {
            var superProto = getProto(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        var fn = arr.slice || arr.set;
        if (fn) {
          cache[
            /** @type {`$${import('.').TypedArrayName}`} */
            "$" + typedArray
          ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
          // @ts-expect-error TODO FIXME
          callBind(fn);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = /** @type {import('.').TypedArrayName} */
                $slice(typedArray, 1);
              }
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = /** @type {import('.').TypedArrayName} */
              $slice(name, 1);
            } catch (e) {
            }
          }
        }
      );
      return found;
    };
    module.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var whichTypedArray = require_which_typed_array();
    module.exports = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
  }
});

// node_modules/typed-array-buffer/index.js
var require_typed_array_buffer = __commonJS({
  "node_modules/typed-array-buffer/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var $TypeError = require_type();
    var callBound = require_call_bound();
    var $typedArrayBuffer = callBound("TypedArray.prototype.buffer", true);
    var isTypedArray = require_is_typed_array();
    module.exports = $typedArrayBuffer || function typedArrayBuffer(x) {
      if (!isTypedArray(x)) {
        throw new $TypeError("Not a Typed Array");
      }
      return x.buffer;
    };
  }
});

// node_modules/to-buffer/index.js
var require_to_buffer = __commonJS({
  "node_modules/to-buffer/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var Buffer2 = require_safe_buffer().Buffer;
    var isArray = require_isarray();
    var typedArrayBuffer = require_typed_array_buffer();
    var isView = ArrayBuffer.isView || function isView2(obj) {
      try {
        typedArrayBuffer(obj);
        return true;
      } catch (e) {
        return false;
      }
    };
    var useUint8Array = typeof Uint8Array !== "undefined";
    var useArrayBuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    var useFromArrayBuffer = useArrayBuffer && (Buffer2.prototype instanceof Uint8Array || Buffer2.TYPED_ARRAY_SUPPORT);
    module.exports = function toBuffer(data, encoding) {
      if (data instanceof Buffer2) {
        return data;
      }
      if (typeof data === "string") {
        return Buffer2.from(data, encoding);
      }
      if (useArrayBuffer && isView(data)) {
        if (data.byteLength === 0) {
          return Buffer2.alloc(0);
        }
        if (useFromArrayBuffer) {
          var res = Buffer2.from(data.buffer, data.byteOffset, data.byteLength);
          if (res.byteLength === data.byteLength) {
            return res;
          }
        }
        var uint8 = data instanceof Uint8Array ? data : new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        var result = Buffer2.from(uint8);
        if (result.length === data.byteLength) {
          return result;
        }
      }
      if (useUint8Array && data instanceof Uint8Array) {
        return Buffer2.from(data);
      }
      var isArr = isArray(data);
      if (isArr) {
        for (var i = 0; i < data.length; i += 1) {
          var x = data[i];
          if (typeof x !== "number" || x < 0 || x > 255 || ~~x !== x) {
            throw new RangeError("Array items must be numbers in the range 0-255.");
          }
        }
      }
      if (isArr || Buffer2.isBuffer(data) && data.constructor && typeof data.constructor.isBuffer === "function" && data.constructor.isBuffer(data)) {
        return Buffer2.from(data);
      }
      throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
    };
  }
});

// node_modules/sha.js/hash.js
var require_hash = __commonJS({
  "node_modules/sha.js/hash.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var Buffer2 = require_safe_buffer().Buffer;
    var toBuffer = require_to_buffer();
    function Hash(blockSize, finalSize) {
      this._block = Buffer2.alloc(blockSize);
      this._finalSize = finalSize;
      this._blockSize = blockSize;
      this._len = 0;
    }
    Hash.prototype.update = function(data, enc) {
      data = toBuffer(data, enc || "utf8");
      var block = this._block;
      var blockSize = this._blockSize;
      var length = data.length;
      var accum = this._len;
      for (var offset = 0; offset < length; ) {
        var assigned = accum % blockSize;
        var remainder = Math.min(length - offset, blockSize - assigned);
        for (var i = 0; i < remainder; i++) {
          block[assigned + i] = data[offset + i];
        }
        accum += remainder;
        offset += remainder;
        if (accum % blockSize === 0) {
          this._update(block);
        }
      }
      this._len += length;
      return this;
    };
    Hash.prototype.digest = function(enc) {
      var rem = this._len % this._blockSize;
      this._block[rem] = 128;
      this._block.fill(0, rem + 1);
      if (rem >= this._finalSize) {
        this._update(this._block);
        this._block.fill(0);
      }
      var bits = this._len * 8;
      if (bits <= 4294967295) {
        this._block.writeUInt32BE(bits, this._blockSize - 4);
      } else {
        var lowBits = (bits & 4294967295) >>> 0;
        var highBits = (bits - lowBits) / 4294967296;
        this._block.writeUInt32BE(highBits, this._blockSize - 8);
        this._block.writeUInt32BE(lowBits, this._blockSize - 4);
      }
      this._update(this._block);
      var hash = this._hash();
      return enc ? hash.toString(enc) : hash;
    };
    Hash.prototype._update = function() {
      throw new Error("_update must be implemented by subclass");
    };
    module.exports = Hash;
  }
});

// node_modules/sha.js/sha.js
var require_sha = __commonJS({
  "node_modules/sha.js/sha.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha, Hash);
    Sha.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) {
        return b & c | ~b & d;
      }
      if (s === 2) {
        return b & c | b & d | c & d;
      }
      return b ^ c ^ d;
    }
    Sha.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 80; ++i) {
        w[i] = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
      }
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha;
  }
});

// node_modules/sha.js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/sha.js/sha1.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1518500249,
      1859775393,
      2400959708 | 0,
      3395469782 | 0
    ];
    var W = new Array(80);
    function Sha1() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha1, Hash);
    Sha1.prototype.init = function() {
      this._a = 1732584193;
      this._b = 4023233417;
      this._c = 2562383102;
      this._d = 271733878;
      this._e = 3285377520;
      return this;
    };
    function rotl1(num) {
      return num << 1 | num >>> 31;
    }
    function rotl5(num) {
      return num << 5 | num >>> 27;
    }
    function rotl30(num) {
      return num << 30 | num >>> 2;
    }
    function ft(s, b, c, d) {
      if (s === 0) {
        return b & c | ~b & d;
      }
      if (s === 2) {
        return b & c | b & d | c & d;
      }
      return b ^ c ^ d;
    }
    Sha1.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 80; ++i) {
        w[i] = rotl1(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);
      }
      for (var j = 0; j < 80; ++j) {
        var s = ~~(j / 20);
        var t = rotl5(a) + ft(s, b, c, d) + e + w[j] + K[s] | 0;
        e = d;
        d = c;
        c = rotl30(b);
        b = a;
        a = t;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
    };
    Sha1.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(20);
      H.writeInt32BE(this._a | 0, 0);
      H.writeInt32BE(this._b | 0, 4);
      H.writeInt32BE(this._c | 0, 8);
      H.writeInt32BE(this._d | 0, 12);
      H.writeInt32BE(this._e | 0, 16);
      return H;
    };
    module.exports = Sha1;
  }
});

// node_modules/sha.js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/sha.js/sha256.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    var W = new Array(64);
    function Sha256() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha256, Hash);
    Sha256.prototype.init = function() {
      this._a = 1779033703;
      this._b = 3144134277;
      this._c = 1013904242;
      this._d = 2773480762;
      this._e = 1359893119;
      this._f = 2600822924;
      this._g = 528734635;
      this._h = 1541459225;
      return this;
    };
    function ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x) {
      return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
    }
    function sigma1(x) {
      return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
    }
    function gamma0(x) {
      return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
    }
    function gamma1(x) {
      return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
    }
    Sha256.prototype._update = function(M) {
      var w = this._w;
      var a = this._a | 0;
      var b = this._b | 0;
      var c = this._c | 0;
      var d = this._d | 0;
      var e = this._e | 0;
      var f = this._f | 0;
      var g = this._g | 0;
      var h = this._h | 0;
      for (var i = 0; i < 16; ++i) {
        w[i] = M.readInt32BE(i * 4);
      }
      for (; i < 64; ++i) {
        w[i] = gamma1(w[i - 2]) + w[i - 7] + gamma0(w[i - 15]) + w[i - 16] | 0;
      }
      for (var j = 0; j < 64; ++j) {
        var T1 = h + sigma1(e) + ch(e, f, g) + K[j] + w[j] | 0;
        var T2 = sigma0(a) + maj(a, b, c) | 0;
        h = g;
        g = f;
        f = e;
        e = d + T1 | 0;
        d = c;
        c = b;
        b = a;
        a = T1 + T2 | 0;
      }
      this._a = a + this._a | 0;
      this._b = b + this._b | 0;
      this._c = c + this._c | 0;
      this._d = d + this._d | 0;
      this._e = e + this._e | 0;
      this._f = f + this._f | 0;
      this._g = g + this._g | 0;
      this._h = h + this._h | 0;
    };
    Sha256.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(32);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      H.writeInt32BE(this._h, 28);
      return H;
    };
    module.exports = Sha256;
  }
});

// node_modules/sha.js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/sha.js/sha224.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var Sha256 = require_sha256();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(64);
    function Sha224() {
      this.init();
      this._w = W;
      Hash.call(this, 64, 56);
    }
    inherits(Sha224, Sha256);
    Sha224.prototype.init = function() {
      this._a = 3238371032;
      this._b = 914150663;
      this._c = 812702999;
      this._d = 4144912697;
      this._e = 4290775857;
      this._f = 1750603025;
      this._g = 1694076839;
      this._h = 3204075428;
      return this;
    };
    Sha224.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(28);
      H.writeInt32BE(this._a, 0);
      H.writeInt32BE(this._b, 4);
      H.writeInt32BE(this._c, 8);
      H.writeInt32BE(this._d, 12);
      H.writeInt32BE(this._e, 16);
      H.writeInt32BE(this._f, 20);
      H.writeInt32BE(this._g, 24);
      return H;
    };
    module.exports = Sha224;
  }
});

// node_modules/sha.js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/sha.js/sha512.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    var W = new Array(160);
    function Sha512() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha512, Hash);
    Sha512.prototype.init = function() {
      this._ah = 1779033703;
      this._bh = 3144134277;
      this._ch = 1013904242;
      this._dh = 2773480762;
      this._eh = 1359893119;
      this._fh = 2600822924;
      this._gh = 528734635;
      this._hh = 1541459225;
      this._al = 4089235720;
      this._bl = 2227873595;
      this._cl = 4271175723;
      this._dl = 1595750129;
      this._el = 2917565137;
      this._fl = 725511199;
      this._gl = 4215389547;
      this._hl = 327033209;
      return this;
    };
    function Ch(x, y, z) {
      return z ^ x & (y ^ z);
    }
    function maj(x, y, z) {
      return x & y | z & (x | y);
    }
    function sigma0(x, xl) {
      return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25);
    }
    function sigma1(x, xl) {
      return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23);
    }
    function Gamma0(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ x >>> 7;
    }
    function Gamma0l(x, xl) {
      return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25);
    }
    function Gamma1(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ x >>> 6;
    }
    function Gamma1l(x, xl) {
      return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26);
    }
    function getCarry(a, b) {
      return a >>> 0 < b >>> 0 ? 1 : 0;
    }
    Sha512.prototype._update = function(M) {
      var w = this._w;
      var ah = this._ah | 0;
      var bh = this._bh | 0;
      var ch = this._ch | 0;
      var dh = this._dh | 0;
      var eh = this._eh | 0;
      var fh = this._fh | 0;
      var gh = this._gh | 0;
      var hh = this._hh | 0;
      var al = this._al | 0;
      var bl = this._bl | 0;
      var cl = this._cl | 0;
      var dl = this._dl | 0;
      var el = this._el | 0;
      var fl = this._fl | 0;
      var gl = this._gl | 0;
      var hl = this._hl | 0;
      for (var i = 0; i < 32; i += 2) {
        w[i] = M.readInt32BE(i * 4);
        w[i + 1] = M.readInt32BE(i * 4 + 4);
      }
      for (; i < 160; i += 2) {
        var xh = w[i - 15 * 2];
        var xl = w[i - 15 * 2 + 1];
        var gamma0 = Gamma0(xh, xl);
        var gamma0l = Gamma0l(xl, xh);
        xh = w[i - 2 * 2];
        xl = w[i - 2 * 2 + 1];
        var gamma1 = Gamma1(xh, xl);
        var gamma1l = Gamma1l(xl, xh);
        var Wi7h = w[i - 7 * 2];
        var Wi7l = w[i - 7 * 2 + 1];
        var Wi16h = w[i - 16 * 2];
        var Wi16l = w[i - 16 * 2 + 1];
        var Wil = gamma0l + Wi7l | 0;
        var Wih = gamma0 + Wi7h + getCarry(Wil, gamma0l) | 0;
        Wil = Wil + gamma1l | 0;
        Wih = Wih + gamma1 + getCarry(Wil, gamma1l) | 0;
        Wil = Wil + Wi16l | 0;
        Wih = Wih + Wi16h + getCarry(Wil, Wi16l) | 0;
        w[i] = Wih;
        w[i + 1] = Wil;
      }
      for (var j = 0; j < 160; j += 2) {
        Wih = w[j];
        Wil = w[j + 1];
        var majh = maj(ah, bh, ch);
        var majl = maj(al, bl, cl);
        var sigma0h = sigma0(ah, al);
        var sigma0l = sigma0(al, ah);
        var sigma1h = sigma1(eh, el);
        var sigma1l = sigma1(el, eh);
        var Kih = K[j];
        var Kil = K[j + 1];
        var chh = Ch(eh, fh, gh);
        var chl = Ch(el, fl, gl);
        var t1l = hl + sigma1l | 0;
        var t1h = hh + sigma1h + getCarry(t1l, hl) | 0;
        t1l = t1l + chl | 0;
        t1h = t1h + chh + getCarry(t1l, chl) | 0;
        t1l = t1l + Kil | 0;
        t1h = t1h + Kih + getCarry(t1l, Kil) | 0;
        t1l = t1l + Wil | 0;
        t1h = t1h + Wih + getCarry(t1l, Wil) | 0;
        var t2l = sigma0l + majl | 0;
        var t2h = sigma0h + majh + getCarry(t2l, sigma0l) | 0;
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        el = dl + t1l | 0;
        eh = dh + t1h + getCarry(el, dl) | 0;
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        al = t1l + t2l | 0;
        ah = t1h + t2h + getCarry(al, t1l) | 0;
      }
      this._al = this._al + al | 0;
      this._bl = this._bl + bl | 0;
      this._cl = this._cl + cl | 0;
      this._dl = this._dl + dl | 0;
      this._el = this._el + el | 0;
      this._fl = this._fl + fl | 0;
      this._gl = this._gl + gl | 0;
      this._hl = this._hl + hl | 0;
      this._ah = this._ah + ah + getCarry(this._al, al) | 0;
      this._bh = this._bh + bh + getCarry(this._bl, bl) | 0;
      this._ch = this._ch + ch + getCarry(this._cl, cl) | 0;
      this._dh = this._dh + dh + getCarry(this._dl, dl) | 0;
      this._eh = this._eh + eh + getCarry(this._el, el) | 0;
      this._fh = this._fh + fh + getCarry(this._fl, fl) | 0;
      this._gh = this._gh + gh + getCarry(this._gl, gl) | 0;
      this._hh = this._hh + hh + getCarry(this._hl, hl) | 0;
    };
    Sha512.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(64);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      writeInt64BE(this._gh, this._gl, 48);
      writeInt64BE(this._hh, this._hl, 56);
      return H;
    };
    module.exports = Sha512;
  }
});

// node_modules/sha.js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/sha.js/sha384.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var inherits = require_inherits_browser();
    var SHA512 = require_sha512();
    var Hash = require_hash();
    var Buffer2 = require_safe_buffer().Buffer;
    var W = new Array(160);
    function Sha384() {
      this.init();
      this._w = W;
      Hash.call(this, 128, 112);
    }
    inherits(Sha384, SHA512);
    Sha384.prototype.init = function() {
      this._ah = 3418070365;
      this._bh = 1654270250;
      this._ch = 2438529370;
      this._dh = 355462360;
      this._eh = 1731405415;
      this._fh = 2394180231;
      this._gh = 3675008525;
      this._hh = 1203062813;
      this._al = 3238371032;
      this._bl = 914150663;
      this._cl = 812702999;
      this._dl = 4144912697;
      this._el = 4290775857;
      this._fl = 1750603025;
      this._gl = 1694076839;
      this._hl = 3204075428;
      return this;
    };
    Sha384.prototype._hash = function() {
      var H = Buffer2.allocUnsafe(48);
      function writeInt64BE(h, l, offset) {
        H.writeInt32BE(h, offset);
        H.writeInt32BE(l, offset + 4);
      }
      writeInt64BE(this._ah, this._al, 0);
      writeInt64BE(this._bh, this._bl, 8);
      writeInt64BE(this._ch, this._cl, 16);
      writeInt64BE(this._dh, this._dl, 24);
      writeInt64BE(this._eh, this._el, 32);
      writeInt64BE(this._fh, this._fl, 40);
      return H;
    };
    module.exports = Sha384;
  }
});

// node_modules/sha.js/index.js
var require_sha2 = __commonJS({
  "node_modules/sha.js/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = function SHA(algorithm) {
      var alg = algorithm.toLowerCase();
      var Algorithm = module.exports[alg];
      if (!Algorithm) {
        throw new Error(alg + " is not supported (we accept pull requests)");
      }
      return new Algorithm();
    };
    module.exports.sha = require_sha();
    module.exports.sha1 = require_sha1();
    module.exports.sha224 = require_sha224();
    module.exports.sha256 = require_sha256();
    module.exports.sha384 = require_sha384();
    module.exports.sha512 = require_sha512();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/hashing.js
var require_hashing = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/hashing.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hash = hash;
    var _sha = require_sha2();
    function hash(data) {
      var hasher = new _sha.sha256();
      hasher.update(data, "utf8");
      return hasher.digest();
    }
  }
});

// browser-external:sodium-native
var require_sodium_native = __commonJS({
  "browser-external:sodium-native"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "sodium-native" has been externalized for browser compatibility. Cannot access "sodium-native.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/signing.js
var require_signing = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/signing.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FastSigning = void 0;
    exports.generate = generate;
    exports.sign = sign;
    exports.verify = verify;
    var actualMethods = {};
    var FastSigning = exports.FastSigning = checkFastSigning();
    function sign(data, secretKey) {
      return actualMethods.sign(data, secretKey);
    }
    function verify(data, signature, publicKey) {
      return actualMethods.verify(data, signature, publicKey);
    }
    function generate(secretKey) {
      return actualMethods.generate(secretKey);
    }
    function checkFastSigning() {
      return typeof window === "undefined" ? checkFastSigningNode() : checkFastSigningBrowser();
    }
    function checkFastSigningNode() {
      var sodium;
      try {
        sodium = require_sodium_native();
      } catch (err) {
        return checkFastSigningBrowser();
      }
      if (!Object.keys(sodium).length) {
        return checkFastSigningBrowser();
      }
      actualMethods.generate = function(secretKey) {
        var pk = Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES);
        var sk = Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES);
        sodium.crypto_sign_seed_keypair(pk, sk, secretKey);
        return pk;
      };
      actualMethods.sign = function(data, secretKey) {
        data = Buffer.from(data);
        var signature = Buffer.alloc(sodium.crypto_sign_BYTES);
        sodium.crypto_sign_detached(signature, data, secretKey);
        return signature;
      };
      actualMethods.verify = function(data, signature, publicKey) {
        data = Buffer.from(data);
        try {
          return sodium.crypto_sign_verify_detached(signature, data, publicKey);
        } catch (e) {
          return false;
        }
      };
      return true;
    }
    function checkFastSigningBrowser() {
      var nacl = require_nacl_fast();
      actualMethods.generate = function(secretKey) {
        var secretKeyUint8 = new Uint8Array(secretKey);
        var naclKeys = nacl.sign.keyPair.fromSeed(secretKeyUint8);
        return Buffer.from(naclKeys.publicKey);
      };
      actualMethods.sign = function(data, secretKey) {
        data = Buffer.from(data);
        data = new Uint8Array(data.toJSON().data);
        secretKey = new Uint8Array(secretKey.toJSON().data);
        var signature = nacl.sign.detached(data, secretKey);
        return Buffer.from(signature);
      };
      actualMethods.verify = function(data, signature, publicKey) {
        data = Buffer.from(data);
        data = new Uint8Array(data.toJSON().data);
        signature = new Uint8Array(signature.toJSON().data);
        publicKey = new Uint8Array(publicKey.toJSON().data);
        return nacl.sign.detached.verify(data, signature, publicKey);
      };
      return false;
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/util/util.js
var require_util = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/util/util.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.trimEnd = void 0;
    var trimEnd = exports.trimEnd = function trimEnd2(input, _char) {
      var isNumber = typeof input === "number";
      var str = String(input);
      while (str.endsWith(_char)) {
        str = str.slice(0, -1);
      }
      return isNumber ? Number(str) : str;
    };
  }
});

// node_modules/base32.js/base32.js
var require_base32 = __commonJS({
  "node_modules/base32.js/base32.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    var charmap = function(alphabet, mappings) {
      mappings || (mappings = {});
      alphabet.split("").forEach(function(c, i) {
        if (!(c in mappings)) mappings[c] = i;
      });
      return mappings;
    };
    var rfc4648 = {
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      charmap: {
        0: 14,
        1: 8
      }
    };
    rfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);
    var crockford = {
      alphabet: "0123456789ABCDEFGHJKMNPQRSTVWXYZ",
      charmap: {
        O: 0,
        I: 1,
        L: 1
      }
    };
    crockford.charmap = charmap(crockford.alphabet, crockford.charmap);
    var base32hex = {
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      charmap: {}
    };
    base32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);
    function Decoder(options) {
      this.buf = [];
      this.shift = 8;
      this.carry = 0;
      if (options) {
        switch (options.type) {
          case "rfc4648":
            this.charmap = exports.rfc4648.charmap;
            break;
          case "crockford":
            this.charmap = exports.crockford.charmap;
            break;
          case "base32hex":
            this.charmap = exports.base32hex.charmap;
            break;
          default:
            throw new Error("invalid type");
        }
        if (options.charmap) this.charmap = options.charmap;
      }
    }
    Decoder.prototype.charmap = rfc4648.charmap;
    Decoder.prototype.write = function(str) {
      var charmap2 = this.charmap;
      var buf = this.buf;
      var shift = this.shift;
      var carry = this.carry;
      str.toUpperCase().split("").forEach(function(char) {
        if (char == "=") return;
        var symbol = charmap2[char] & 255;
        shift -= 5;
        if (shift > 0) {
          carry |= symbol << shift;
        } else if (shift < 0) {
          buf.push(carry | symbol >> -shift);
          shift += 8;
          carry = symbol << shift & 255;
        } else {
          buf.push(carry | symbol);
          shift = 8;
          carry = 0;
        }
      });
      this.shift = shift;
      this.carry = carry;
      return this;
    };
    Decoder.prototype.finalize = function(str) {
      if (str) {
        this.write(str);
      }
      if (this.shift !== 8 && this.carry !== 0) {
        this.buf.push(this.carry);
        this.shift = 8;
        this.carry = 0;
      }
      return this.buf;
    };
    function Encoder(options) {
      this.buf = "";
      this.shift = 3;
      this.carry = 0;
      if (options) {
        switch (options.type) {
          case "rfc4648":
            this.alphabet = exports.rfc4648.alphabet;
            break;
          case "crockford":
            this.alphabet = exports.crockford.alphabet;
            break;
          case "base32hex":
            this.alphabet = exports.base32hex.alphabet;
            break;
          default:
            throw new Error("invalid type");
        }
        if (options.alphabet) this.alphabet = options.alphabet;
        else if (options.lc) this.alphabet = this.alphabet.toLowerCase();
      }
    }
    Encoder.prototype.alphabet = rfc4648.alphabet;
    Encoder.prototype.write = function(buf) {
      var shift = this.shift;
      var carry = this.carry;
      var symbol;
      var byte;
      var i;
      for (i = 0; i < buf.length; i++) {
        byte = buf[i];
        symbol = carry | byte >> shift;
        this.buf += this.alphabet[symbol & 31];
        if (shift > 5) {
          shift -= 5;
          symbol = byte >> shift;
          this.buf += this.alphabet[symbol & 31];
        }
        shift = 5 - shift;
        carry = byte << shift;
        shift = 8 - shift;
      }
      this.shift = shift;
      this.carry = carry;
      return this;
    };
    Encoder.prototype.finalize = function(buf) {
      if (buf) {
        this.write(buf);
      }
      if (this.shift !== 3) {
        this.buf += this.alphabet[this.carry & 31];
        this.shift = 3;
        this.carry = 0;
      }
      return this.buf;
    };
    exports.encode = function(buf, options) {
      return new Encoder(options).finalize(buf);
    };
    exports.decode = function(str, options) {
      return new Decoder(options).finalize(str);
    };
    exports.Decoder = Decoder;
    exports.Encoder = Encoder;
    exports.charmap = charmap;
    exports.crockford = crockford;
    exports.rfc4648 = rfc4648;
    exports.base32hex = base32hex;
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/util/checksum.js
var require_checksum = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/util/checksum.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.verifyChecksum = verifyChecksum;
    function verifyChecksum(expected, actual) {
      if (expected.length !== actual.length) {
        return false;
      }
      if (expected.length === 0) {
        return true;
      }
      for (var i = 0; i < expected.length; i += 1) {
        if (expected[i] !== actual[i]) {
          return false;
        }
      }
      return true;
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/strkey.js
var require_strkey = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/strkey.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.StrKey = void 0;
    exports.decodeCheck = decodeCheck;
    exports.encodeCheck = encodeCheck;
    var _base = _interopRequireDefault(require_base32());
    var _checksum = require_checksum();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var versionBytes = {
      ed25519PublicKey: 6 << 3,
      // G (when encoded in base32)
      ed25519SecretSeed: 18 << 3,
      // S
      med25519PublicKey: 12 << 3,
      // M
      preAuthTx: 19 << 3,
      // T
      sha256Hash: 23 << 3,
      // X
      signedPayload: 15 << 3,
      // P
      contract: 2 << 3
      // C
    };
    var strkeyTypes = {
      G: "ed25519PublicKey",
      S: "ed25519SecretSeed",
      M: "med25519PublicKey",
      T: "preAuthTx",
      X: "sha256Hash",
      P: "signedPayload",
      C: "contract"
    };
    var StrKey = exports.StrKey = function() {
      function StrKey2() {
        _classCallCheck(this, StrKey2);
      }
      return _createClass(StrKey2, null, [{
        key: "encodeEd25519PublicKey",
        value: (
          /**
           * Encodes `data` to strkey ed25519 public key.
           *
           * @param   {Buffer} data   raw data to encode
           * @returns {string}        "G..." representation of the key
           */
          function encodeEd25519PublicKey(data) {
            return encodeCheck("ed25519PublicKey", data);
          }
        )
        /**
         * Decodes strkey ed25519 public key to raw data.
         *
         * If the parameter is a muxed account key ("M..."), this will only encode it
         * as a basic Ed25519 key (as if in "G..." format).
         *
         * @param   {string} data   "G..." (or "M...") key representation to decode
         * @returns {Buffer}        raw key
         */
      }, {
        key: "decodeEd25519PublicKey",
        value: function decodeEd25519PublicKey(data) {
          return decodeCheck("ed25519PublicKey", data);
        }
        /**
         * Returns true if the given Stellar public key is a valid ed25519 public key.
         * @param {string} publicKey public key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidEd25519PublicKey",
        value: function isValidEd25519PublicKey(publicKey) {
          return isValid("ed25519PublicKey", publicKey);
        }
        /**
         * Encodes data to strkey ed25519 seed.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodeEd25519SecretSeed",
        value: function encodeEd25519SecretSeed(data) {
          return encodeCheck("ed25519SecretSeed", data);
        }
        /**
         * Decodes strkey ed25519 seed to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeEd25519SecretSeed",
        value: function decodeEd25519SecretSeed(address) {
          return decodeCheck("ed25519SecretSeed", address);
        }
        /**
         * Returns true if the given Stellar secret key is a valid ed25519 secret seed.
         * @param {string} seed seed to check
         * @returns {boolean}
         */
      }, {
        key: "isValidEd25519SecretSeed",
        value: function isValidEd25519SecretSeed(seed) {
          return isValid("ed25519SecretSeed", seed);
        }
        /**
         * Encodes data to strkey med25519 public key.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodeMed25519PublicKey",
        value: function encodeMed25519PublicKey(data) {
          return encodeCheck("med25519PublicKey", data);
        }
        /**
         * Decodes strkey med25519 public key to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeMed25519PublicKey",
        value: function decodeMed25519PublicKey(address) {
          return decodeCheck("med25519PublicKey", address);
        }
        /**
         * Returns true if the given Stellar public key is a valid med25519 public key.
         * @param {string} publicKey public key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidMed25519PublicKey",
        value: function isValidMed25519PublicKey(publicKey) {
          return isValid("med25519PublicKey", publicKey);
        }
        /**
         * Encodes data to strkey preAuthTx.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodePreAuthTx",
        value: function encodePreAuthTx(data) {
          return encodeCheck("preAuthTx", data);
        }
        /**
         * Decodes strkey PreAuthTx to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodePreAuthTx",
        value: function decodePreAuthTx(address) {
          return decodeCheck("preAuthTx", address);
        }
        /**
         * Encodes data to strkey sha256 hash.
         * @param {Buffer} data data to encode
         * @returns {string}
         */
      }, {
        key: "encodeSha256Hash",
        value: function encodeSha256Hash(data) {
          return encodeCheck("sha256Hash", data);
        }
        /**
         * Decodes strkey sha256 hash to raw data.
         * @param {string} address data to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeSha256Hash",
        value: function decodeSha256Hash(address) {
          return decodeCheck("sha256Hash", address);
        }
        /**
         * Encodes raw data to strkey signed payload (P...).
         * @param   {Buffer} data  data to encode
         * @returns {string}
         */
      }, {
        key: "encodeSignedPayload",
        value: function encodeSignedPayload(data) {
          return encodeCheck("signedPayload", data);
        }
        /**
         * Decodes strkey signed payload (P...) to raw data.
         * @param   {string} address  address to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeSignedPayload",
        value: function decodeSignedPayload(address) {
          return decodeCheck("signedPayload", address);
        }
        /**
         * Checks validity of alleged signed payload (P...) strkey address.
         * @param   {string} address  signer key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidSignedPayload",
        value: function isValidSignedPayload(address) {
          return isValid("signedPayload", address);
        }
        /**
         * Encodes raw data to strkey contract (C...).
         * @param   {Buffer} data  data to encode
         * @returns {string}
         */
      }, {
        key: "encodeContract",
        value: function encodeContract(data) {
          return encodeCheck("contract", data);
        }
        /**
         * Decodes strkey contract (C...) to raw data.
         * @param   {string} address  address to decode
         * @returns {Buffer}
         */
      }, {
        key: "decodeContract",
        value: function decodeContract(address) {
          return decodeCheck("contract", address);
        }
        /**
         * Checks validity of alleged contract (C...) strkey address.
         * @param   {string} address  signer key to check
         * @returns {boolean}
         */
      }, {
        key: "isValidContract",
        value: function isValidContract(address) {
          return isValid("contract", address);
        }
      }, {
        key: "getVersionByteForPrefix",
        value: function getVersionByteForPrefix(address) {
          return strkeyTypes[address[0]];
        }
      }]);
    }();
    function isValid(versionByteName, encoded) {
      if (typeof encoded !== "string") {
        return false;
      }
      switch (versionByteName) {
        case "ed25519PublicKey":
        // falls through
        case "ed25519SecretSeed":
        // falls through
        case "preAuthTx":
        // falls through
        case "sha256Hash":
        // falls through
        case "contract":
          if (encoded.length !== 56) {
            return false;
          }
          break;
        case "med25519PublicKey":
          if (encoded.length !== 69) {
            return false;
          }
          break;
        case "signedPayload":
          if (encoded.length < 56 || encoded.length > 165) {
            return false;
          }
          break;
        default:
          return false;
      }
      var decoded = "";
      try {
        decoded = decodeCheck(versionByteName, encoded);
      } catch (err) {
        return false;
      }
      switch (versionByteName) {
        case "ed25519PublicKey":
        // falls through
        case "ed25519SecretSeed":
        // falls through
        case "preAuthTx":
        // falls through
        case "sha256Hash":
        // falls through
        case "contract":
          return decoded.length === 32;
        case "med25519PublicKey":
          return decoded.length === 40;
        // +8 bytes for the ID
        case "signedPayload":
          return (
            // 32 for the signer, +4 for the payload size, then either +4 for the
            // min or +64 for the max payload
            decoded.length >= 32 + 4 + 4 && decoded.length <= 32 + 4 + 64
          );
        default:
          return false;
      }
    }
    function decodeCheck(versionByteName, encoded) {
      if (typeof encoded !== "string") {
        throw new TypeError("encoded argument must be of type String");
      }
      var decoded = _base["default"].decode(encoded);
      var versionByte = decoded[0];
      var payload = decoded.slice(0, -2);
      var data = payload.slice(1);
      var checksum = decoded.slice(-2);
      if (encoded !== _base["default"].encode(decoded)) {
        throw new Error("invalid encoded string");
      }
      var expectedVersion = versionBytes[versionByteName];
      if (expectedVersion === void 0) {
        throw new Error("".concat(versionByteName, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(versionBytes).join(", ")));
      }
      if (versionByte !== expectedVersion) {
        throw new Error("invalid version byte. expected ".concat(expectedVersion, ", got ").concat(versionByte));
      }
      var expectedChecksum = calculateChecksum(payload);
      if (!(0, _checksum.verifyChecksum)(expectedChecksum, checksum)) {
        throw new Error("invalid checksum");
      }
      return Buffer.from(data);
    }
    function encodeCheck(versionByteName, data) {
      if (data === null || data === void 0) {
        throw new Error("cannot encode null data");
      }
      var versionByte = versionBytes[versionByteName];
      if (versionByte === void 0) {
        throw new Error("".concat(versionByteName, " is not a valid version byte name. ") + "Expected one of ".concat(Object.keys(versionBytes).join(", ")));
      }
      data = Buffer.from(data);
      var versionBuffer = Buffer.from([versionByte]);
      var payload = Buffer.concat([versionBuffer, data]);
      var checksum = Buffer.from(calculateChecksum(payload));
      var unencoded = Buffer.concat([payload, checksum]);
      return _base["default"].encode(unencoded);
    }
    function calculateChecksum(payload) {
      var crcTable = [0, 4129, 8258, 12387, 16516, 20645, 24774, 28903, 33032, 37161, 41290, 45419, 49548, 53677, 57806, 61935, 4657, 528, 12915, 8786, 21173, 17044, 29431, 25302, 37689, 33560, 45947, 41818, 54205, 50076, 62463, 58334, 9314, 13379, 1056, 5121, 25830, 29895, 17572, 21637, 42346, 46411, 34088, 38153, 58862, 62927, 50604, 54669, 13907, 9842, 5649, 1584, 30423, 26358, 22165, 18100, 46939, 42874, 38681, 34616, 63455, 59390, 55197, 51132, 18628, 22757, 26758, 30887, 2112, 6241, 10242, 14371, 51660, 55789, 59790, 63919, 35144, 39273, 43274, 47403, 23285, 19156, 31415, 27286, 6769, 2640, 14899, 10770, 56317, 52188, 64447, 60318, 39801, 35672, 47931, 43802, 27814, 31879, 19684, 23749, 11298, 15363, 3168, 7233, 60846, 64911, 52716, 56781, 44330, 48395, 36200, 40265, 32407, 28342, 24277, 20212, 15891, 11826, 7761, 3696, 65439, 61374, 57309, 53244, 48923, 44858, 40793, 36728, 37256, 33193, 45514, 41451, 53516, 49453, 61774, 57711, 4224, 161, 12482, 8419, 20484, 16421, 28742, 24679, 33721, 37784, 41979, 46042, 49981, 54044, 58239, 62302, 689, 4752, 8947, 13010, 16949, 21012, 25207, 29270, 46570, 42443, 38312, 34185, 62830, 58703, 54572, 50445, 13538, 9411, 5280, 1153, 29798, 25671, 21540, 17413, 42971, 47098, 34713, 38840, 59231, 63358, 50973, 55100, 9939, 14066, 1681, 5808, 26199, 30326, 17941, 22068, 55628, 51565, 63758, 59695, 39368, 35305, 47498, 43435, 22596, 18533, 30726, 26663, 6336, 2273, 14466, 10403, 52093, 56156, 60223, 64286, 35833, 39896, 43963, 48026, 19061, 23124, 27191, 31254, 2801, 6864, 10931, 14994, 64814, 60687, 56684, 52557, 48554, 44427, 40424, 36297, 31782, 27655, 23652, 19525, 15522, 11395, 7392, 3265, 61215, 65342, 53085, 57212, 44955, 49082, 36825, 40952, 28183, 32310, 20053, 24180, 11923, 16050, 3793, 7920];
      var crc16 = 0;
      for (var i = 0; i < payload.length; i += 1) {
        var _byte = payload[i];
        var lookupIndex = crc16 >> 8 ^ _byte;
        crc16 = crc16 << 8 ^ crcTable[lookupIndex];
        crc16 &= 65535;
      }
      var checksum = new Uint8Array(2);
      checksum[0] = crc16 & 255;
      checksum[1] = crc16 >> 8 & 255;
      return checksum;
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/keypair.js
var require_keypair = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/keypair.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Keypair = void 0;
    var _tweetnacl = _interopRequireDefault(require_nacl_fast());
    var _signing = require_signing();
    var _strkey = require_strkey();
    var _hashing = require_hashing();
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Keypair = exports.Keypair = function() {
      function Keypair2(keys) {
        _classCallCheck(this, Keypair2);
        if (keys.type !== "ed25519") {
          throw new Error("Invalid keys type");
        }
        this.type = keys.type;
        if (keys.secretKey) {
          keys.secretKey = Buffer.from(keys.secretKey);
          if (keys.secretKey.length !== 32) {
            throw new Error("secretKey length is invalid");
          }
          this._secretSeed = keys.secretKey;
          this._publicKey = (0, _signing.generate)(keys.secretKey);
          this._secretKey = Buffer.concat([keys.secretKey, this._publicKey]);
          if (keys.publicKey && !this._publicKey.equals(Buffer.from(keys.publicKey))) {
            throw new Error("secretKey does not match publicKey");
          }
        } else {
          this._publicKey = Buffer.from(keys.publicKey);
          if (this._publicKey.length !== 32) {
            throw new Error("publicKey length is invalid");
          }
        }
      }
      return _createClass(Keypair2, [{
        key: "xdrAccountId",
        value: function xdrAccountId() {
          return new _xdr["default"].AccountId.publicKeyTypeEd25519(this._publicKey);
        }
      }, {
        key: "xdrPublicKey",
        value: function xdrPublicKey() {
          return new _xdr["default"].PublicKey.publicKeyTypeEd25519(this._publicKey);
        }
        /**
         * Creates a {@link xdr.MuxedAccount} object from the public key.
         *
         * You will get a different type of muxed account depending on whether or not
         * you pass an ID.
         *
         * @param  {string} [id] - stringified integer indicating the underlying muxed
         *     ID of the new account object
         *
         * @return {xdr.MuxedAccount}
         */
      }, {
        key: "xdrMuxedAccount",
        value: function xdrMuxedAccount(id) {
          if (typeof id !== "undefined") {
            if (typeof id !== "string") {
              throw new TypeError("expected string for ID, got ".concat(_typeof(id)));
            }
            return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
              id: _xdr["default"].Uint64.fromString(id),
              ed25519: this._publicKey
            }));
          }
          return new _xdr["default"].MuxedAccount.keyTypeEd25519(this._publicKey);
        }
        /**
         * Returns raw public key
         * @returns {Buffer}
         */
      }, {
        key: "rawPublicKey",
        value: function rawPublicKey() {
          return this._publicKey;
        }
      }, {
        key: "signatureHint",
        value: function signatureHint() {
          var a = this.xdrAccountId().toXDR();
          return a.slice(a.length - 4);
        }
        /**
         * Returns public key associated with this `Keypair` object.
         * @returns {string}
         */
      }, {
        key: "publicKey",
        value: function publicKey() {
          return _strkey.StrKey.encodeEd25519PublicKey(this._publicKey);
        }
        /**
         * Returns secret key associated with this `Keypair` object
         * @returns {string}
         */
      }, {
        key: "secret",
        value: function secret() {
          if (!this._secretSeed) {
            throw new Error("no secret key available");
          }
          if (this.type === "ed25519") {
            return _strkey.StrKey.encodeEd25519SecretSeed(this._secretSeed);
          }
          throw new Error("Invalid Keypair type");
        }
        /**
         * Returns raw secret key.
         * @returns {Buffer}
         */
      }, {
        key: "rawSecretKey",
        value: function rawSecretKey() {
          return this._secretSeed;
        }
        /**
         * Returns `true` if this `Keypair` object contains secret key and can sign.
         * @returns {boolean}
         */
      }, {
        key: "canSign",
        value: function canSign() {
          return !!this._secretKey;
        }
        /**
         * Signs data.
         * @param {Buffer} data Data to sign
         * @returns {Buffer}
         */
      }, {
        key: "sign",
        value: function sign(data) {
          if (!this.canSign()) {
            throw new Error("cannot sign: no secret key available");
          }
          return (0, _signing.sign)(data, this._secretKey);
        }
        /**
         * Verifies if `signature` for `data` is valid.
         * @param {Buffer} data Signed data
         * @param {Buffer} signature Signature
         * @returns {boolean}
         */
      }, {
        key: "verify",
        value: function verify(data, signature) {
          return (0, _signing.verify)(data, signature, this._publicKey);
        }
        /**
         * Returns the decorated signature (hint+sig) for arbitrary data.
         *
         * @param  {Buffer} data  arbitrary data to sign
         * @return {xdr.DecoratedSignature}   the raw signature structure which can be
         *     added directly to a transaction envelope
         *
         * @see TransactionBase.addDecoratedSignature
         */
      }, {
        key: "signDecorated",
        value: function signDecorated(data) {
          var signature = this.sign(data);
          var hint = this.signatureHint();
          return new _xdr["default"].DecoratedSignature({
            hint,
            signature
          });
        }
        /**
         * Returns the raw decorated signature (hint+sig) for a signed payload signer.
         *
         *  The hint is defined as the last 4 bytes of the signer key XORed with last
         *  4 bytes of the payload (zero-left-padded if necessary).
         *
         * @param  {Buffer} data    data to both sign and treat as the payload
         * @return {xdr.DecoratedSignature}
         *
         * @see https://github.com/stellar/stellar-protocol/blob/master/core/cap-0040.md#signature-hint
         * @see TransactionBase.addDecoratedSignature
         */
      }, {
        key: "signPayloadDecorated",
        value: function signPayloadDecorated(data) {
          var signature = this.sign(data);
          var keyHint = this.signatureHint();
          var hint = Buffer.from(data.slice(-4));
          if (hint.length < 4) {
            hint = Buffer.concat([hint, Buffer.alloc(4 - data.length, 0)]);
          }
          return new _xdr["default"].DecoratedSignature({
            hint: hint.map(function(_byte, i) {
              return _byte ^ keyHint[i];
            }),
            signature
          });
        }
      }], [{
        key: "fromSecret",
        value: function fromSecret(secret) {
          var rawSecret = _strkey.StrKey.decodeEd25519SecretSeed(secret);
          return this.fromRawEd25519Seed(rawSecret);
        }
        /**
         * Creates a new `Keypair` object from ed25519 secret key seed raw bytes.
         *
         * @param {Buffer} rawSeed Raw 32-byte ed25519 secret key seed
         * @returns {Keypair}
         */
      }, {
        key: "fromRawEd25519Seed",
        value: function fromRawEd25519Seed(rawSeed) {
          return new this({
            type: "ed25519",
            secretKey: rawSeed
          });
        }
        /**
         * Returns `Keypair` object representing network master key.
         * @param {string} networkPassphrase passphrase of the target stellar network (e.g. "Public Global Stellar Network ; September 2015").
         * @returns {Keypair}
         */
      }, {
        key: "master",
        value: function master(networkPassphrase) {
          if (!networkPassphrase) {
            throw new Error("No network selected. Please pass a network argument, e.g. `Keypair.master(Networks.PUBLIC)`.");
          }
          return this.fromRawEd25519Seed((0, _hashing.hash)(networkPassphrase));
        }
        /**
         * Creates a new `Keypair` object from public key.
         * @param {string} publicKey public key (ex. `GB3KJPLFUYN5VL6R3GU3EGCGVCKFDSD7BEDX42HWG5BWFKB3KQGJJRMA`)
         * @returns {Keypair}
         */
      }, {
        key: "fromPublicKey",
        value: function fromPublicKey(publicKey) {
          publicKey = _strkey.StrKey.decodeEd25519PublicKey(publicKey);
          if (publicKey.length !== 32) {
            throw new Error("Invalid Stellar public key");
          }
          return new this({
            type: "ed25519",
            publicKey
          });
        }
        /**
         * Create a random `Keypair` object.
         * @returns {Keypair}
         */
      }, {
        key: "random",
        value: function random() {
          var secret = _tweetnacl["default"].randomBytes(32);
          return this.fromRawEd25519Seed(secret);
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/asset.js
var require_asset = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/asset.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Asset = void 0;
    var _util = require_util();
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _strkey = require_strkey();
    var _hashing = require_hashing();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Asset = exports.Asset = function() {
      function Asset2(code, issuer) {
        _classCallCheck(this, Asset2);
        if (!/^[a-zA-Z0-9]{1,12}$/.test(code)) {
          throw new Error("Asset code is invalid (maximum alphanumeric, 12 characters at max)");
        }
        if (String(code).toLowerCase() !== "xlm" && !issuer) {
          throw new Error("Issuer cannot be null");
        }
        if (issuer && !_strkey.StrKey.isValidEd25519PublicKey(issuer)) {
          throw new Error("Issuer is invalid");
        }
        if (String(code).toLowerCase() === "xlm") {
          this.code = "XLM";
        } else {
          this.code = code;
        }
        this.issuer = issuer;
      }
      return _createClass(Asset2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the xdr.Asset object for this asset.
           * @returns {xdr.Asset} XDR asset object
           */
          function toXDRObject() {
            return this._toXDRObject(_xdr["default"].Asset);
          }
        )
        /**
         * Returns the xdr.ChangeTrustAsset object for this asset.
         * @returns {xdr.ChangeTrustAsset} XDR asset object
         */
      }, {
        key: "toChangeTrustXDRObject",
        value: function toChangeTrustXDRObject() {
          return this._toXDRObject(_xdr["default"].ChangeTrustAsset);
        }
        /**
         * Returns the xdr.TrustLineAsset object for this asset.
         * @returns {xdr.TrustLineAsset} XDR asset object
         */
      }, {
        key: "toTrustLineXDRObject",
        value: function toTrustLineXDRObject() {
          return this._toXDRObject(_xdr["default"].TrustLineAsset);
        }
        /**
         * Returns the would-be contract ID (`C...` format) for this asset on a given
         * network.
         *
         * @param {string}    networkPassphrase   indicates which network the contract
         *    ID should refer to, since every network will have a unique ID for the
         *    same contract (see {@link Networks} for options)
         *
         * @returns {string}  the strkey-encoded (`C...`) contract ID for this asset
         *
         * @warning This makes no guarantee that this contract actually *exists*.
         */
      }, {
        key: "contractId",
        value: function contractId(networkPassphrase) {
          var networkId = (0, _hashing.hash)(Buffer.from(networkPassphrase));
          var preimage = _xdr["default"].HashIdPreimage.envelopeTypeContractId(new _xdr["default"].HashIdPreimageContractId({
            networkId,
            contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAsset(this.toXDRObject())
          }));
          return _strkey.StrKey.encodeContract((0, _hashing.hash)(preimage.toXDR()));
        }
        /**
         * Returns the xdr object for this asset.
         * @param {xdr.Asset | xdr.ChangeTrustAsset} xdrAsset - The asset xdr object.
         * @returns {xdr.Asset | xdr.ChangeTrustAsset | xdr.TrustLineAsset} XDR Asset object
         */
      }, {
        key: "_toXDRObject",
        value: function _toXDRObject() {
          var xdrAsset = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : _xdr["default"].Asset;
          if (this.isNative()) {
            return xdrAsset.assetTypeNative();
          }
          var xdrType;
          var xdrTypeString;
          if (this.code.length <= 4) {
            xdrType = _xdr["default"].AlphaNum4;
            xdrTypeString = "assetTypeCreditAlphanum4";
          } else {
            xdrType = _xdr["default"].AlphaNum12;
            xdrTypeString = "assetTypeCreditAlphanum12";
          }
          var padLength = this.code.length <= 4 ? 4 : 12;
          var paddedCode = this.code.padEnd(padLength, "\0");
          var assetType = new xdrType({
            assetCode: paddedCode,
            issuer: _keypair.Keypair.fromPublicKey(this.issuer).xdrAccountId()
          });
          return new xdrAsset(xdrTypeString, assetType);
        }
        /**
         * @returns {string} Asset code
         */
      }, {
        key: "getCode",
        value: function getCode() {
          if (this.code === void 0) {
            return void 0;
          }
          return String(this.code);
        }
        /**
         * @returns {string} Asset issuer
         */
      }, {
        key: "getIssuer",
        value: function getIssuer() {
          if (this.issuer === void 0) {
            return void 0;
          }
          return String(this.issuer);
        }
        /**
         * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
         * @returns {string} Asset type. Can be one of following types:
         *
         *  - `native`,
         *  - `credit_alphanum4`,
         *  - `credit_alphanum12`, or
         *  - `unknown` as the error case (which should never occur)
         */
      }, {
        key: "getAssetType",
        value: function getAssetType() {
          switch (this.getRawAssetType().value) {
            case _xdr["default"].AssetType.assetTypeNative().value:
              return "native";
            case _xdr["default"].AssetType.assetTypeCreditAlphanum4().value:
              return "credit_alphanum4";
            case _xdr["default"].AssetType.assetTypeCreditAlphanum12().value:
              return "credit_alphanum12";
            default:
              return "unknown";
          }
        }
        /**
         * @returns {xdr.AssetType}  the raw XDR representation of the asset type
         */
      }, {
        key: "getRawAssetType",
        value: function getRawAssetType() {
          if (this.isNative()) {
            return _xdr["default"].AssetType.assetTypeNative();
          }
          if (this.code.length <= 4) {
            return _xdr["default"].AssetType.assetTypeCreditAlphanum4();
          }
          return _xdr["default"].AssetType.assetTypeCreditAlphanum12();
        }
        /**
         * @returns {boolean}  true if this asset object is the native asset.
         */
      }, {
        key: "isNative",
        value: function isNative() {
          return !this.issuer;
        }
        /**
         * @param {Asset} asset Asset to compare
         * @returns {boolean} true if this asset equals the given asset.
         */
      }, {
        key: "equals",
        value: function equals(asset) {
          return this.code === asset.getCode() && this.issuer === asset.getIssuer();
        }
      }, {
        key: "toString",
        value: function toString() {
          if (this.isNative()) {
            return "native";
          }
          return "".concat(this.getCode(), ":").concat(this.getIssuer());
        }
        /**
         * Compares two assets according to the criteria:
         *
         *  1. First compare the type (native < alphanum4 < alphanum12).
         *  2. If the types are equal, compare the assets codes.
         *  3. If the asset codes are equal, compare the issuers.
         *
         * @param   {Asset} assetA - the first asset
         * @param   {Asset} assetB - the second asset
         * @returns {number} `-1` if assetA < assetB, `0` if assetA == assetB, `1` if assetA > assetB.
         *
         * @static
         * @memberof Asset
         */
      }], [{
        key: "native",
        value: function _native() {
          return new Asset2("XLM");
        }
        /**
         * Returns an asset object from its XDR object representation.
         * @param {xdr.Asset} assetXdr - The asset xdr object.
         * @returns {Asset}
         */
      }, {
        key: "fromOperation",
        value: function fromOperation(assetXdr) {
          var anum;
          var code;
          var issuer;
          switch (assetXdr["switch"]()) {
            case _xdr["default"].AssetType.assetTypeNative():
              return this["native"]();
            case _xdr["default"].AssetType.assetTypeCreditAlphanum4():
              anum = assetXdr.alphaNum4();
            /* falls through */
            case _xdr["default"].AssetType.assetTypeCreditAlphanum12():
              anum = anum || assetXdr.alphaNum12();
              issuer = _strkey.StrKey.encodeEd25519PublicKey(anum.issuer().ed25519());
              code = (0, _util.trimEnd)(anum.assetCode(), "\0");
              return new this(code, issuer);
            default:
              throw new Error("Invalid asset type: ".concat(assetXdr["switch"]().name));
          }
        }
      }, {
        key: "compare",
        value: function compare(assetA, assetB) {
          if (!assetA || !(assetA instanceof Asset2)) {
            throw new Error("assetA is invalid");
          }
          if (!assetB || !(assetB instanceof Asset2)) {
            throw new Error("assetB is invalid");
          }
          if (assetA.equals(assetB)) {
            return 0;
          }
          var xdrAtype = assetA.getRawAssetType().value;
          var xdrBtype = assetB.getRawAssetType().value;
          if (xdrAtype !== xdrBtype) {
            return xdrAtype < xdrBtype ? -1 : 1;
          }
          var result = asciiCompare(assetA.getCode(), assetB.getCode());
          if (result !== 0) {
            return result;
          }
          return asciiCompare(assetA.getIssuer(), assetB.getIssuer());
        }
      }]);
    }();
    function asciiCompare(a, b) {
      return Buffer.compare(Buffer.from(a, "ascii"), Buffer.from(b, "ascii"));
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/get_liquidity_pool_id.js
var require_get_liquidity_pool_id = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/get_liquidity_pool_id.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LiquidityPoolFeeV18 = void 0;
    exports.getLiquidityPoolId = getLiquidityPoolId;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _asset = require_asset();
    var _hashing = require_hashing();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var LiquidityPoolFeeV18 = exports.LiquidityPoolFeeV18 = 30;
    function getLiquidityPoolId(liquidityPoolType) {
      var liquidityPoolParameters = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (liquidityPoolType !== "constant_product") {
        throw new Error("liquidityPoolType is invalid");
      }
      var assetA = liquidityPoolParameters.assetA, assetB = liquidityPoolParameters.assetB, fee = liquidityPoolParameters.fee;
      if (!assetA || !(assetA instanceof _asset.Asset)) {
        throw new Error("assetA is invalid");
      }
      if (!assetB || !(assetB instanceof _asset.Asset)) {
        throw new Error("assetB is invalid");
      }
      if (!fee || fee !== LiquidityPoolFeeV18) {
        throw new Error("fee is invalid");
      }
      if (_asset.Asset.compare(assetA, assetB) !== -1) {
        throw new Error("Assets are not in lexicographic order");
      }
      var lpTypeData = _xdr["default"].LiquidityPoolType.liquidityPoolConstantProduct().toXDR();
      var lpParamsData = new _xdr["default"].LiquidityPoolConstantProductParameters({
        assetA: assetA.toXDRObject(),
        assetB: assetB.toXDRObject(),
        fee
      }).toXDR();
      var payload = Buffer.concat([lpTypeData, lpParamsData]);
      return (0, _hashing.hash)(payload);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/transaction_base.js
var require_transaction_base = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/transaction_base.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TransactionBase = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _hashing = require_hashing();
    var _keypair = require_keypair();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var TransactionBase = exports.TransactionBase = function() {
      function TransactionBase2(tx, signatures, fee, networkPassphrase) {
        _classCallCheck(this, TransactionBase2);
        if (typeof networkPassphrase !== "string") {
          throw new Error("Invalid passphrase provided to Transaction: expected a string but got a ".concat(_typeof(networkPassphrase)));
        }
        this._networkPassphrase = networkPassphrase;
        this._tx = tx;
        this._signatures = signatures;
        this._fee = fee;
      }
      return _createClass(TransactionBase2, [{
        key: "signatures",
        get: function get() {
          return this._signatures;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
      }, {
        key: "tx",
        get: function get() {
          return this._tx;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "fee",
        get: function get() {
          return this._fee;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "networkPassphrase",
        get: function get() {
          return this._networkPassphrase;
        },
        set: function set(networkPassphrase) {
          this._networkPassphrase = networkPassphrase;
        }
        /**
         * Signs the transaction with the given {@link Keypair}.
         * @param {...Keypair} keypairs Keypairs of signers
         * @returns {void}
         */
      }, {
        key: "sign",
        value: function sign() {
          var _this = this;
          var txHash = this.hash();
          for (var _len = arguments.length, keypairs = new Array(_len), _key = 0; _key < _len; _key++) {
            keypairs[_key] = arguments[_key];
          }
          keypairs.forEach(function(kp) {
            var sig = kp.signDecorated(txHash);
            _this.signatures.push(sig);
          });
        }
        /**
         * Signs a transaction with the given {@link Keypair}. Useful if someone sends
         * you a transaction XDR for you to sign and return (see
         * [addSignature](#addSignature) for more information).
         *
         * When you get a transaction XDR to sign....
         * - Instantiate a `Transaction` object with the XDR
         * - Use {@link Keypair} to generate a keypair object for your Stellar seed.
         * - Run `getKeypairSignature` with that keypair
         * - Send back the signature along with your publicKey (not your secret seed!)
         *
         * Example:
         * ```javascript
         * // `transactionXDR` is a string from the person generating the transaction
         * const transaction = new Transaction(transactionXDR, networkPassphrase);
         * const keypair = Keypair.fromSecret(myStellarSeed);
         * return transaction.getKeypairSignature(keypair);
         * ```
         *
         * @param {Keypair} keypair Keypair of signer
         * @returns {string} Signature string
         */
      }, {
        key: "getKeypairSignature",
        value: function getKeypairSignature(keypair) {
          return keypair.sign(this.hash()).toString("base64");
        }
        /**
         * Add a signature to the transaction. Useful when a party wants to pre-sign
         * a transaction but doesn't want to give access to their secret keys.
         * This will also verify whether the signature is valid.
         *
         * Here's how you would use this feature to solicit multiple signatures.
         * - Use `TransactionBuilder` to build a new transaction.
         * - Make sure to set a long enough timeout on that transaction to give your
         * signers enough time to sign!
         * - Once you build the transaction, use `transaction.toXDR()` to get the
         * base64-encoded XDR string.
         * - _Warning!_ Once you've built this transaction, don't submit any other
         * transactions onto your account! Doing so will invalidate this pre-compiled
         * transaction!
         * - Send this XDR string to your other parties. They can use the instructions
         * for [getKeypairSignature](#getKeypairSignature) to sign the transaction.
         * - They should send you back their `publicKey` and the `signature` string
         * from [getKeypairSignature](#getKeypairSignature), both of which you pass to
         * this function.
         *
         * @param {string} publicKey The public key of the signer
         * @param {string} signature The base64 value of the signature XDR
         * @returns {void}
         */
      }, {
        key: "addSignature",
        value: function addSignature() {
          var publicKey = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var signature = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          if (!signature || typeof signature !== "string") {
            throw new Error("Invalid signature");
          }
          if (!publicKey || typeof publicKey !== "string") {
            throw new Error("Invalid publicKey");
          }
          var keypair;
          var hint;
          var signatureBuffer = Buffer.from(signature, "base64");
          try {
            keypair = _keypair.Keypair.fromPublicKey(publicKey);
            hint = keypair.signatureHint();
          } catch (e) {
            throw new Error("Invalid publicKey");
          }
          if (!keypair.verify(this.hash(), signatureBuffer)) {
            throw new Error("Invalid signature");
          }
          this.signatures.push(new _xdr["default"].DecoratedSignature({
            hint,
            signature: signatureBuffer
          }));
        }
        /**
         * Add a decorated signature directly to the transaction envelope.
         *
         * @param {xdr.DecoratedSignature} signature    raw signature to add
         * @returns {void}
         *
         * @see Keypair.signDecorated
         * @see Keypair.signPayloadDecorated
         */
      }, {
        key: "addDecoratedSignature",
        value: function addDecoratedSignature(signature) {
          this.signatures.push(signature);
        }
        /**
         * Add `hashX` signer preimage as signature.
         * @param {Buffer|String} preimage Preimage of hash used as signer
         * @returns {void}
         */
      }, {
        key: "signHashX",
        value: function signHashX(preimage) {
          if (typeof preimage === "string") {
            preimage = Buffer.from(preimage, "hex");
          }
          if (preimage.length > 64) {
            throw new Error("preimage cannnot be longer than 64 bytes");
          }
          var signature = preimage;
          var hashX = (0, _hashing.hash)(preimage);
          var hint = hashX.slice(hashX.length - 4);
          this.signatures.push(new _xdr["default"].DecoratedSignature({
            hint,
            signature
          }));
        }
        /**
         * Returns a hash for this transaction, suitable for signing.
         * @returns {Buffer}
         */
      }, {
        key: "hash",
        value: function hash() {
          return (0, _hashing.hash)(this.signatureBase());
        }
      }, {
        key: "signatureBase",
        value: function signatureBase() {
          throw new Error("Implement in subclass");
        }
      }, {
        key: "toEnvelope",
        value: function toEnvelope() {
          throw new Error("Implement in subclass");
        }
        /**
         * Get the transaction envelope as a base64-encoded string
         * @returns {string} XDR string
         */
      }, {
        key: "toXDR",
        value: function toXDR() {
          return this.toEnvelope().toXDR().toString("base64");
        }
      }]);
    }();
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: " ",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++) ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--) ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++) ;
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++) ;
              str = toExponential(str, e);
            } else {
              i -= ne + (id === 2 && e > ne);
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0") ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i++) ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null) m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0)) ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0) for (; b--; xc[i++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b) ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0)) ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i;
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z) ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/util/bignumber.js
var require_bignumber2 = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/util/bignumber.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _bignumber = _interopRequireDefault(require_bignumber());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var BigNumber = _bignumber["default"].clone();
    BigNumber.DEBUG = true;
    var _default = exports["default"] = BigNumber;
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/util/continued_fraction.js
var require_continued_fraction = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/util/continued_fraction.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.best_r = best_r;
    var _bignumber = _interopRequireDefault(require_bignumber2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    var MAX_INT = (1 << 31 >>> 0) - 1;
    function best_r(rawNumber) {
      var number = new _bignumber["default"](rawNumber);
      var a;
      var f;
      var fractions = [[new _bignumber["default"](0), new _bignumber["default"](1)], [new _bignumber["default"](1), new _bignumber["default"](0)]];
      var i = 2;
      while (true) {
        if (number.gt(MAX_INT)) {
          break;
        }
        a = number.integerValue(_bignumber["default"].ROUND_FLOOR);
        f = number.minus(a);
        var h = a.times(fractions[i - 1][0]).plus(fractions[i - 2][0]);
        var k = a.times(fractions[i - 1][1]).plus(fractions[i - 2][1]);
        if (h.gt(MAX_INT) || k.gt(MAX_INT)) {
          break;
        }
        fractions.push([h, k]);
        if (f.eq(0)) {
          break;
        }
        number = new _bignumber["default"](1).div(f);
        i += 1;
      }
      var _fractions = _slicedToArray(fractions[fractions.length - 1], 2), n = _fractions[0], d = _fractions[1];
      if (n.isZero() || d.isZero()) {
        throw new Error("Couldn't find approximation");
      }
      return [n.toNumber(), d.toNumber()];
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/liquidity_pool_asset.js
var require_liquidity_pool_asset = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/liquidity_pool_asset.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LiquidityPoolAsset = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _asset = require_asset();
    var _get_liquidity_pool_id = require_get_liquidity_pool_id();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var LiquidityPoolAsset = exports.LiquidityPoolAsset = function() {
      function LiquidityPoolAsset2(assetA, assetB, fee) {
        _classCallCheck(this, LiquidityPoolAsset2);
        if (!assetA || !(assetA instanceof _asset.Asset)) {
          throw new Error("assetA is invalid");
        }
        if (!assetB || !(assetB instanceof _asset.Asset)) {
          throw new Error("assetB is invalid");
        }
        if (_asset.Asset.compare(assetA, assetB) !== -1) {
          throw new Error("Assets are not in lexicographic order");
        }
        if (!fee || fee !== _get_liquidity_pool_id.LiquidityPoolFeeV18) {
          throw new Error("fee is invalid");
        }
        this.assetA = assetA;
        this.assetB = assetB;
        this.fee = fee;
      }
      return _createClass(LiquidityPoolAsset2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the `xdr.ChangeTrustAsset` object for this liquidity pool asset.
           *
           * Note: To convert from an {@link Asset `Asset`} to `xdr.ChangeTrustAsset`
           * please refer to the
           * {@link Asset.toChangeTrustXDRObject `Asset.toChangeTrustXDRObject`} method.
           *
           * @returns {xdr.ChangeTrustAsset} XDR ChangeTrustAsset object.
           */
          function toXDRObject() {
            var lpConstantProductParamsXdr = new _xdr["default"].LiquidityPoolConstantProductParameters({
              assetA: this.assetA.toXDRObject(),
              assetB: this.assetB.toXDRObject(),
              fee: this.fee
            });
            var lpParamsXdr = new _xdr["default"].LiquidityPoolParameters("liquidityPoolConstantProduct", lpConstantProductParamsXdr);
            return new _xdr["default"].ChangeTrustAsset("assetTypePoolShare", lpParamsXdr);
          }
        )
        /**
         * @returns {LiquidityPoolParameters} Liquidity pool parameters.
         */
      }, {
        key: "getLiquidityPoolParameters",
        value: function getLiquidityPoolParameters() {
          return _objectSpread(_objectSpread({}, this), {}, {
            assetA: this.assetA,
            assetB: this.assetB,
            fee: this.fee
          });
        }
        /**
         * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
         * @returns {AssetType.liquidityPoolShares} asset type. Can only be `liquidity_pool_shares`.
         */
      }, {
        key: "getAssetType",
        value: function getAssetType() {
          return "liquidity_pool_shares";
        }
        /**
         * @param {LiquidityPoolAsset} other the LiquidityPoolAsset to compare
         * @returns {boolean} `true` if this asset equals the given asset.
         */
      }, {
        key: "equals",
        value: function equals(other) {
          return this.assetA.equals(other.assetA) && this.assetB.equals(other.assetB) && this.fee === other.fee;
        }
      }, {
        key: "toString",
        value: function toString() {
          var poolId = (0, _get_liquidity_pool_id.getLiquidityPoolId)("constant_product", this.getLiquidityPoolParameters()).toString("hex");
          return "liquidity_pool:".concat(poolId);
        }
      }], [{
        key: "fromOperation",
        value: function fromOperation(ctAssetXdr) {
          var assetType = ctAssetXdr["switch"]();
          if (assetType === _xdr["default"].AssetType.assetTypePoolShare()) {
            var liquidityPoolParameters = ctAssetXdr.liquidityPool().constantProduct();
            return new this(_asset.Asset.fromOperation(liquidityPoolParameters.assetA()), _asset.Asset.fromOperation(liquidityPoolParameters.assetB()), liquidityPoolParameters.fee());
          }
          throw new Error("Invalid asset type: ".concat(assetType.name));
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/claimant.js
var require_claimant = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/claimant.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Claimant = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Claimant = exports.Claimant = function() {
      function Claimant2(destination, predicate) {
        _classCallCheck(this, Claimant2);
        if (destination && !_strkey.StrKey.isValidEd25519PublicKey(destination)) {
          throw new Error("Destination is invalid");
        }
        this._destination = destination;
        if (!predicate) {
          this._predicate = _xdr["default"].ClaimPredicate.claimPredicateUnconditional();
        } else if (predicate instanceof _xdr["default"].ClaimPredicate) {
          this._predicate = predicate;
        } else {
          throw new Error("Predicate should be an xdr.ClaimPredicate");
        }
      }
      return _createClass(Claimant2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the xdr object for this claimant.
           * @returns {xdr.Claimant} XDR Claimant object
           */
          function toXDRObject() {
            var claimant = new _xdr["default"].ClaimantV0({
              destination: _keypair.Keypair.fromPublicKey(this._destination).xdrAccountId(),
              predicate: this._predicate
            });
            return _xdr["default"].Claimant.claimantTypeV0(claimant);
          }
        )
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "destination",
        get: function get() {
          return this._destination;
        },
        set: function set(value) {
          throw new Error("Claimant is immutable");
        }
        /**
         * @type {xdr.ClaimPredicate}
         * @readonly
         */
      }, {
        key: "predicate",
        get: function get() {
          return this._predicate;
        },
        set: function set(value) {
          throw new Error("Claimant is immutable");
        }
      }], [{
        key: "predicateUnconditional",
        value: function predicateUnconditional() {
          return _xdr["default"].ClaimPredicate.claimPredicateUnconditional();
        }
        /**
         * Returns an `and` claim predicate
         * @param {xdr.ClaimPredicate} left an xdr.ClaimPredicate
         * @param {xdr.ClaimPredicate} right an xdr.ClaimPredicate
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateAnd",
        value: function predicateAnd(left, right) {
          if (!(left instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("left Predicate should be an xdr.ClaimPredicate");
          }
          if (!(right instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("right Predicate should be an xdr.ClaimPredicate");
          }
          return _xdr["default"].ClaimPredicate.claimPredicateAnd([left, right]);
        }
        /**
         * Returns an `or` claim predicate
         * @param {xdr.ClaimPredicate} left an xdr.ClaimPredicate
         * @param {xdr.ClaimPredicate} right an xdr.ClaimPredicate
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateOr",
        value: function predicateOr(left, right) {
          if (!(left instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("left Predicate should be an xdr.ClaimPredicate");
          }
          if (!(right instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("right Predicate should be an xdr.ClaimPredicate");
          }
          return _xdr["default"].ClaimPredicate.claimPredicateOr([left, right]);
        }
        /**
         * Returns a `not` claim predicate
         * @param {xdr.ClaimPredicate} predicate an xdr.ClaimPredicate
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateNot",
        value: function predicateNot(predicate) {
          if (!(predicate instanceof _xdr["default"].ClaimPredicate)) {
            throw new Error("right Predicate should be an xdr.ClaimPredicate");
          }
          return _xdr["default"].ClaimPredicate.claimPredicateNot(predicate);
        }
        /**
         * Returns a `BeforeAbsoluteTime` claim predicate
         *
         * This predicate will be fulfilled if the closing time of the ledger that
         * includes the CreateClaimableBalance operation is less than this (absolute)
         * Unix timestamp (expressed in seconds).
         *
         * @param {string} absBefore Unix epoch (in seconds) as a string
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateBeforeAbsoluteTime",
        value: function predicateBeforeAbsoluteTime(absBefore) {
          return _xdr["default"].ClaimPredicate.claimPredicateBeforeAbsoluteTime(_xdr["default"].Int64.fromString(absBefore));
        }
        /**
         * Returns a `BeforeRelativeTime` claim predicate
         *
         * This predicate will be fulfilled if the closing time of the ledger that
         * includes the CreateClaimableBalance operation plus this relative time delta
         * (in seconds) is less than the current time.
         *
         * @param {strings} seconds seconds since closeTime of the ledger in which the ClaimableBalanceEntry was created (as string)
         * @Return {xdr.ClaimPredicate}
         */
      }, {
        key: "predicateBeforeRelativeTime",
        value: function predicateBeforeRelativeTime(seconds) {
          return _xdr["default"].ClaimPredicate.claimPredicateBeforeRelativeTime(_xdr["default"].Int64.fromString(seconds));
        }
        /**
         * Returns a claimant object from its XDR object representation.
         * @param {xdr.Claimant} claimantXdr - The claimant xdr object.
         * @returns {Claimant}
         */
      }, {
        key: "fromXDR",
        value: function fromXDR(claimantXdr) {
          var value;
          switch (claimantXdr["switch"]()) {
            case _xdr["default"].ClaimantType.claimantTypeV0():
              value = claimantXdr.v0();
              return new this(_strkey.StrKey.encodeEd25519PublicKey(value.destination().ed25519()), value.predicate());
            default:
              throw new Error("Invalid claimant type: ".concat(claimantXdr["switch"]().name));
          }
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/liquidity_pool_id.js
var require_liquidity_pool_id = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/liquidity_pool_id.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LiquidityPoolId = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var LiquidityPoolId = exports.LiquidityPoolId = function() {
      function LiquidityPoolId2(liquidityPoolId) {
        _classCallCheck(this, LiquidityPoolId2);
        if (!liquidityPoolId) {
          throw new Error("liquidityPoolId cannot be empty");
        }
        if (!/^[a-f0-9]{64}$/.test(liquidityPoolId)) {
          throw new Error("Liquidity pool ID is not a valid hash");
        }
        this.liquidityPoolId = liquidityPoolId;
      }
      return _createClass(LiquidityPoolId2, [{
        key: "toXDRObject",
        value: (
          /**
           * Returns the `xdr.TrustLineAsset` object for this liquidity pool ID.
           *
           * Note: To convert from {@link Asset `Asset`} to `xdr.TrustLineAsset` please
           * refer to the
           * {@link Asset.toTrustLineXDRObject `Asset.toTrustLineXDRObject`} method.
           *
           * @returns {xdr.TrustLineAsset} XDR LiquidityPoolId object
           */
          function toXDRObject() {
            var xdrPoolId = _xdr["default"].PoolId.fromXDR(this.liquidityPoolId, "hex");
            return new _xdr["default"].TrustLineAsset("assetTypePoolShare", xdrPoolId);
          }
        )
        /**
         * @returns {string} Liquidity pool ID.
         */
      }, {
        key: "getLiquidityPoolId",
        value: function getLiquidityPoolId() {
          return String(this.liquidityPoolId);
        }
        /**
         * @see [Assets concept](https://developers.stellar.org/docs/glossary/assets/)
         * @returns {AssetType.liquidityPoolShares} asset type. Can only be `liquidity_pool_shares`.
         */
      }, {
        key: "getAssetType",
        value: function getAssetType() {
          return "liquidity_pool_shares";
        }
        /**
         * @param {LiquidityPoolId} asset LiquidityPoolId to compare.
         * @returns {boolean} `true` if this asset equals the given asset.
         */
      }, {
        key: "equals",
        value: function equals(asset) {
          return this.liquidityPoolId === asset.getLiquidityPoolId();
        }
      }, {
        key: "toString",
        value: function toString() {
          return "liquidity_pool:".concat(this.liquidityPoolId);
        }
      }], [{
        key: "fromOperation",
        value: function fromOperation(tlAssetXdr) {
          var assetType = tlAssetXdr["switch"]();
          if (assetType === _xdr["default"].AssetType.assetTypePoolShare()) {
            var liquidityPoolId = tlAssetXdr.liquidityPoolId().toString("hex");
            return new this(liquidityPoolId);
          }
          throw new Error("Invalid asset type: ".concat(assetType.name));
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_sell_offer.js
var require_manage_sell_offer = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_sell_offer.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.manageSellOffer = manageSellOffer;
    var _jsXdr = require_xdr();
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function manageSellOffer(opts) {
      var attributes = {};
      attributes.selling = opts.selling.toXDRObject();
      attributes.buying = opts.buying.toXDRObject();
      if (!this.isValidAmount(opts.amount, true)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      if (opts.price === void 0) {
        throw new TypeError("price argument is required");
      }
      attributes.price = this._toXDRPrice(opts.price);
      if (opts.offerId !== void 0) {
        opts.offerId = opts.offerId.toString();
      } else {
        opts.offerId = "0";
      }
      attributes.offerId = _jsXdr.Hyper.fromString(opts.offerId);
      var manageSellOfferOp = new _xdr["default"].ManageSellOfferOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.manageSellOffer(manageSellOfferOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/create_passive_sell_offer.js
var require_create_passive_sell_offer = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/create_passive_sell_offer.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createPassiveSellOffer = createPassiveSellOffer;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function createPassiveSellOffer(opts) {
      var attributes = {};
      attributes.selling = opts.selling.toXDRObject();
      attributes.buying = opts.buying.toXDRObject();
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      if (opts.price === void 0) {
        throw new TypeError("price argument is required");
      }
      attributes.price = this._toXDRPrice(opts.price);
      var createPassiveSellOfferOp = new _xdr["default"].CreatePassiveSellOfferOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.createPassiveSellOffer(createPassiveSellOfferOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js
var require_decode_encode_muxed_account = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/util/decode_encode_muxed_account.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.decodeAddressToMuxedAccount = decodeAddressToMuxedAccount;
    exports.encodeMuxedAccount = encodeMuxedAccount;
    exports.encodeMuxedAccountToAddress = encodeMuxedAccountToAddress;
    exports.extractBaseAddress = extractBaseAddress;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function decodeAddressToMuxedAccount(address) {
      if (_strkey.StrKey.isValidMed25519PublicKey(address)) {
        return _decodeAddressFullyToMuxedAccount(address);
      }
      return _xdr["default"].MuxedAccount.keyTypeEd25519(_strkey.StrKey.decodeEd25519PublicKey(address));
    }
    function encodeMuxedAccountToAddress(muxedAccount) {
      if (muxedAccount["switch"]().value === _xdr["default"].CryptoKeyType.keyTypeMuxedEd25519().value) {
        return _encodeMuxedAccountFullyToAddress(muxedAccount);
      }
      return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.ed25519());
    }
    function encodeMuxedAccount(address, id) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(address)) {
        throw new Error("address should be a Stellar account ID (G...)");
      }
      if (typeof id !== "string") {
        throw new Error("id should be a string representing a number (uint64)");
      }
      return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
        id: _xdr["default"].Uint64.fromString(id),
        ed25519: _strkey.StrKey.decodeEd25519PublicKey(address)
      }));
    }
    function extractBaseAddress(address) {
      if (_strkey.StrKey.isValidEd25519PublicKey(address)) {
        return address;
      }
      if (!_strkey.StrKey.isValidMed25519PublicKey(address)) {
        throw new TypeError("expected muxed account (M...), got ".concat(address));
      }
      var muxedAccount = decodeAddressToMuxedAccount(address);
      return _strkey.StrKey.encodeEd25519PublicKey(muxedAccount.med25519().ed25519());
    }
    function _decodeAddressFullyToMuxedAccount(address) {
      var rawBytes = _strkey.StrKey.decodeMed25519PublicKey(address);
      return _xdr["default"].MuxedAccount.keyTypeMuxedEd25519(new _xdr["default"].MuxedAccountMed25519({
        id: _xdr["default"].Uint64.fromXDR(rawBytes.subarray(-8)),
        ed25519: rawBytes.subarray(0, -8)
      }));
    }
    function _encodeMuxedAccountFullyToAddress(muxedAccount) {
      if (muxedAccount["switch"]() === _xdr["default"].CryptoKeyType.keyTypeEd25519()) {
        return encodeMuxedAccountToAddress(muxedAccount);
      }
      var muxed = muxedAccount.med25519();
      return _strkey.StrKey.encodeMed25519PublicKey(Buffer.concat([muxed.ed25519(), muxed.id().toXDR("raw")]));
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/account_merge.js
var require_account_merge = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/account_merge.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.accountMerge = accountMerge;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function accountMerge(opts) {
      var opAttributes = {};
      try {
        opAttributes.body = _xdr["default"].OperationBody.accountMerge((0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination));
      } catch (e) {
        throw new Error("destination is invalid");
      }
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/allow_trust.js
var require_allow_trust = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/allow_trust.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.allowTrust = allowTrust;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function allowTrust(opts) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.trustor)) {
        throw new Error("trustor is invalid");
      }
      var attributes = {};
      attributes.trustor = _keypair.Keypair.fromPublicKey(opts.trustor).xdrAccountId();
      if (opts.assetCode.length <= 4) {
        var code = opts.assetCode.padEnd(4, "\0");
        attributes.asset = _xdr["default"].AssetCode.assetTypeCreditAlphanum4(code);
      } else if (opts.assetCode.length <= 12) {
        var _code = opts.assetCode.padEnd(12, "\0");
        attributes.asset = _xdr["default"].AssetCode.assetTypeCreditAlphanum12(_code);
      } else {
        throw new Error("Asset code must be 12 characters at max.");
      }
      if (typeof opts.authorize === "boolean") {
        if (opts.authorize) {
          attributes.authorize = _xdr["default"].TrustLineFlags.authorizedFlag().value;
        } else {
          attributes.authorize = 0;
        }
      } else {
        attributes.authorize = opts.authorize;
      }
      var allowTrustOp = new _xdr["default"].AllowTrustOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.allowTrust(allowTrustOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/bump_sequence.js
var require_bump_sequence = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/bump_sequence.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bumpSequence = bumpSequence;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber2());
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function bumpSequence(opts) {
      var attributes = {};
      if (typeof opts.bumpTo !== "string") {
        throw new Error("bumpTo must be a string");
      }
      try {
        new _bignumber["default"](opts.bumpTo);
      } catch (e) {
        throw new Error("bumpTo must be a stringified number");
      }
      attributes.bumpTo = _jsXdr.Hyper.fromString(opts.bumpTo);
      var bumpSequenceOp = new _xdr["default"].BumpSequenceOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.bumpSequence(bumpSequenceOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/change_trust.js
var require_change_trust = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/change_trust.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.changeTrust = changeTrust;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber2());
    var _xdr = _interopRequireDefault(require_xdr2());
    var _asset = require_asset();
    var _liquidity_pool_asset = require_liquidity_pool_asset();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var MAX_INT64 = "9223372036854775807";
    function changeTrust(opts) {
      var attributes = {};
      if (opts.asset instanceof _asset.Asset) {
        attributes.line = opts.asset.toChangeTrustXDRObject();
      } else if (opts.asset instanceof _liquidity_pool_asset.LiquidityPoolAsset) {
        attributes.line = opts.asset.toXDRObject();
      } else {
        throw new TypeError("asset must be Asset or LiquidityPoolAsset");
      }
      if (opts.limit !== void 0 && !this.isValidAmount(opts.limit, true)) {
        throw new TypeError(this.constructAmountRequirementsError("limit"));
      }
      if (opts.limit) {
        attributes.limit = this._toXDRAmount(opts.limit);
      } else {
        attributes.limit = _jsXdr.Hyper.fromString(new _bignumber["default"](MAX_INT64).toString());
      }
      if (opts.source) {
        attributes.source = opts.source.masterKeypair;
      }
      var changeTrustOP = new _xdr["default"].ChangeTrustOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.changeTrust(changeTrustOP);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/create_account.js
var require_create_account = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/create_account.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createAccount = createAccount;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function createAccount(opts) {
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.destination)) {
        throw new Error("destination is invalid");
      }
      if (!this.isValidAmount(opts.startingBalance, true)) {
        throw new TypeError(this.constructAmountRequirementsError("startingBalance"));
      }
      var attributes = {};
      attributes.destination = _keypair.Keypair.fromPublicKey(opts.destination).xdrAccountId();
      attributes.startingBalance = this._toXDRAmount(opts.startingBalance);
      var createAccountOp = new _xdr["default"].CreateAccountOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.createAccount(createAccountOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/create_claimable_balance.js
var require_create_claimable_balance = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/create_claimable_balance.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createClaimableBalance = createClaimableBalance;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _asset = require_asset();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function createClaimableBalance(opts) {
      if (!(opts.asset instanceof _asset.Asset)) {
        throw new Error("must provide an asset for create claimable balance operation");
      }
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      if (!Array.isArray(opts.claimants) || opts.claimants.length === 0) {
        throw new Error("must provide at least one claimant");
      }
      var attributes = {};
      attributes.asset = opts.asset.toXDRObject();
      attributes.amount = this._toXDRAmount(opts.amount);
      attributes.claimants = Object.values(opts.claimants).map(function(c) {
        return c.toXDRObject();
      });
      var createClaimableBalanceOp = new _xdr["default"].CreateClaimableBalanceOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.createClaimableBalance(createClaimableBalanceOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/claim_claimable_balance.js
var require_claim_claimable_balance = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/claim_claimable_balance.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.claimClaimableBalance = claimClaimableBalance;
    exports.validateClaimableBalanceId = validateClaimableBalanceId;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function claimClaimableBalance() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      validateClaimableBalanceId(opts.balanceId);
      var attributes = {};
      attributes.balanceId = _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, "hex");
      var claimClaimableBalanceOp = new _xdr["default"].ClaimClaimableBalanceOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.claimClaimableBalance(claimClaimableBalanceOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function validateClaimableBalanceId(balanceId) {
      if (typeof balanceId !== "string" || balanceId.length !== 8 + 64) {
        throw new Error("must provide a valid claimable balance id");
      }
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/clawback_claimable_balance.js
var require_clawback_claimable_balance = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/clawback_claimable_balance.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clawbackClaimableBalance = clawbackClaimableBalance;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _claim_claimable_balance = require_claim_claimable_balance();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function clawbackClaimableBalance() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      (0, _claim_claimable_balance.validateClaimableBalanceId)(opts.balanceId);
      var attributes = {
        balanceId: _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, "hex")
      };
      var opAttributes = {
        body: _xdr["default"].OperationBody.clawbackClaimableBalance(new _xdr["default"].ClawbackClaimableBalanceOp(attributes))
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/inflation.js
var require_inflation = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/inflation.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.inflation = inflation;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function inflation() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.inflation();
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_data.js
var require_manage_data = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_data.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.manageData = manageData;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function manageData(opts) {
      var attributes = {};
      if (!(typeof opts.name === "string" && opts.name.length <= 64)) {
        throw new Error("name must be a string, up to 64 characters");
      }
      attributes.dataName = opts.name;
      if (typeof opts.value !== "string" && !Buffer.isBuffer(opts.value) && opts.value !== null) {
        throw new Error("value must be a string, Buffer or null");
      }
      if (typeof opts.value === "string") {
        attributes.dataValue = Buffer.from(opts.value);
      } else {
        attributes.dataValue = opts.value;
      }
      if (attributes.dataValue !== null && attributes.dataValue.length > 64) {
        throw new Error("value cannot be longer that 64 bytes");
      }
      var manageDataOp = new _xdr["default"].ManageDataOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.manageData(manageDataOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_buy_offer.js
var require_manage_buy_offer = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/manage_buy_offer.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.manageBuyOffer = manageBuyOffer;
    var _jsXdr = require_xdr();
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function manageBuyOffer(opts) {
      var attributes = {};
      attributes.selling = opts.selling.toXDRObject();
      attributes.buying = opts.buying.toXDRObject();
      if (!this.isValidAmount(opts.buyAmount, true)) {
        throw new TypeError(this.constructAmountRequirementsError("buyAmount"));
      }
      attributes.buyAmount = this._toXDRAmount(opts.buyAmount);
      if (opts.price === void 0) {
        throw new TypeError("price argument is required");
      }
      attributes.price = this._toXDRPrice(opts.price);
      if (opts.offerId !== void 0) {
        opts.offerId = opts.offerId.toString();
      } else {
        opts.offerId = "0";
      }
      attributes.offerId = _jsXdr.Hyper.fromString(opts.offerId);
      var manageBuyOfferOp = new _xdr["default"].ManageBuyOfferOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.manageBuyOffer(manageBuyOfferOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_receive.js
var require_path_payment_strict_receive = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_receive.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pathPaymentStrictReceive = pathPaymentStrictReceive;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function pathPaymentStrictReceive(opts) {
      switch (true) {
        case !opts.sendAsset:
          throw new Error("Must specify a send asset");
        case !this.isValidAmount(opts.sendMax):
          throw new TypeError(this.constructAmountRequirementsError("sendMax"));
        case !opts.destAsset:
          throw new Error("Must provide a destAsset for a payment operation");
        case !this.isValidAmount(opts.destAmount):
          throw new TypeError(this.constructAmountRequirementsError("destAmount"));
        default:
          break;
      }
      var attributes = {};
      attributes.sendAsset = opts.sendAsset.toXDRObject();
      attributes.sendMax = this._toXDRAmount(opts.sendMax);
      try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
      } catch (e) {
        throw new Error("destination is invalid");
      }
      attributes.destAsset = opts.destAsset.toXDRObject();
      attributes.destAmount = this._toXDRAmount(opts.destAmount);
      var path = opts.path ? opts.path : [];
      attributes.path = path.map(function(x) {
        return x.toXDRObject();
      });
      var payment = new _xdr["default"].PathPaymentStrictReceiveOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.pathPaymentStrictReceive(payment);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_send.js
var require_path_payment_strict_send = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/path_payment_strict_send.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.pathPaymentStrictSend = pathPaymentStrictSend;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function pathPaymentStrictSend(opts) {
      switch (true) {
        case !opts.sendAsset:
          throw new Error("Must specify a send asset");
        case !this.isValidAmount(opts.sendAmount):
          throw new TypeError(this.constructAmountRequirementsError("sendAmount"));
        case !opts.destAsset:
          throw new Error("Must provide a destAsset for a payment operation");
        case !this.isValidAmount(opts.destMin):
          throw new TypeError(this.constructAmountRequirementsError("destMin"));
        default:
          break;
      }
      var attributes = {};
      attributes.sendAsset = opts.sendAsset.toXDRObject();
      attributes.sendAmount = this._toXDRAmount(opts.sendAmount);
      try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
      } catch (e) {
        throw new Error("destination is invalid");
      }
      attributes.destAsset = opts.destAsset.toXDRObject();
      attributes.destMin = this._toXDRAmount(opts.destMin);
      var path = opts.path ? opts.path : [];
      attributes.path = path.map(function(x) {
        return x.toXDRObject();
      });
      var payment = new _xdr["default"].PathPaymentStrictSendOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.pathPaymentStrictSend(payment);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/payment.js
var require_payment = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/payment.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.payment = payment;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function payment(opts) {
      if (!opts.asset) {
        throw new Error("Must provide an asset for a payment operation");
      }
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      var attributes = {};
      try {
        attributes.destination = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.destination);
      } catch (e) {
        throw new Error("destination is invalid");
      }
      attributes.asset = opts.asset.toXDRObject();
      attributes.amount = this._toXDRAmount(opts.amount);
      var paymentOp = new _xdr["default"].PaymentOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.payment(paymentOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/set_options.js
var require_set_options = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/set_options.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.setOptions = setOptions;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function weightCheckFunction(value, name) {
      if (value >= 0 && value <= 255) {
        return true;
      }
      throw new Error("".concat(name, " value must be between 0 and 255"));
    }
    function setOptions(opts) {
      var attributes = {};
      if (opts.inflationDest) {
        if (!_strkey.StrKey.isValidEd25519PublicKey(opts.inflationDest)) {
          throw new Error("inflationDest is invalid");
        }
        attributes.inflationDest = _keypair.Keypair.fromPublicKey(opts.inflationDest).xdrAccountId();
      }
      attributes.clearFlags = this._checkUnsignedIntValue("clearFlags", opts.clearFlags);
      attributes.setFlags = this._checkUnsignedIntValue("setFlags", opts.setFlags);
      attributes.masterWeight = this._checkUnsignedIntValue("masterWeight", opts.masterWeight, weightCheckFunction);
      attributes.lowThreshold = this._checkUnsignedIntValue("lowThreshold", opts.lowThreshold, weightCheckFunction);
      attributes.medThreshold = this._checkUnsignedIntValue("medThreshold", opts.medThreshold, weightCheckFunction);
      attributes.highThreshold = this._checkUnsignedIntValue("highThreshold", opts.highThreshold, weightCheckFunction);
      if (opts.homeDomain !== void 0 && typeof opts.homeDomain !== "string") {
        throw new TypeError("homeDomain argument must be of type String");
      }
      attributes.homeDomain = opts.homeDomain;
      if (opts.signer) {
        var weight = this._checkUnsignedIntValue("signer.weight", opts.signer.weight, weightCheckFunction);
        var key;
        var setValues = 0;
        if (opts.signer.ed25519PublicKey) {
          if (!_strkey.StrKey.isValidEd25519PublicKey(opts.signer.ed25519PublicKey)) {
            throw new Error("signer.ed25519PublicKey is invalid.");
          }
          var rawKey = _strkey.StrKey.decodeEd25519PublicKey(opts.signer.ed25519PublicKey);
          key = new _xdr["default"].SignerKey.signerKeyTypeEd25519(rawKey);
          setValues += 1;
        }
        if (opts.signer.preAuthTx) {
          if (typeof opts.signer.preAuthTx === "string") {
            opts.signer.preAuthTx = Buffer.from(opts.signer.preAuthTx, "hex");
          }
          if (!(Buffer.isBuffer(opts.signer.preAuthTx) && opts.signer.preAuthTx.length === 32)) {
            throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
          }
          key = new _xdr["default"].SignerKey.signerKeyTypePreAuthTx(opts.signer.preAuthTx);
          setValues += 1;
        }
        if (opts.signer.sha256Hash) {
          if (typeof opts.signer.sha256Hash === "string") {
            opts.signer.sha256Hash = Buffer.from(opts.signer.sha256Hash, "hex");
          }
          if (!(Buffer.isBuffer(opts.signer.sha256Hash) && opts.signer.sha256Hash.length === 32)) {
            throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
          }
          key = new _xdr["default"].SignerKey.signerKeyTypeHashX(opts.signer.sha256Hash);
          setValues += 1;
        }
        if (opts.signer.ed25519SignedPayload) {
          if (!_strkey.StrKey.isValidSignedPayload(opts.signer.ed25519SignedPayload)) {
            throw new Error("signer.ed25519SignedPayload is invalid.");
          }
          var _rawKey = _strkey.StrKey.decodeSignedPayload(opts.signer.ed25519SignedPayload);
          var signedPayloadXdr = _xdr["default"].SignerKeyEd25519SignedPayload.fromXDR(_rawKey);
          key = _xdr["default"].SignerKey.signerKeyTypeEd25519SignedPayload(signedPayloadXdr);
          setValues += 1;
        }
        if (setValues !== 1) {
          throw new Error("Signer object must contain exactly one of signer.ed25519PublicKey, signer.sha256Hash, signer.preAuthTx.");
        }
        attributes.signer = new _xdr["default"].Signer({
          key,
          weight
        });
      }
      var setOptionsOp = new _xdr["default"].SetOptionsOp(attributes);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.setOptions(setOptionsOp);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/begin_sponsoring_future_reserves.js
var require_begin_sponsoring_future_reserves = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/begin_sponsoring_future_reserves.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.beginSponsoringFutureReserves = beginSponsoringFutureReserves;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _strkey = require_strkey();
    var _keypair = require_keypair();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function beginSponsoringFutureReserves() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.sponsoredId)) {
        throw new Error("sponsoredId is invalid");
      }
      var op = new _xdr["default"].BeginSponsoringFutureReservesOp({
        sponsoredId: _keypair.Keypair.fromPublicKey(opts.sponsoredId).xdrAccountId()
      });
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.beginSponsoringFutureReserves(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/end_sponsoring_future_reserves.js
var require_end_sponsoring_future_reserves = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/end_sponsoring_future_reserves.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.endSponsoringFutureReserves = endSponsoringFutureReserves;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function endSponsoringFutureReserves() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.endSponsoringFutureReserves();
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/revoke_sponsorship.js
var require_revoke_sponsorship = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/revoke_sponsorship.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.revokeAccountSponsorship = revokeAccountSponsorship;
    exports.revokeClaimableBalanceSponsorship = revokeClaimableBalanceSponsorship;
    exports.revokeDataSponsorship = revokeDataSponsorship;
    exports.revokeLiquidityPoolSponsorship = revokeLiquidityPoolSponsorship;
    exports.revokeOfferSponsorship = revokeOfferSponsorship;
    exports.revokeSignerSponsorship = revokeSignerSponsorship;
    exports.revokeTrustlineSponsorship = revokeTrustlineSponsorship;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _strkey = require_strkey();
    var _keypair = require_keypair();
    var _asset = require_asset();
    var _liquidity_pool_id = require_liquidity_pool_id();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function revokeAccountSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.account(new _xdr["default"].LedgerKeyAccount({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId()
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeTrustlineSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      var asset;
      if (opts.asset instanceof _asset.Asset) {
        asset = opts.asset.toTrustLineXDRObject();
      } else if (opts.asset instanceof _liquidity_pool_id.LiquidityPoolId) {
        asset = opts.asset.toXDRObject();
      } else {
        throw new TypeError("asset must be an Asset or LiquidityPoolId");
      }
      var ledgerKey = _xdr["default"].LedgerKey.trustline(new _xdr["default"].LedgerKeyTrustLine({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        asset
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeOfferSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.seller)) {
        throw new Error("seller is invalid");
      }
      if (typeof opts.offerId !== "string") {
        throw new Error("offerId is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.offer(new _xdr["default"].LedgerKeyOffer({
        sellerId: _keypair.Keypair.fromPublicKey(opts.seller).xdrAccountId(),
        offerId: _xdr["default"].Int64.fromString(opts.offerId)
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeDataSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      if (typeof opts.name !== "string" || opts.name.length > 64) {
        throw new Error("name must be a string, up to 64 characters");
      }
      var ledgerKey = _xdr["default"].LedgerKey.data(new _xdr["default"].LedgerKeyData({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        dataName: opts.name
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeClaimableBalanceSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (typeof opts.balanceId !== "string") {
        throw new Error("balanceId is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.claimableBalance(new _xdr["default"].LedgerKeyClaimableBalance({
        balanceId: _xdr["default"].ClaimableBalanceId.fromXDR(opts.balanceId, "hex")
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeLiquidityPoolSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (typeof opts.liquidityPoolId !== "string") {
        throw new Error("liquidityPoolId is invalid");
      }
      var ledgerKey = _xdr["default"].LedgerKey.liquidityPool(new _xdr["default"].LedgerKeyLiquidityPool({
        liquidityPoolId: _xdr["default"].PoolId.fromXDR(opts.liquidityPoolId, "hex")
      }));
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipLedgerEntry(ledgerKey);
      var opAttributes = {
        body: _xdr["default"].OperationBody.revokeSponsorship(op)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function revokeSignerSponsorship() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!_strkey.StrKey.isValidEd25519PublicKey(opts.account)) {
        throw new Error("account is invalid");
      }
      var key;
      if (opts.signer.ed25519PublicKey) {
        if (!_strkey.StrKey.isValidEd25519PublicKey(opts.signer.ed25519PublicKey)) {
          throw new Error("signer.ed25519PublicKey is invalid.");
        }
        var rawKey = _strkey.StrKey.decodeEd25519PublicKey(opts.signer.ed25519PublicKey);
        key = new _xdr["default"].SignerKey.signerKeyTypeEd25519(rawKey);
      } else if (opts.signer.preAuthTx) {
        var buffer;
        if (typeof opts.signer.preAuthTx === "string") {
          buffer = Buffer.from(opts.signer.preAuthTx, "hex");
        } else {
          buffer = opts.signer.preAuthTx;
        }
        if (!(Buffer.isBuffer(buffer) && buffer.length === 32)) {
          throw new Error("signer.preAuthTx must be 32 bytes Buffer.");
        }
        key = new _xdr["default"].SignerKey.signerKeyTypePreAuthTx(buffer);
      } else if (opts.signer.sha256Hash) {
        var _buffer;
        if (typeof opts.signer.sha256Hash === "string") {
          _buffer = Buffer.from(opts.signer.sha256Hash, "hex");
        } else {
          _buffer = opts.signer.sha256Hash;
        }
        if (!(Buffer.isBuffer(_buffer) && _buffer.length === 32)) {
          throw new Error("signer.sha256Hash must be 32 bytes Buffer.");
        }
        key = new _xdr["default"].SignerKey.signerKeyTypeHashX(_buffer);
      } else {
        throw new Error("signer is invalid");
      }
      var signer = new _xdr["default"].RevokeSponsorshipOpSigner({
        accountId: _keypair.Keypair.fromPublicKey(opts.account).xdrAccountId(),
        signerKey: key
      });
      var op = _xdr["default"].RevokeSponsorshipOp.revokeSponsorshipSigner(signer);
      var opAttributes = {};
      opAttributes.body = _xdr["default"].OperationBody.revokeSponsorship(op);
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/clawback.js
var require_clawback = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/clawback.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.clawback = clawback;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function clawback(opts) {
      var attributes = {};
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      attributes.asset = opts.asset.toXDRObject();
      try {
        attributes.from = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.from);
      } catch (e) {
        throw new Error("from address is invalid");
      }
      var opAttributes = {
        body: _xdr["default"].OperationBody.clawback(new _xdr["default"].ClawbackOp(attributes))
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/set_trustline_flags.js
var require_set_trustline_flags = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/set_trustline_flags.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.setTrustLineFlags = setTrustLineFlags;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function setTrustLineFlags() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var attributes = {};
      if (_typeof(opts.flags) !== "object" || Object.keys(opts.flags).length === 0) {
        throw new Error("opts.flags must be a map of boolean flags to modify");
      }
      var mapping = {
        authorized: _xdr["default"].TrustLineFlags.authorizedFlag(),
        authorizedToMaintainLiabilities: _xdr["default"].TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
        clawbackEnabled: _xdr["default"].TrustLineFlags.trustlineClawbackEnabledFlag()
      };
      var clearFlag = 0;
      var setFlag = 0;
      Object.keys(opts.flags).forEach(function(flagName) {
        if (!Object.prototype.hasOwnProperty.call(mapping, flagName)) {
          throw new Error("unsupported flag name specified: ".concat(flagName));
        }
        var flagValue = opts.flags[flagName];
        var bit = mapping[flagName].value;
        if (flagValue === true) {
          setFlag |= bit;
        } else if (flagValue === false) {
          clearFlag |= bit;
        }
      });
      attributes.trustor = _keypair.Keypair.fromPublicKey(opts.trustor).xdrAccountId();
      attributes.asset = opts.asset.toXDRObject();
      attributes.clearFlags = clearFlag;
      attributes.setFlags = setFlag;
      var opAttributes = {
        body: _xdr["default"].OperationBody.setTrustLineFlags(new _xdr["default"].SetTrustLineFlagsOp(attributes))
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_deposit.js
var require_liquidity_pool_deposit = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_deposit.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.liquidityPoolDeposit = liquidityPoolDeposit;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function liquidityPoolDeposit() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var liquidityPoolId = opts.liquidityPoolId, maxAmountA = opts.maxAmountA, maxAmountB = opts.maxAmountB, minPrice = opts.minPrice, maxPrice = opts.maxPrice;
      var attributes = {};
      if (!liquidityPoolId) {
        throw new TypeError("liquidityPoolId argument is required");
      }
      attributes.liquidityPoolId = _xdr["default"].PoolId.fromXDR(liquidityPoolId, "hex");
      if (!this.isValidAmount(maxAmountA, true)) {
        throw new TypeError(this.constructAmountRequirementsError("maxAmountA"));
      }
      attributes.maxAmountA = this._toXDRAmount(maxAmountA);
      if (!this.isValidAmount(maxAmountB, true)) {
        throw new TypeError(this.constructAmountRequirementsError("maxAmountB"));
      }
      attributes.maxAmountB = this._toXDRAmount(maxAmountB);
      if (minPrice === void 0) {
        throw new TypeError("minPrice argument is required");
      }
      attributes.minPrice = this._toXDRPrice(minPrice);
      if (maxPrice === void 0) {
        throw new TypeError("maxPrice argument is required");
      }
      attributes.maxPrice = this._toXDRPrice(maxPrice);
      var liquidityPoolDepositOp = new _xdr["default"].LiquidityPoolDepositOp(attributes);
      var opAttributes = {
        body: _xdr["default"].OperationBody.liquidityPoolDeposit(liquidityPoolDepositOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_withdraw.js
var require_liquidity_pool_withdraw = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/liquidity_pool_withdraw.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.liquidityPoolWithdraw = liquidityPoolWithdraw;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function liquidityPoolWithdraw() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var attributes = {};
      if (!opts.liquidityPoolId) {
        throw new TypeError("liquidityPoolId argument is required");
      }
      attributes.liquidityPoolId = _xdr["default"].PoolId.fromXDR(opts.liquidityPoolId, "hex");
      if (!this.isValidAmount(opts.amount)) {
        throw new TypeError(this.constructAmountRequirementsError("amount"));
      }
      attributes.amount = this._toXDRAmount(opts.amount);
      if (!this.isValidAmount(opts.minAmountA, true)) {
        throw new TypeError(this.constructAmountRequirementsError("minAmountA"));
      }
      attributes.minAmountA = this._toXDRAmount(opts.minAmountA);
      if (!this.isValidAmount(opts.minAmountB, true)) {
        throw new TypeError(this.constructAmountRequirementsError("minAmountB"));
      }
      attributes.minAmountB = this._toXDRAmount(opts.minAmountB);
      var liquidityPoolWithdrawOp = new _xdr["default"].LiquidityPoolWithdrawOp(attributes);
      var opAttributes = {
        body: _xdr["default"].OperationBody.liquidityPoolWithdraw(liquidityPoolWithdrawOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/address.js
var require_address = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/address.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Address = void 0;
    var _strkey = require_strkey();
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Address = exports.Address = function() {
      function Address2(address) {
        _classCallCheck(this, Address2);
        if (_strkey.StrKey.isValidEd25519PublicKey(address)) {
          this._type = "account";
          this._key = _strkey.StrKey.decodeEd25519PublicKey(address);
        } else if (_strkey.StrKey.isValidContract(address)) {
          this._type = "contract";
          this._key = _strkey.StrKey.decodeContract(address);
        } else {
          throw new Error("Unsupported address type: ".concat(address));
        }
      }
      return _createClass(Address2, [{
        key: "toString",
        value: (
          /**
           * Serialize an address to string.
           *
           * @returns {string}
           */
          function toString() {
            switch (this._type) {
              case "account":
                return _strkey.StrKey.encodeEd25519PublicKey(this._key);
              case "contract":
                return _strkey.StrKey.encodeContract(this._key);
              default:
                throw new Error("Unsupported address type");
            }
          }
        )
        /**
         * Convert this Address to an xdr.ScVal type.
         *
         * @returns {xdr.ScVal}
         */
      }, {
        key: "toScVal",
        value: function toScVal() {
          return _xdr["default"].ScVal.scvAddress(this.toScAddress());
        }
        /**
         * Convert this Address to an xdr.ScAddress type.
         *
         * @returns {xdr.ScAddress}
         */
      }, {
        key: "toScAddress",
        value: function toScAddress() {
          switch (this._type) {
            case "account":
              return _xdr["default"].ScAddress.scAddressTypeAccount(_xdr["default"].PublicKey.publicKeyTypeEd25519(this._key));
            case "contract":
              return _xdr["default"].ScAddress.scAddressTypeContract(this._key);
            default:
              throw new Error("Unsupported address type");
          }
        }
        /**
         * Return the raw public key bytes for this address.
         *
         * @returns {Buffer}
         */
      }, {
        key: "toBuffer",
        value: function toBuffer() {
          return this._key;
        }
      }], [{
        key: "fromString",
        value: function fromString(address) {
          return new Address2(address);
        }
        /**
         * Creates a new account Address object from a buffer of raw bytes.
         *
         * @param {Buffer} buffer - The bytes of an address to parse.
         * @returns {Address}
         */
      }, {
        key: "account",
        value: function account(buffer) {
          return new Address2(_strkey.StrKey.encodeEd25519PublicKey(buffer));
        }
        /**
         * Creates a new contract Address object from a buffer of raw bytes.
         *
         * @param {Buffer} buffer - The bytes of an address to parse.
         * @returns {Address}
         */
      }, {
        key: "contract",
        value: function contract(buffer) {
          return new Address2(_strkey.StrKey.encodeContract(buffer));
        }
        /**
         * Convert this from an xdr.ScVal type
         *
         * @param {xdr.ScVal} scVal - The xdr.ScVal type to parse
         * @returns {Address}
         */
      }, {
        key: "fromScVal",
        value: function fromScVal(scVal) {
          return Address2.fromScAddress(scVal.address());
        }
        /**
         * Convert this from an xdr.ScAddress type
         *
         * @param {xdr.ScAddress} scAddress - The xdr.ScAddress type to parse
         * @returns {Address}
         */
      }, {
        key: "fromScAddress",
        value: function fromScAddress(scAddress) {
          switch (scAddress["switch"]().value) {
            case _xdr["default"].ScAddressType.scAddressTypeAccount().value:
              return Address2.account(scAddress.accountId().ed25519());
            case _xdr["default"].ScAddressType.scAddressTypeContract().value:
              return Address2.contract(scAddress.contractId());
            default:
              throw new Error("Unsupported address type");
          }
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/invoke_host_function.js
var require_invoke_host_function = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/invoke_host_function.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.createCustomContract = createCustomContract;
    exports.createStellarAssetContract = createStellarAssetContract;
    exports.invokeContractFunction = invokeContractFunction;
    exports.invokeHostFunction = invokeHostFunction;
    exports.uploadContractWasm = uploadContractWasm;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _address = require_address();
    var _asset = require_asset();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function invokeHostFunction(opts) {
      if (!opts.func) {
        throw new TypeError("host function invocation ('func') required (got ".concat(JSON.stringify(opts), ")"));
      }
      var invokeHostFunctionOp = new _xdr["default"].InvokeHostFunctionOp({
        hostFunction: opts.func,
        auth: opts.auth || []
      });
      var opAttributes = {
        body: _xdr["default"].OperationBody.invokeHostFunction(invokeHostFunctionOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
    function invokeContractFunction(opts) {
      var c = new _address.Address(opts.contract);
      if (c._type !== "contract") {
        throw new TypeError("expected contract strkey instance, got ".concat(c));
      }
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeInvokeContract(new _xdr["default"].InvokeContractArgs({
          contractAddress: c.toScAddress(),
          functionName: opts["function"],
          args: opts.args
        }))
      });
    }
    function createCustomContract(opts) {
      var _opts$constructorArgs;
      var salt = Buffer.from(opts.salt || getSalty());
      if (!opts.wasmHash || opts.wasmHash.length !== 32) {
        throw new TypeError("expected hash(contract WASM) in 'opts.wasmHash', got ".concat(opts.wasmHash));
      }
      if (salt.length !== 32) {
        throw new TypeError("expected 32-byte salt in 'opts.salt', got ".concat(opts.wasmHash));
      }
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeCreateContractV2(new _xdr["default"].CreateContractArgsV2({
          executable: _xdr["default"].ContractExecutable.contractExecutableWasm(Buffer.from(opts.wasmHash)),
          contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAddress(new _xdr["default"].ContractIdPreimageFromAddress({
            address: opts.address.toScAddress(),
            salt
          })),
          constructorArgs: (_opts$constructorArgs = opts.constructorArgs) !== null && _opts$constructorArgs !== void 0 ? _opts$constructorArgs : []
        }))
      });
    }
    function createStellarAssetContract(opts) {
      var asset = opts.asset;
      if (typeof asset === "string") {
        var _asset$split = asset.split(":"), _asset$split2 = _slicedToArray(_asset$split, 2), code = _asset$split2[0], issuer = _asset$split2[1];
        asset = new _asset.Asset(code, issuer);
      }
      if (!(asset instanceof _asset.Asset)) {
        throw new TypeError("expected Asset in 'opts.asset', got ".concat(asset));
      }
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeCreateContract(new _xdr["default"].CreateContractArgs({
          executable: _xdr["default"].ContractExecutable.contractExecutableStellarAsset(),
          contractIdPreimage: _xdr["default"].ContractIdPreimage.contractIdPreimageFromAsset(asset.toXDRObject())
        }))
      });
    }
    function uploadContractWasm(opts) {
      return this.invokeHostFunction({
        source: opts.source,
        auth: opts.auth,
        func: _xdr["default"].HostFunction.hostFunctionTypeUploadContractWasm(
          Buffer.from(opts.wasm)
          // coalesce so we can drop `Buffer` someday
        )
      });
    }
    function getSalty() {
      return _keypair.Keypair.random().xdrPublicKey().value();
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/extend_footprint_ttl.js
var require_extend_footprint_ttl = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/extend_footprint_ttl.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.extendFootprintTtl = extendFootprintTtl;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function extendFootprintTtl(opts) {
      var _opts$extendTo;
      if (((_opts$extendTo = opts.extendTo) !== null && _opts$extendTo !== void 0 ? _opts$extendTo : -1) <= 0) {
        throw new RangeError("extendTo has to be positive");
      }
      var extendFootprintOp = new _xdr["default"].ExtendFootprintTtlOp({
        ext: new _xdr["default"].ExtensionPoint(0),
        extendTo: opts.extendTo
      });
      var opAttributes = {
        body: _xdr["default"].OperationBody.extendFootprintTtl(extendFootprintOp)
      };
      this.setSourceAccount(opAttributes, opts);
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/restore_footprint.js
var require_restore_footprint = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/restore_footprint.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.restoreFootprint = restoreFootprint;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function restoreFootprint() {
      var opts = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var op = new _xdr["default"].RestoreFootprintOp({
        ext: new _xdr["default"].ExtensionPoint(0)
      });
      var opAttributes = {
        body: _xdr["default"].OperationBody.restoreFootprint(op)
      };
      this.setSourceAccount(opAttributes, opts !== null && opts !== void 0 ? opts : {});
      return new _xdr["default"].Operation(opAttributes);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/index.js
var require_operations = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operations/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "accountMerge", {
      enumerable: true,
      get: function get() {
        return _account_merge.accountMerge;
      }
    });
    Object.defineProperty(exports, "allowTrust", {
      enumerable: true,
      get: function get() {
        return _allow_trust.allowTrust;
      }
    });
    Object.defineProperty(exports, "beginSponsoringFutureReserves", {
      enumerable: true,
      get: function get() {
        return _begin_sponsoring_future_reserves.beginSponsoringFutureReserves;
      }
    });
    Object.defineProperty(exports, "bumpSequence", {
      enumerable: true,
      get: function get() {
        return _bump_sequence.bumpSequence;
      }
    });
    Object.defineProperty(exports, "changeTrust", {
      enumerable: true,
      get: function get() {
        return _change_trust.changeTrust;
      }
    });
    Object.defineProperty(exports, "claimClaimableBalance", {
      enumerable: true,
      get: function get() {
        return _claim_claimable_balance.claimClaimableBalance;
      }
    });
    Object.defineProperty(exports, "clawback", {
      enumerable: true,
      get: function get() {
        return _clawback.clawback;
      }
    });
    Object.defineProperty(exports, "clawbackClaimableBalance", {
      enumerable: true,
      get: function get() {
        return _clawback_claimable_balance.clawbackClaimableBalance;
      }
    });
    Object.defineProperty(exports, "createAccount", {
      enumerable: true,
      get: function get() {
        return _create_account.createAccount;
      }
    });
    Object.defineProperty(exports, "createClaimableBalance", {
      enumerable: true,
      get: function get() {
        return _create_claimable_balance.createClaimableBalance;
      }
    });
    Object.defineProperty(exports, "createCustomContract", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.createCustomContract;
      }
    });
    Object.defineProperty(exports, "createPassiveSellOffer", {
      enumerable: true,
      get: function get() {
        return _create_passive_sell_offer.createPassiveSellOffer;
      }
    });
    Object.defineProperty(exports, "createStellarAssetContract", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.createStellarAssetContract;
      }
    });
    Object.defineProperty(exports, "endSponsoringFutureReserves", {
      enumerable: true,
      get: function get() {
        return _end_sponsoring_future_reserves.endSponsoringFutureReserves;
      }
    });
    Object.defineProperty(exports, "extendFootprintTtl", {
      enumerable: true,
      get: function get() {
        return _extend_footprint_ttl.extendFootprintTtl;
      }
    });
    Object.defineProperty(exports, "inflation", {
      enumerable: true,
      get: function get() {
        return _inflation.inflation;
      }
    });
    Object.defineProperty(exports, "invokeContractFunction", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.invokeContractFunction;
      }
    });
    Object.defineProperty(exports, "invokeHostFunction", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.invokeHostFunction;
      }
    });
    Object.defineProperty(exports, "liquidityPoolDeposit", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_deposit.liquidityPoolDeposit;
      }
    });
    Object.defineProperty(exports, "liquidityPoolWithdraw", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_withdraw.liquidityPoolWithdraw;
      }
    });
    Object.defineProperty(exports, "manageBuyOffer", {
      enumerable: true,
      get: function get() {
        return _manage_buy_offer.manageBuyOffer;
      }
    });
    Object.defineProperty(exports, "manageData", {
      enumerable: true,
      get: function get() {
        return _manage_data.manageData;
      }
    });
    Object.defineProperty(exports, "manageSellOffer", {
      enumerable: true,
      get: function get() {
        return _manage_sell_offer.manageSellOffer;
      }
    });
    Object.defineProperty(exports, "pathPaymentStrictReceive", {
      enumerable: true,
      get: function get() {
        return _path_payment_strict_receive.pathPaymentStrictReceive;
      }
    });
    Object.defineProperty(exports, "pathPaymentStrictSend", {
      enumerable: true,
      get: function get() {
        return _path_payment_strict_send.pathPaymentStrictSend;
      }
    });
    Object.defineProperty(exports, "payment", {
      enumerable: true,
      get: function get() {
        return _payment.payment;
      }
    });
    Object.defineProperty(exports, "restoreFootprint", {
      enumerable: true,
      get: function get() {
        return _restore_footprint.restoreFootprint;
      }
    });
    Object.defineProperty(exports, "revokeAccountSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeAccountSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeClaimableBalanceSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeClaimableBalanceSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeDataSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeDataSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeLiquidityPoolSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeLiquidityPoolSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeOfferSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeOfferSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeSignerSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeSignerSponsorship;
      }
    });
    Object.defineProperty(exports, "revokeTrustlineSponsorship", {
      enumerable: true,
      get: function get() {
        return _revoke_sponsorship.revokeTrustlineSponsorship;
      }
    });
    Object.defineProperty(exports, "setOptions", {
      enumerable: true,
      get: function get() {
        return _set_options.setOptions;
      }
    });
    Object.defineProperty(exports, "setTrustLineFlags", {
      enumerable: true,
      get: function get() {
        return _set_trustline_flags.setTrustLineFlags;
      }
    });
    Object.defineProperty(exports, "uploadContractWasm", {
      enumerable: true,
      get: function get() {
        return _invoke_host_function.uploadContractWasm;
      }
    });
    var _manage_sell_offer = require_manage_sell_offer();
    var _create_passive_sell_offer = require_create_passive_sell_offer();
    var _account_merge = require_account_merge();
    var _allow_trust = require_allow_trust();
    var _bump_sequence = require_bump_sequence();
    var _change_trust = require_change_trust();
    var _create_account = require_create_account();
    var _create_claimable_balance = require_create_claimable_balance();
    var _claim_claimable_balance = require_claim_claimable_balance();
    var _clawback_claimable_balance = require_clawback_claimable_balance();
    var _inflation = require_inflation();
    var _manage_data = require_manage_data();
    var _manage_buy_offer = require_manage_buy_offer();
    var _path_payment_strict_receive = require_path_payment_strict_receive();
    var _path_payment_strict_send = require_path_payment_strict_send();
    var _payment = require_payment();
    var _set_options = require_set_options();
    var _begin_sponsoring_future_reserves = require_begin_sponsoring_future_reserves();
    var _end_sponsoring_future_reserves = require_end_sponsoring_future_reserves();
    var _revoke_sponsorship = require_revoke_sponsorship();
    var _clawback = require_clawback();
    var _set_trustline_flags = require_set_trustline_flags();
    var _liquidity_pool_deposit = require_liquidity_pool_deposit();
    var _liquidity_pool_withdraw = require_liquidity_pool_withdraw();
    var _invoke_host_function = require_invoke_host_function();
    var _extend_footprint_ttl = require_extend_footprint_ttl();
    var _restore_footprint = require_restore_footprint();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operation.js
var require_operation = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/operation.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Operation = exports.AuthRevocableFlag = exports.AuthRequiredFlag = exports.AuthImmutableFlag = exports.AuthClawbackEnabledFlag = void 0;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber2());
    var _util = require_util();
    var _continued_fraction = require_continued_fraction();
    var _asset = require_asset();
    var _liquidity_pool_asset = require_liquidity_pool_asset();
    var _claimant = require_claimant();
    var _strkey = require_strkey();
    var _liquidity_pool_id = require_liquidity_pool_id();
    var _xdr = _interopRequireDefault(require_xdr2());
    var ops = _interopRequireWildcard(require_operations());
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n["default"] = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var ONE = 1e7;
    var MAX_INT64 = "9223372036854775807";
    var AuthRequiredFlag = exports.AuthRequiredFlag = 1 << 0;
    var AuthRevocableFlag = exports.AuthRevocableFlag = 1 << 1;
    var AuthImmutableFlag = exports.AuthImmutableFlag = 1 << 2;
    var AuthClawbackEnabledFlag = exports.AuthClawbackEnabledFlag = 1 << 3;
    var Operation = exports.Operation = function() {
      function Operation2() {
        _classCallCheck(this, Operation2);
      }
      return _createClass(Operation2, null, [{
        key: "setSourceAccount",
        value: function setSourceAccount(opAttributes, opts) {
          if (opts.source) {
            try {
              opAttributes.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(opts.source);
            } catch (e) {
              throw new Error("Source address is invalid");
            }
          }
        }
        /**
         * Deconstructs the raw XDR operation object into the structured object that
         * was used to create the operation (i.e. the `opts` parameter to most ops).
         *
         * @param {xdr.Operation}   operation - An XDR Operation.
         * @return {Operation}
         */
      }, {
        key: "fromXDRObject",
        value: function fromXDRObject(operation) {
          var result = {};
          if (operation.sourceAccount()) {
            result.source = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(operation.sourceAccount());
          }
          var attrs = operation.body().value();
          var operationName = operation.body()["switch"]().name;
          switch (operationName) {
            case "createAccount": {
              result.type = "createAccount";
              result.destination = accountIdtoAddress(attrs.destination());
              result.startingBalance = this._fromXDRAmount(attrs.startingBalance());
              break;
            }
            case "payment": {
              result.type = "payment";
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              result.amount = this._fromXDRAmount(attrs.amount());
              break;
            }
            case "pathPaymentStrictReceive": {
              result.type = "pathPaymentStrictReceive";
              result.sendAsset = _asset.Asset.fromOperation(attrs.sendAsset());
              result.sendMax = this._fromXDRAmount(attrs.sendMax());
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
              result.destAsset = _asset.Asset.fromOperation(attrs.destAsset());
              result.destAmount = this._fromXDRAmount(attrs.destAmount());
              result.path = [];
              var path = attrs.path();
              Object.keys(path).forEach(function(pathKey) {
                result.path.push(_asset.Asset.fromOperation(path[pathKey]));
              });
              break;
            }
            case "pathPaymentStrictSend": {
              result.type = "pathPaymentStrictSend";
              result.sendAsset = _asset.Asset.fromOperation(attrs.sendAsset());
              result.sendAmount = this._fromXDRAmount(attrs.sendAmount());
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.destination());
              result.destAsset = _asset.Asset.fromOperation(attrs.destAsset());
              result.destMin = this._fromXDRAmount(attrs.destMin());
              result.path = [];
              var _path = attrs.path();
              Object.keys(_path).forEach(function(pathKey) {
                result.path.push(_asset.Asset.fromOperation(_path[pathKey]));
              });
              break;
            }
            case "changeTrust": {
              result.type = "changeTrust";
              switch (attrs.line()["switch"]()) {
                case _xdr["default"].AssetType.assetTypePoolShare():
                  result.line = _liquidity_pool_asset.LiquidityPoolAsset.fromOperation(attrs.line());
                  break;
                default:
                  result.line = _asset.Asset.fromOperation(attrs.line());
                  break;
              }
              result.limit = this._fromXDRAmount(attrs.limit());
              break;
            }
            case "allowTrust": {
              result.type = "allowTrust";
              result.trustor = accountIdtoAddress(attrs.trustor());
              result.assetCode = attrs.asset().value().toString();
              result.assetCode = (0, _util.trimEnd)(result.assetCode, "\0");
              result.authorize = attrs.authorize();
              break;
            }
            case "setOptions": {
              result.type = "setOptions";
              if (attrs.inflationDest()) {
                result.inflationDest = accountIdtoAddress(attrs.inflationDest());
              }
              result.clearFlags = attrs.clearFlags();
              result.setFlags = attrs.setFlags();
              result.masterWeight = attrs.masterWeight();
              result.lowThreshold = attrs.lowThreshold();
              result.medThreshold = attrs.medThreshold();
              result.highThreshold = attrs.highThreshold();
              result.homeDomain = attrs.homeDomain() !== void 0 ? attrs.homeDomain().toString("ascii") : void 0;
              if (attrs.signer()) {
                var signer = {};
                var arm = attrs.signer().key().arm();
                if (arm === "ed25519") {
                  signer.ed25519PublicKey = accountIdtoAddress(attrs.signer().key());
                } else if (arm === "preAuthTx") {
                  signer.preAuthTx = attrs.signer().key().preAuthTx();
                } else if (arm === "hashX") {
                  signer.sha256Hash = attrs.signer().key().hashX();
                } else if (arm === "ed25519SignedPayload") {
                  var signedPayload = attrs.signer().key().ed25519SignedPayload();
                  signer.ed25519SignedPayload = _strkey.StrKey.encodeSignedPayload(signedPayload.toXDR());
                }
                signer.weight = attrs.signer().weight();
                result.signer = signer;
              }
              break;
            }
            // the next case intentionally falls through!
            case "manageOffer":
            case "manageSellOffer": {
              result.type = "manageSellOffer";
              result.selling = _asset.Asset.fromOperation(attrs.selling());
              result.buying = _asset.Asset.fromOperation(attrs.buying());
              result.amount = this._fromXDRAmount(attrs.amount());
              result.price = this._fromXDRPrice(attrs.price());
              result.offerId = attrs.offerId().toString();
              break;
            }
            case "manageBuyOffer": {
              result.type = "manageBuyOffer";
              result.selling = _asset.Asset.fromOperation(attrs.selling());
              result.buying = _asset.Asset.fromOperation(attrs.buying());
              result.buyAmount = this._fromXDRAmount(attrs.buyAmount());
              result.price = this._fromXDRPrice(attrs.price());
              result.offerId = attrs.offerId().toString();
              break;
            }
            // the next case intentionally falls through!
            case "createPassiveOffer":
            case "createPassiveSellOffer": {
              result.type = "createPassiveSellOffer";
              result.selling = _asset.Asset.fromOperation(attrs.selling());
              result.buying = _asset.Asset.fromOperation(attrs.buying());
              result.amount = this._fromXDRAmount(attrs.amount());
              result.price = this._fromXDRPrice(attrs.price());
              break;
            }
            case "accountMerge": {
              result.type = "accountMerge";
              result.destination = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs);
              break;
            }
            case "manageData": {
              result.type = "manageData";
              result.name = attrs.dataName().toString("ascii");
              result.value = attrs.dataValue();
              break;
            }
            case "inflation": {
              result.type = "inflation";
              break;
            }
            case "bumpSequence": {
              result.type = "bumpSequence";
              result.bumpTo = attrs.bumpTo().toString();
              break;
            }
            case "createClaimableBalance": {
              result.type = "createClaimableBalance";
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              result.amount = this._fromXDRAmount(attrs.amount());
              result.claimants = [];
              attrs.claimants().forEach(function(claimant) {
                result.claimants.push(_claimant.Claimant.fromXDR(claimant));
              });
              break;
            }
            case "claimClaimableBalance": {
              result.type = "claimClaimableBalance";
              result.balanceId = attrs.toXDR("hex");
              break;
            }
            case "beginSponsoringFutureReserves": {
              result.type = "beginSponsoringFutureReserves";
              result.sponsoredId = accountIdtoAddress(attrs.sponsoredId());
              break;
            }
            case "endSponsoringFutureReserves": {
              result.type = "endSponsoringFutureReserves";
              break;
            }
            case "revokeSponsorship": {
              extractRevokeSponshipDetails(attrs, result);
              break;
            }
            case "clawback": {
              result.type = "clawback";
              result.amount = this._fromXDRAmount(attrs.amount());
              result.from = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(attrs.from());
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              break;
            }
            case "clawbackClaimableBalance": {
              result.type = "clawbackClaimableBalance";
              result.balanceId = attrs.toXDR("hex");
              break;
            }
            case "setTrustLineFlags": {
              result.type = "setTrustLineFlags";
              result.asset = _asset.Asset.fromOperation(attrs.asset());
              result.trustor = accountIdtoAddress(attrs.trustor());
              var clears = attrs.clearFlags();
              var sets = attrs.setFlags();
              var mapping = {
                authorized: _xdr["default"].TrustLineFlags.authorizedFlag(),
                authorizedToMaintainLiabilities: _xdr["default"].TrustLineFlags.authorizedToMaintainLiabilitiesFlag(),
                clawbackEnabled: _xdr["default"].TrustLineFlags.trustlineClawbackEnabledFlag()
              };
              var getFlagValue = function getFlagValue2(key) {
                var bit = mapping[key].value;
                if (sets & bit) {
                  return true;
                }
                if (clears & bit) {
                  return false;
                }
                return void 0;
              };
              result.flags = {};
              Object.keys(mapping).forEach(function(flagName) {
                result.flags[flagName] = getFlagValue(flagName);
              });
              break;
            }
            case "liquidityPoolDeposit": {
              result.type = "liquidityPoolDeposit";
              result.liquidityPoolId = attrs.liquidityPoolId().toString("hex");
              result.maxAmountA = this._fromXDRAmount(attrs.maxAmountA());
              result.maxAmountB = this._fromXDRAmount(attrs.maxAmountB());
              result.minPrice = this._fromXDRPrice(attrs.minPrice());
              result.maxPrice = this._fromXDRPrice(attrs.maxPrice());
              break;
            }
            case "liquidityPoolWithdraw": {
              result.type = "liquidityPoolWithdraw";
              result.liquidityPoolId = attrs.liquidityPoolId().toString("hex");
              result.amount = this._fromXDRAmount(attrs.amount());
              result.minAmountA = this._fromXDRAmount(attrs.minAmountA());
              result.minAmountB = this._fromXDRAmount(attrs.minAmountB());
              break;
            }
            case "invokeHostFunction": {
              var _attrs$auth;
              result.type = "invokeHostFunction";
              result.func = attrs.hostFunction();
              result.auth = (_attrs$auth = attrs.auth()) !== null && _attrs$auth !== void 0 ? _attrs$auth : [];
              break;
            }
            case "extendFootprintTtl": {
              result.type = "extendFootprintTtl";
              result.extendTo = attrs.extendTo();
              break;
            }
            case "restoreFootprint": {
              result.type = "restoreFootprint";
              break;
            }
            default: {
              throw new Error("Unknown operation: ".concat(operationName));
            }
          }
          return result;
        }
        /**
         * Validates that a given amount is possible for a Stellar asset.
         *
         * Specifically, this means that the amount is well, a valid number, but also
         * that it is within the int64 range and has no more than 7 decimal levels of
         * precision.
         *
         * Note that while smart contracts allow larger amounts, this is oriented
         * towards validating the standard Stellar operations.
         *
         * @param {string}  value       the amount to validate
         * @param {boolean} allowZero   optionally, whether or not zero is valid (default: no)
         *
         * @returns {boolean}
         */
      }, {
        key: "isValidAmount",
        value: function isValidAmount(value) {
          var allowZero = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (typeof value !== "string") {
            return false;
          }
          var amount;
          try {
            amount = new _bignumber["default"](value);
          } catch (e) {
            return false;
          }
          if (
            // == 0
            !allowZero && amount.isZero() || // < 0
            amount.isNegative() || // > Max value
            amount.times(ONE).gt(new _bignumber["default"](MAX_INT64).toString()) || // Decimal places (max 7)
            amount.decimalPlaces() > 7 || // NaN or Infinity
            amount.isNaN() || !amount.isFinite()
          ) {
            return false;
          }
          return true;
        }
      }, {
        key: "constructAmountRequirementsError",
        value: function constructAmountRequirementsError(arg) {
          return "".concat(arg, " argument must be of type String, represent a positive number and have at most 7 digits after the decimal");
        }
        /**
         * Returns value converted to uint32 value or undefined.
         * If `value` is not `Number`, `String` or `Undefined` then throws an error.
         * Used in {@link Operation.setOptions}.
         * @private
         * @param {string} name Name of the property (used in error message only)
         * @param {*} value Value to check
         * @param {function(value, name)} isValidFunction Function to check other constraints (the argument will be a `Number`)
         * @returns {undefined|Number}
         */
      }, {
        key: "_checkUnsignedIntValue",
        value: function _checkUnsignedIntValue(name, value) {
          var isValidFunction = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          if (typeof value === "undefined") {
            return void 0;
          }
          if (typeof value === "string") {
            value = parseFloat(value);
          }
          switch (true) {
            case (typeof value !== "number" || !Number.isFinite(value) || value % 1 !== 0):
              throw new Error("".concat(name, " value is invalid"));
            case value < 0:
              throw new Error("".concat(name, " value must be unsigned"));
            case (!isValidFunction || isValidFunction && isValidFunction(value, name)):
              return value;
            default:
              throw new Error("".concat(name, " value is invalid"));
          }
        }
        /**
         * @private
         * @param {string|BigNumber} value Value
         * @returns {Hyper} XDR amount
         */
      }, {
        key: "_toXDRAmount",
        value: function _toXDRAmount(value) {
          var amount = new _bignumber["default"](value).times(ONE);
          return _jsXdr.Hyper.fromString(amount.toString());
        }
        /**
         * @private
         * @param {string|BigNumber} value XDR amount
         * @returns {BigNumber} Number
         */
      }, {
        key: "_fromXDRAmount",
        value: function _fromXDRAmount(value) {
          return new _bignumber["default"](value).div(ONE).toFixed(7);
        }
        /**
         * @private
         * @param {object} price Price object
         * @param {function} price.n numerator function that returns a value
         * @param {function} price.d denominator function that returns a value
         * @returns {BigNumber} Big string
         */
      }, {
        key: "_fromXDRPrice",
        value: function _fromXDRPrice(price) {
          var n = new _bignumber["default"](price.n());
          return n.div(new _bignumber["default"](price.d())).toString();
        }
        /**
         * @private
         * @param {object} price Price object
         * @param {function} price.n numerator function that returns a value
         * @param {function} price.d denominator function that returns a value
         * @returns {object} XDR price object
         */
      }, {
        key: "_toXDRPrice",
        value: function _toXDRPrice(price) {
          var xdrObject;
          if (price.n && price.d) {
            xdrObject = new _xdr["default"].Price(price);
          } else {
            var approx = (0, _continued_fraction.best_r)(price);
            xdrObject = new _xdr["default"].Price({
              n: parseInt(approx[0], 10),
              d: parseInt(approx[1], 10)
            });
          }
          if (xdrObject.n() < 0 || xdrObject.d() < 0) {
            throw new Error("price must be positive");
          }
          return xdrObject;
        }
      }]);
    }();
    function extractRevokeSponshipDetails(attrs, result) {
      switch (attrs["switch"]().name) {
        case "revokeSponsorshipLedgerEntry": {
          var ledgerKey = attrs.ledgerKey();
          switch (ledgerKey["switch"]().name) {
            case _xdr["default"].LedgerEntryType.account().name: {
              result.type = "revokeAccountSponsorship";
              result.account = accountIdtoAddress(ledgerKey.account().accountId());
              break;
            }
            case _xdr["default"].LedgerEntryType.trustline().name: {
              result.type = "revokeTrustlineSponsorship";
              result.account = accountIdtoAddress(ledgerKey.trustLine().accountId());
              var xdrAsset = ledgerKey.trustLine().asset();
              switch (xdrAsset["switch"]()) {
                case _xdr["default"].AssetType.assetTypePoolShare():
                  result.asset = _liquidity_pool_id.LiquidityPoolId.fromOperation(xdrAsset);
                  break;
                default:
                  result.asset = _asset.Asset.fromOperation(xdrAsset);
                  break;
              }
              break;
            }
            case _xdr["default"].LedgerEntryType.offer().name: {
              result.type = "revokeOfferSponsorship";
              result.seller = accountIdtoAddress(ledgerKey.offer().sellerId());
              result.offerId = ledgerKey.offer().offerId().toString();
              break;
            }
            case _xdr["default"].LedgerEntryType.data().name: {
              result.type = "revokeDataSponsorship";
              result.account = accountIdtoAddress(ledgerKey.data().accountId());
              result.name = ledgerKey.data().dataName().toString("ascii");
              break;
            }
            case _xdr["default"].LedgerEntryType.claimableBalance().name: {
              result.type = "revokeClaimableBalanceSponsorship";
              result.balanceId = ledgerKey.claimableBalance().balanceId().toXDR("hex");
              break;
            }
            case _xdr["default"].LedgerEntryType.liquidityPool().name: {
              result.type = "revokeLiquidityPoolSponsorship";
              result.liquidityPoolId = ledgerKey.liquidityPool().liquidityPoolId().toString("hex");
              break;
            }
            default: {
              throw new Error("Unknown ledgerKey: ".concat(attrs["switch"]().name));
            }
          }
          break;
        }
        case "revokeSponsorshipSigner": {
          result.type = "revokeSignerSponsorship";
          result.account = accountIdtoAddress(attrs.signer().accountId());
          result.signer = convertXDRSignerKeyToObject(attrs.signer().signerKey());
          break;
        }
        default: {
          throw new Error("Unknown revokeSponsorship: ".concat(attrs["switch"]().name));
        }
      }
    }
    function convertXDRSignerKeyToObject(signerKey) {
      var attrs = {};
      switch (signerKey["switch"]().name) {
        case _xdr["default"].SignerKeyType.signerKeyTypeEd25519().name: {
          attrs.ed25519PublicKey = _strkey.StrKey.encodeEd25519PublicKey(signerKey.ed25519());
          break;
        }
        case _xdr["default"].SignerKeyType.signerKeyTypePreAuthTx().name: {
          attrs.preAuthTx = signerKey.preAuthTx().toString("hex");
          break;
        }
        case _xdr["default"].SignerKeyType.signerKeyTypeHashX().name: {
          attrs.sha256Hash = signerKey.hashX().toString("hex");
          break;
        }
        default: {
          throw new Error("Unknown signerKey: ".concat(signerKey["switch"]().name));
        }
      }
      return attrs;
    }
    function accountIdtoAddress(accountId) {
      return _strkey.StrKey.encodeEd25519PublicKey(accountId.ed25519());
    }
    Operation.accountMerge = ops.accountMerge;
    Operation.allowTrust = ops.allowTrust;
    Operation.bumpSequence = ops.bumpSequence;
    Operation.changeTrust = ops.changeTrust;
    Operation.createAccount = ops.createAccount;
    Operation.createClaimableBalance = ops.createClaimableBalance;
    Operation.claimClaimableBalance = ops.claimClaimableBalance;
    Operation.clawbackClaimableBalance = ops.clawbackClaimableBalance;
    Operation.createPassiveSellOffer = ops.createPassiveSellOffer;
    Operation.inflation = ops.inflation;
    Operation.manageData = ops.manageData;
    Operation.manageSellOffer = ops.manageSellOffer;
    Operation.manageBuyOffer = ops.manageBuyOffer;
    Operation.pathPaymentStrictReceive = ops.pathPaymentStrictReceive;
    Operation.pathPaymentStrictSend = ops.pathPaymentStrictSend;
    Operation.payment = ops.payment;
    Operation.setOptions = ops.setOptions;
    Operation.beginSponsoringFutureReserves = ops.beginSponsoringFutureReserves;
    Operation.endSponsoringFutureReserves = ops.endSponsoringFutureReserves;
    Operation.revokeAccountSponsorship = ops.revokeAccountSponsorship;
    Operation.revokeTrustlineSponsorship = ops.revokeTrustlineSponsorship;
    Operation.revokeOfferSponsorship = ops.revokeOfferSponsorship;
    Operation.revokeDataSponsorship = ops.revokeDataSponsorship;
    Operation.revokeClaimableBalanceSponsorship = ops.revokeClaimableBalanceSponsorship;
    Operation.revokeLiquidityPoolSponsorship = ops.revokeLiquidityPoolSponsorship;
    Operation.revokeSignerSponsorship = ops.revokeSignerSponsorship;
    Operation.clawback = ops.clawback;
    Operation.setTrustLineFlags = ops.setTrustLineFlags;
    Operation.liquidityPoolDeposit = ops.liquidityPoolDeposit;
    Operation.liquidityPoolWithdraw = ops.liquidityPoolWithdraw;
    Operation.invokeHostFunction = ops.invokeHostFunction;
    Operation.extendFootprintTtl = ops.extendFootprintTtl;
    Operation.restoreFootprint = ops.restoreFootprint;
    Operation.createStellarAssetContract = ops.createStellarAssetContract;
    Operation.invokeContractFunction = ops.invokeContractFunction;
    Operation.createCustomContract = ops.createCustomContract;
    Operation.uploadContractWasm = ops.uploadContractWasm;
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/memo.js
var require_memo = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/memo.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MemoText = exports.MemoReturn = exports.MemoNone = exports.MemoID = exports.MemoHash = exports.Memo = void 0;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber2());
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var MemoNone = exports.MemoNone = "none";
    var MemoID = exports.MemoID = "id";
    var MemoText = exports.MemoText = "text";
    var MemoHash = exports.MemoHash = "hash";
    var MemoReturn = exports.MemoReturn = "return";
    var Memo = exports.Memo = function() {
      function Memo2(type) {
        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        _classCallCheck(this, Memo2);
        this._type = type;
        this._value = value;
        switch (this._type) {
          case MemoNone:
            break;
          case MemoID:
            Memo2._validateIdValue(value);
            break;
          case MemoText:
            Memo2._validateTextValue(value);
            break;
          case MemoHash:
          case MemoReturn:
            Memo2._validateHashValue(value);
            if (typeof value === "string") {
              this._value = Buffer.from(value, "hex");
            }
            break;
          default:
            throw new Error("Invalid memo type");
        }
      }
      return _createClass(Memo2, [{
        key: "type",
        get: function get() {
          return this._type;
        },
        set: function set(type) {
          throw new Error("Memo is immutable");
        }
        /**
         * Contains memo value:
         * * `null` for `MemoNone`,
         * * `string` for `MemoID`,
         * * `Buffer` for `MemoText` after decoding using `fromXDRObject`, original value otherwise,
         * * `Buffer` for `MemoHash`, `MemoReturn`.
         */
      }, {
        key: "value",
        get: function get() {
          switch (this._type) {
            case MemoNone:
              return null;
            case MemoID:
            case MemoText:
              return this._value;
            case MemoHash:
            case MemoReturn:
              return Buffer.from(this._value);
            default:
              throw new Error("Invalid memo type");
          }
        },
        set: function set(value) {
          throw new Error("Memo is immutable");
        }
      }, {
        key: "toXDRObject",
        value: (
          /**
           * Returns XDR memo object.
           * @returns {xdr.Memo}
           */
          function toXDRObject() {
            switch (this._type) {
              case MemoNone:
                return _xdr["default"].Memo.memoNone();
              case MemoID:
                return _xdr["default"].Memo.memoId(_jsXdr.UnsignedHyper.fromString(this._value));
              case MemoText:
                return _xdr["default"].Memo.memoText(this._value);
              case MemoHash:
                return _xdr["default"].Memo.memoHash(this._value);
              case MemoReturn:
                return _xdr["default"].Memo.memoReturn(this._value);
              default:
                return null;
            }
          }
        )
        /**
         * Returns {@link Memo} from XDR memo object.
         * @param {xdr.Memo} object XDR memo object
         * @returns {Memo}
         */
      }], [{
        key: "_validateIdValue",
        value: function _validateIdValue(value) {
          var error = new Error("Expects a int64 as a string. Got ".concat(value));
          if (typeof value !== "string") {
            throw error;
          }
          var number;
          try {
            number = new _bignumber["default"](value);
          } catch (e) {
            throw error;
          }
          if (!number.isFinite()) {
            throw error;
          }
          if (number.isNaN()) {
            throw error;
          }
        }
      }, {
        key: "_validateTextValue",
        value: function _validateTextValue(value) {
          if (!_xdr["default"].Memo.armTypeForArm("text").isValid(value)) {
            throw new Error("Expects string, array or buffer, max 28 bytes");
          }
        }
      }, {
        key: "_validateHashValue",
        value: function _validateHashValue(value) {
          var error = new Error("Expects a 32 byte hash value or hex encoded string. Got ".concat(value));
          if (value === null || typeof value === "undefined") {
            throw error;
          }
          var valueBuffer;
          if (typeof value === "string") {
            if (!/^[0-9A-Fa-f]{64}$/g.test(value)) {
              throw error;
            }
            valueBuffer = Buffer.from(value, "hex");
          } else if (Buffer.isBuffer(value)) {
            valueBuffer = Buffer.from(value);
          } else {
            throw error;
          }
          if (!valueBuffer.length || valueBuffer.length !== 32) {
            throw error;
          }
        }
        /**
         * Returns an empty memo (`MemoNone`).
         * @returns {Memo}
         */
      }, {
        key: "none",
        value: function none() {
          return new Memo2(MemoNone);
        }
        /**
         * Creates and returns a `MemoText` memo.
         * @param {string} text - memo text
         * @returns {Memo}
         */
      }, {
        key: "text",
        value: function text(_text) {
          return new Memo2(MemoText, _text);
        }
        /**
         * Creates and returns a `MemoID` memo.
         * @param {string} id - 64-bit number represented as a string
         * @returns {Memo}
         */
      }, {
        key: "id",
        value: function id(_id) {
          return new Memo2(MemoID, _id);
        }
        /**
         * Creates and returns a `MemoHash` memo.
         * @param {array|string} hash - 32 byte hash or hex encoded string
         * @returns {Memo}
         */
      }, {
        key: "hash",
        value: function hash(_hash) {
          return new Memo2(MemoHash, _hash);
        }
        /**
         * Creates and returns a `MemoReturn` memo.
         * @param {array|string} hash - 32 byte hash or hex encoded string
         * @returns {Memo}
         */
      }, {
        key: "return",
        value: function _return(hash) {
          return new Memo2(MemoReturn, hash);
        }
      }, {
        key: "fromXDRObject",
        value: function fromXDRObject(object) {
          switch (object.arm()) {
            case "id":
              return Memo2.id(object.value().toString());
            case "text":
              return Memo2.text(object.value());
            case "hash":
              return Memo2.hash(object.value());
            case "retHash":
              return Memo2["return"](object.value());
            default:
              break;
          }
          if (typeof object.value() === "undefined") {
            return Memo2.none();
          }
          throw new Error("Unknown type");
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/transaction.js
var require_transaction = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/transaction.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Transaction = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _hashing = require_hashing();
    var _strkey = require_strkey();
    var _operation = require_operation();
    var _memo = require_memo();
    var _transaction_base = require_transaction_base();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Transaction = exports.Transaction = function(_TransactionBase) {
      function Transaction2(envelope, networkPassphrase) {
        var _this;
        _classCallCheck(this, Transaction2);
        if (typeof envelope === "string") {
          var buffer = Buffer.from(envelope, "base64");
          envelope = _xdr["default"].TransactionEnvelope.fromXDR(buffer);
        }
        var envelopeType = envelope["switch"]();
        if (!(envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTxV0() || envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTx())) {
          throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(envelopeType.name, "."));
        }
        var txEnvelope = envelope.value();
        var tx = txEnvelope.tx();
        var fee = tx.fee().toString();
        var signatures = (txEnvelope.signatures() || []).slice();
        _this = _callSuper(this, Transaction2, [tx, signatures, fee, networkPassphrase]);
        _this._envelopeType = envelopeType;
        _this._memo = tx.memo();
        _this._sequence = tx.seqNum().toString();
        switch (_this._envelopeType) {
          case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
            _this._source = _strkey.StrKey.encodeEd25519PublicKey(_this.tx.sourceAccountEd25519());
            break;
          default:
            _this._source = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(_this.tx.sourceAccount());
            break;
        }
        var cond = null;
        var timeBounds = null;
        switch (_this._envelopeType) {
          case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
            timeBounds = tx.timeBounds();
            break;
          case _xdr["default"].EnvelopeType.envelopeTypeTx():
            switch (tx.cond()["switch"]()) {
              case _xdr["default"].PreconditionType.precondTime():
                timeBounds = tx.cond().timeBounds();
                break;
              case _xdr["default"].PreconditionType.precondV2():
                cond = tx.cond().v2();
                timeBounds = cond.timeBounds();
                break;
              default:
                break;
            }
            break;
          default:
            break;
        }
        if (timeBounds) {
          _this._timeBounds = {
            minTime: timeBounds.minTime().toString(),
            maxTime: timeBounds.maxTime().toString()
          };
        }
        if (cond) {
          var ledgerBounds = cond.ledgerBounds();
          if (ledgerBounds) {
            _this._ledgerBounds = {
              minLedger: ledgerBounds.minLedger(),
              maxLedger: ledgerBounds.maxLedger()
            };
          }
          var minSeq = cond.minSeqNum();
          if (minSeq) {
            _this._minAccountSequence = minSeq.toString();
          }
          _this._minAccountSequenceAge = cond.minSeqAge();
          _this._minAccountSequenceLedgerGap = cond.minSeqLedgerGap();
          _this._extraSigners = cond.extraSigners();
        }
        var operations = tx.operations() || [];
        _this._operations = operations.map(function(op) {
          return _operation.Operation.fromXDRObject(op);
        });
        return _this;
      }
      _inherits(Transaction2, _TransactionBase);
      return _createClass(Transaction2, [{
        key: "timeBounds",
        get: function get() {
          return this._timeBounds;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {object}
         * @property {number} minLedger - smallest ledger bound (uint32)
         * @property {number} maxLedger - largest ledger bound (or 0 for inf)
         * @readonly
         */
      }, {
        key: "ledgerBounds",
        get: function get() {
          return this._ledgerBounds;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * 64 bit account sequence
         * @readonly
         * @type {string}
         */
      }, {
        key: "minAccountSequence",
        get: function get() {
          return this._minAccountSequence;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * 64 bit number of seconds
         * @type {number}
         * @readonly
         */
      }, {
        key: "minAccountSequenceAge",
        get: function get() {
          return this._minAccountSequenceAge;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * 32 bit number of ledgers
         * @type {number}
         * @readonly
         */
      }, {
        key: "minAccountSequenceLedgerGap",
        get: function get() {
          return this._minAccountSequenceLedgerGap;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * array of extra signers ({@link StrKey}s)
         * @type {string[]}
         * @readonly
         */
      }, {
        key: "extraSigners",
        get: function get() {
          return this._extraSigners;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "sequence",
        get: function get() {
          return this._sequence;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "source",
        get: function get() {
          return this._source;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {Array.<xdr.Operation>}
         * @readonly
         */
      }, {
        key: "operations",
        get: function get() {
          return this._operations;
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "memo",
        get: function get() {
          return _memo.Memo.fromXDRObject(this._memo);
        },
        set: function set(value) {
          throw new Error("Transaction is immutable");
        }
        /**
         * Returns the "signature base" of this transaction, which is the value
         * that, when hashed, should be signed to create a signature that
         * validators on the Stellar Network will accept.
         *
         * It is composed of a 4 prefix bytes followed by the xdr-encoded form
         * of this transaction.
         * @returns {Buffer}
         */
      }, {
        key: "signatureBase",
        value: function signatureBase() {
          var tx = this.tx;
          if (this._envelopeType === _xdr["default"].EnvelopeType.envelopeTypeTxV0()) {
            tx = _xdr["default"].Transaction.fromXDR(Buffer.concat([
              // TransactionV0 is a transaction with the AccountID discriminant
              // stripped off, we need to put it back to build a valid transaction
              // which we can use to build a TransactionSignaturePayloadTaggedTransaction
              _xdr["default"].PublicKeyType.publicKeyTypeEd25519().toXDR(),
              tx.toXDR()
            ]));
          }
          var taggedTransaction = new _xdr["default"].TransactionSignaturePayloadTaggedTransaction.envelopeTypeTx(tx);
          var txSignature = new _xdr["default"].TransactionSignaturePayload({
            networkId: _xdr["default"].Hash.fromXDR((0, _hashing.hash)(this.networkPassphrase)),
            taggedTransaction
          });
          return txSignature.toXDR();
        }
        /**
         * To envelope returns a xdr.TransactionEnvelope which can be submitted to the network.
         * @returns {xdr.TransactionEnvelope}
         */
      }, {
        key: "toEnvelope",
        value: function toEnvelope() {
          var rawTx = this.tx.toXDR();
          var signatures = this.signatures.slice();
          var envelope;
          switch (this._envelopeType) {
            case _xdr["default"].EnvelopeType.envelopeTypeTxV0():
              envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTxV0(new _xdr["default"].TransactionV0Envelope({
                tx: _xdr["default"].TransactionV0.fromXDR(rawTx),
                // make a copy of tx
                signatures
              }));
              break;
            case _xdr["default"].EnvelopeType.envelopeTypeTx():
              envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
                tx: _xdr["default"].Transaction.fromXDR(rawTx),
                // make a copy of tx
                signatures
              }));
              break;
            default:
              throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxV0 or envelopeTypeTx but received an ".concat(this._envelopeType.name, "."));
          }
          return envelope;
        }
        /**
         * Calculate the claimable balance ID for an operation within the transaction.
         *
         * @param   {integer}  opIndex   the index of the CreateClaimableBalance op
         * @returns {string}   a hex string representing the claimable balance ID
         *
         * @throws {RangeError}   for invalid `opIndex` value
         * @throws {TypeError}    if op at `opIndex` is not `CreateClaimableBalance`
         * @throws for general XDR un/marshalling failures
         *
         * @see https://github.com/stellar/go/blob/d712346e61e288d450b0c08038c158f8848cc3e4/txnbuild/transaction.go#L392-L435
         *
         */
      }, {
        key: "getClaimableBalanceId",
        value: function getClaimableBalanceId(opIndex) {
          if (!Number.isInteger(opIndex) || opIndex < 0 || opIndex >= this.operations.length) {
            throw new RangeError("invalid operation index");
          }
          var op = this.operations[opIndex];
          try {
            op = _operation.Operation.createClaimableBalance(op);
          } catch (err) {
            throw new TypeError("expected createClaimableBalance, got ".concat(op.type, ": ").concat(err));
          }
          var account = _strkey.StrKey.decodeEd25519PublicKey((0, _decode_encode_muxed_account.extractBaseAddress)(this.source));
          var operationId = _xdr["default"].HashIdPreimage.envelopeTypeOpId(new _xdr["default"].HashIdPreimageOperationId({
            sourceAccount: _xdr["default"].AccountId.publicKeyTypeEd25519(account),
            seqNum: _xdr["default"].SequenceNumber.fromString(this.sequence),
            opNum: opIndex
          }));
          var opIdHash = (0, _hashing.hash)(operationId.toXDR("raw"));
          var balanceId = _xdr["default"].ClaimableBalanceId.claimableBalanceIdTypeV0(opIdHash);
          return balanceId.toXDR("hex");
        }
      }]);
    }(_transaction_base.TransactionBase);
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/fee_bump_transaction.js
var require_fee_bump_transaction = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/fee_bump_transaction.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.FeeBumpTransaction = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _hashing = require_hashing();
    var _transaction = require_transaction();
    var _transaction_base = require_transaction_base();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var FeeBumpTransaction = exports.FeeBumpTransaction = function(_TransactionBase) {
      function FeeBumpTransaction2(envelope, networkPassphrase) {
        var _this;
        _classCallCheck(this, FeeBumpTransaction2);
        if (typeof envelope === "string") {
          var buffer = Buffer.from(envelope, "base64");
          envelope = _xdr["default"].TransactionEnvelope.fromXDR(buffer);
        }
        var envelopeType = envelope["switch"]();
        if (envelopeType !== _xdr["default"].EnvelopeType.envelopeTypeTxFeeBump()) {
          throw new Error("Invalid TransactionEnvelope: expected an envelopeTypeTxFeeBump but received an ".concat(envelopeType.name, "."));
        }
        var txEnvelope = envelope.value();
        var tx = txEnvelope.tx();
        var fee = tx.fee().toString();
        var signatures = (txEnvelope.signatures() || []).slice();
        _this = _callSuper(this, FeeBumpTransaction2, [tx, signatures, fee, networkPassphrase]);
        var innerTxEnvelope = _xdr["default"].TransactionEnvelope.envelopeTypeTx(tx.innerTx().v1());
        _this._feeSource = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(_this.tx.feeSource());
        _this._innerTransaction = new _transaction.Transaction(innerTxEnvelope, networkPassphrase);
        return _this;
      }
      _inherits(FeeBumpTransaction2, _TransactionBase);
      return _createClass(FeeBumpTransaction2, [{
        key: "innerTransaction",
        get: function get() {
          return this._innerTransaction;
        }
        /**
         * @type {Operation[]}
         * @readonly
         */
      }, {
        key: "operations",
        get: function get() {
          return this._innerTransaction.operations;
        }
        /**
         * @type {string}
         * @readonly
         */
      }, {
        key: "feeSource",
        get: function get() {
          return this._feeSource;
        }
        /**
         * Returns the "signature base" of this transaction, which is the value
         * that, when hashed, should be signed to create a signature that
         * validators on the Stellar Network will accept.
         *
         * It is composed of a 4 prefix bytes followed by the xdr-encoded form
         * of this transaction.
         * @returns {Buffer}
         */
      }, {
        key: "signatureBase",
        value: function signatureBase() {
          var taggedTransaction = new _xdr["default"].TransactionSignaturePayloadTaggedTransaction.envelopeTypeTxFeeBump(this.tx);
          var txSignature = new _xdr["default"].TransactionSignaturePayload({
            networkId: _xdr["default"].Hash.fromXDR((0, _hashing.hash)(this.networkPassphrase)),
            taggedTransaction
          });
          return txSignature.toXDR();
        }
        /**
         * To envelope returns a xdr.TransactionEnvelope which can be submitted to the network.
         * @returns {xdr.TransactionEnvelope}
         */
      }, {
        key: "toEnvelope",
        value: function toEnvelope() {
          var envelope = new _xdr["default"].FeeBumpTransactionEnvelope({
            tx: _xdr["default"].FeeBumpTransaction.fromXDR(this.tx.toXDR()),
            // make a copy of the tx
            signatures: this.signatures.slice()
            // make a copy of the signatures
          });
          return new _xdr["default"].TransactionEnvelope.envelopeTypeTxFeeBump(envelope);
        }
      }]);
    }(_transaction_base.TransactionBase);
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/account.js
var require_account = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/account.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Account = void 0;
    var _bignumber = _interopRequireDefault(require_bignumber2());
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Account = exports.Account = function() {
      function Account2(accountId, sequence) {
        _classCallCheck(this, Account2);
        if (_strkey.StrKey.isValidMed25519PublicKey(accountId)) {
          throw new Error("accountId is an M-address; use MuxedAccount instead");
        }
        if (!_strkey.StrKey.isValidEd25519PublicKey(accountId)) {
          throw new Error("accountId is invalid");
        }
        if (!(typeof sequence === "string")) {
          throw new Error("sequence must be of type string");
        }
        this._accountId = accountId;
        this.sequence = new _bignumber["default"](sequence);
      }
      return _createClass(Account2, [{
        key: "accountId",
        value: function accountId() {
          return this._accountId;
        }
        /**
         * @returns {string}  sequence number for the account as a string
         */
      }, {
        key: "sequenceNumber",
        value: function sequenceNumber() {
          return this.sequence.toString();
        }
        /**
         * Increments sequence number in this object by one.
         * @returns {void}
         */
      }, {
        key: "incrementSequenceNumber",
        value: function incrementSequenceNumber() {
          this.sequence = this.sequence.plus(1);
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/muxed_account.js
var require_muxed_account = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/muxed_account.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MuxedAccount = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _account = require_account();
    var _strkey = require_strkey();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var MuxedAccount = exports.MuxedAccount = function() {
      function MuxedAccount2(baseAccount, id) {
        _classCallCheck(this, MuxedAccount2);
        var accountId = baseAccount.accountId();
        if (!_strkey.StrKey.isValidEd25519PublicKey(accountId)) {
          throw new Error("accountId is invalid");
        }
        this.account = baseAccount;
        this._muxedXdr = (0, _decode_encode_muxed_account.encodeMuxedAccount)(accountId, id);
        this._mAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(this._muxedXdr);
        this._id = id;
      }
      return _createClass(MuxedAccount2, [{
        key: "baseAccount",
        value: (
          /**
           * @return {Account} the underlying account object shared among all muxed
           *     accounts with this Stellar address
           */
          function baseAccount() {
            return this.account;
          }
        )
        /**
         * @return {string} the M-address representing this account's (G-address, ID)
         */
      }, {
        key: "accountId",
        value: function accountId() {
          return this._mAddress;
        }
      }, {
        key: "id",
        value: function id() {
          return this._id;
        }
      }, {
        key: "setId",
        value: function setId(id) {
          if (typeof id !== "string") {
            throw new Error("id should be a string representing a number (uint64)");
          }
          this._muxedXdr.med25519().id(_xdr["default"].Uint64.fromString(id));
          this._mAddress = (0, _decode_encode_muxed_account.encodeMuxedAccountToAddress)(this._muxedXdr);
          this._id = id;
          return this;
        }
        /**
         * Accesses the underlying account's sequence number.
         * @return {string}  strigified sequence number for the underlying account
         */
      }, {
        key: "sequenceNumber",
        value: function sequenceNumber() {
          return this.account.sequenceNumber();
        }
        /**
         * Increments the underlying account's sequence number by one.
         * @return {void}
         */
      }, {
        key: "incrementSequenceNumber",
        value: function incrementSequenceNumber() {
          return this.account.incrementSequenceNumber();
        }
        /**
         * @return {xdr.MuxedAccount} the XDR object representing this muxed account's
         *     G-address and uint64 ID
         */
      }, {
        key: "toXDRObject",
        value: function toXDRObject() {
          return this._muxedXdr;
        }
      }, {
        key: "equals",
        value: function equals(otherMuxedAccount) {
          return this.accountId() === otherMuxedAccount.accountId();
        }
      }], [{
        key: "fromAddress",
        value: function fromAddress(mAddress, sequenceNum) {
          var muxedAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(mAddress);
          var gAddress = (0, _decode_encode_muxed_account.extractBaseAddress)(mAddress);
          var id = muxedAccount.med25519().id().toString();
          return new MuxedAccount2(new _account.Account(gAddress, sequenceNum), id);
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/sorobandata_builder.js
var require_sorobandata_builder = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/sorobandata_builder.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SorobanDataBuilder = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SorobanDataBuilder = exports.SorobanDataBuilder = function() {
      function SorobanDataBuilder2(sorobanData) {
        _classCallCheck(this, SorobanDataBuilder2);
        _defineProperty(this, "_data", void 0);
        var data;
        if (!sorobanData) {
          data = new _xdr["default"].SorobanTransactionData({
            resources: new _xdr["default"].SorobanResources({
              footprint: new _xdr["default"].LedgerFootprint({
                readOnly: [],
                readWrite: []
              }),
              instructions: 0,
              readBytes: 0,
              writeBytes: 0
            }),
            ext: new _xdr["default"].ExtensionPoint(0),
            resourceFee: new _xdr["default"].Int64(0)
          });
        } else if (typeof sorobanData === "string" || ArrayBuffer.isView(sorobanData)) {
          data = SorobanDataBuilder2.fromXDR(sorobanData);
        } else {
          data = SorobanDataBuilder2.fromXDR(sorobanData.toXDR());
        }
        this._data = data;
      }
      return _createClass(SorobanDataBuilder2, [{
        key: "setResourceFee",
        value: (
          /**
           * Sets the resource fee portion of the Soroban data.
           * @param {number | bigint | string} fee  the resource fee to set (int64)
           * @returns {SorobanDataBuilder}
           */
          function setResourceFee(fee) {
            this._data.resourceFee(new _xdr["default"].Int64(fee));
            return this;
          }
        )
        /**
         * Sets up the resource metrics.
         *
         * You should almost NEVER need this, as its often generated / provided to you
         * by transaction simulation/preflight from a Soroban RPC server.
         *
         * @param {number} cpuInstrs      number of CPU instructions
         * @param {number} readBytes      number of bytes being read
         * @param {number} writeBytes     number of bytes being written
         *
         * @returns {SorobanDataBuilder}
         */
      }, {
        key: "setResources",
        value: function setResources(cpuInstrs, readBytes, writeBytes) {
          this._data.resources().instructions(cpuInstrs);
          this._data.resources().readBytes(readBytes);
          this._data.resources().writeBytes(writeBytes);
          return this;
        }
        /**
         * Appends the given ledger keys to the existing storage access footprint.
         * @param {xdr.LedgerKey[]} readOnly   read-only keys to add
         * @param {xdr.LedgerKey[]} readWrite  read-write keys to add
         * @returns {SorobanDataBuilder} this builder instance
         */
      }, {
        key: "appendFootprint",
        value: function appendFootprint(readOnly, readWrite) {
          return this.setFootprint(this.getReadOnly().concat(readOnly), this.getReadWrite().concat(readWrite));
        }
        /**
         * Sets the storage access footprint to be a certain set of ledger keys.
         *
         * You can also set each field explicitly via
         * {@link SorobanDataBuilder.setReadOnly} and
         * {@link SorobanDataBuilder.setReadWrite} or add to the existing footprint
         * via {@link SorobanDataBuilder.appendFootprint}.
         *
         * Passing `null|undefined` to either parameter will IGNORE the existing
         * values. If you want to clear them, pass `[]`, instead.
         *
         * @param {xdr.LedgerKey[]|null} [readOnly]   the set of ledger keys to set in
         *    the read-only portion of the transaction's `sorobanData`, or `null |
         *    undefined` to keep the existing keys
         * @param {xdr.LedgerKey[]|null} [readWrite]  the set of ledger keys to set in
         *    the read-write portion of the transaction's `sorobanData`, or `null |
         *    undefined` to keep the existing keys
         * @returns {SorobanDataBuilder} this builder instance
         */
      }, {
        key: "setFootprint",
        value: function setFootprint(readOnly, readWrite) {
          if (readOnly !== null) {
            this.setReadOnly(readOnly);
          }
          if (readWrite !== null) {
            this.setReadWrite(readWrite);
          }
          return this;
        }
        /**
         * @param {xdr.LedgerKey[]} readOnly  read-only keys in the access footprint
         * @returns {SorobanDataBuilder}
         */
      }, {
        key: "setReadOnly",
        value: function setReadOnly(readOnly) {
          this._data.resources().footprint().readOnly(readOnly !== null && readOnly !== void 0 ? readOnly : []);
          return this;
        }
        /**
         * @param {xdr.LedgerKey[]} readWrite  read-write keys in the access footprint
         * @returns {SorobanDataBuilder}
         */
      }, {
        key: "setReadWrite",
        value: function setReadWrite(readWrite) {
          this._data.resources().footprint().readWrite(readWrite !== null && readWrite !== void 0 ? readWrite : []);
          return this;
        }
        /**
         * @returns {xdr.SorobanTransactionData} a copy of the final data structure
         */
      }, {
        key: "build",
        value: function build() {
          return _xdr["default"].SorobanTransactionData.fromXDR(this._data.toXDR());
        }
        //
        // getters follow
        //
        /** @returns {xdr.LedgerKey[]} the read-only storage access pattern */
      }, {
        key: "getReadOnly",
        value: function getReadOnly() {
          return this.getFootprint().readOnly();
        }
        /** @returns {xdr.LedgerKey[]} the read-write storage access pattern */
      }, {
        key: "getReadWrite",
        value: function getReadWrite() {
          return this.getFootprint().readWrite();
        }
        /** @returns {xdr.LedgerFootprint} the storage access pattern */
      }, {
        key: "getFootprint",
        value: function getFootprint() {
          return this._data.resources().footprint();
        }
      }], [{
        key: "fromXDR",
        value: function fromXDR(data) {
          return _xdr["default"].SorobanTransactionData.fromXDR(data, typeof data === "string" ? "base64" : "raw");
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/signerkey.js
var require_signerkey = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/signerkey.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SignerKey = void 0;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SignerKey = exports.SignerKey = function() {
      function SignerKey2() {
        _classCallCheck(this, SignerKey2);
      }
      return _createClass(SignerKey2, null, [{
        key: "decodeAddress",
        value: (
          /**
           * Decodes a StrKey address into an xdr.SignerKey instance.
           *
           * Only ED25519 public keys (G...), pre-auth transactions (T...), hashes
           * (H...), and signed payloads (P...) can be signer keys.
           *
           * @param   {string} address  a StrKey-encoded signer address
           * @returns {xdr.SignerKey}
           */
          function decodeAddress(address) {
            var signerKeyMap = {
              ed25519PublicKey: _xdr["default"].SignerKey.signerKeyTypeEd25519,
              preAuthTx: _xdr["default"].SignerKey.signerKeyTypePreAuthTx,
              sha256Hash: _xdr["default"].SignerKey.signerKeyTypeHashX,
              signedPayload: _xdr["default"].SignerKey.signerKeyTypeEd25519SignedPayload
            };
            var vb = _strkey.StrKey.getVersionByteForPrefix(address);
            var encoder = signerKeyMap[vb];
            if (!encoder) {
              throw new Error("invalid signer key type (".concat(vb, ")"));
            }
            var raw = (0, _strkey.decodeCheck)(vb, address);
            switch (vb) {
              case "signedPayload":
                return encoder(new _xdr["default"].SignerKeyEd25519SignedPayload({
                  ed25519: raw.slice(0, 32),
                  payload: raw.slice(32 + 4)
                }));
              case "ed25519PublicKey":
              // falls through
              case "preAuthTx":
              // falls through
              case "sha256Hash":
              // falls through
              default:
                return encoder(raw);
            }
          }
        )
        /**
         * Encodes a signer key into its StrKey equivalent.
         *
         * @param   {xdr.SignerKey} signerKey   the signer
         * @returns {string} the StrKey representation of the signer
         */
      }, {
        key: "encodeSignerKey",
        value: function encodeSignerKey(signerKey) {
          var strkeyType;
          var raw;
          switch (signerKey["switch"]()) {
            case _xdr["default"].SignerKeyType.signerKeyTypeEd25519():
              strkeyType = "ed25519PublicKey";
              raw = signerKey.value();
              break;
            case _xdr["default"].SignerKeyType.signerKeyTypePreAuthTx():
              strkeyType = "preAuthTx";
              raw = signerKey.value();
              break;
            case _xdr["default"].SignerKeyType.signerKeyTypeHashX():
              strkeyType = "sha256Hash";
              raw = signerKey.value();
              break;
            case _xdr["default"].SignerKeyType.signerKeyTypeEd25519SignedPayload():
              strkeyType = "signedPayload";
              raw = signerKey.ed25519SignedPayload().toXDR("raw");
              break;
            default:
              throw new Error("invalid SignerKey (type: ".concat(signerKey["switch"](), ")"));
          }
          return (0, _strkey.encodeCheck)(strkeyType, raw);
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/transaction_builder.js
var require_transaction_builder = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/transaction_builder.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TransactionBuilder = exports.TimeoutInfinite = exports.BASE_FEE = void 0;
    exports.isValidDate = isValidDate;
    var _jsXdr = require_xdr();
    var _bignumber = _interopRequireDefault(require_bignumber2());
    var _xdr = _interopRequireDefault(require_xdr2());
    var _account = require_account();
    var _muxed_account = require_muxed_account();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    var _transaction = require_transaction();
    var _fee_bump_transaction = require_fee_bump_transaction();
    var _sorobandata_builder = require_sorobandata_builder();
    var _strkey = require_strkey();
    var _signerkey = require_signerkey();
    var _memo = require_memo();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var BASE_FEE = exports.BASE_FEE = "100";
    var TimeoutInfinite = exports.TimeoutInfinite = 0;
    var TransactionBuilder = exports.TransactionBuilder = function() {
      function TransactionBuilder2(sourceAccount) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, TransactionBuilder2);
        if (!sourceAccount) {
          throw new Error("must specify source account for the transaction");
        }
        if (opts.fee === void 0) {
          throw new Error("must specify fee for the transaction (in stroops)");
        }
        this.source = sourceAccount;
        this.operations = [];
        this.baseFee = opts.fee;
        this.timebounds = opts.timebounds ? _objectSpread({}, opts.timebounds) : null;
        this.ledgerbounds = opts.ledgerbounds ? _objectSpread({}, opts.ledgerbounds) : null;
        this.minAccountSequence = opts.minAccountSequence || null;
        this.minAccountSequenceAge = opts.minAccountSequenceAge || null;
        this.minAccountSequenceLedgerGap = opts.minAccountSequenceLedgerGap || null;
        this.extraSigners = opts.extraSigners ? _toConsumableArray(opts.extraSigners) : null;
        this.memo = opts.memo || _memo.Memo.none();
        this.networkPassphrase = opts.networkPassphrase || null;
        this.sorobanData = opts.sorobanData ? new _sorobandata_builder.SorobanDataBuilder(opts.sorobanData).build() : null;
      }
      return _createClass(TransactionBuilder2, [{
        key: "addOperation",
        value: (
          /**
           * Adds an operation to the transaction.
           *
           * @param {xdr.Operation} operation   The xdr operation object, use {@link
           *     Operation} static methods.
           *
           * @returns {TransactionBuilder}
           */
          function addOperation(operation) {
            this.operations.push(operation);
            return this;
          }
        )
        /**
         * Adds an operation to the transaction at a specific index.
         *
         * @param {xdr.Operation} operation - The xdr operation object to add, use {@link Operation} static methods.
         * @param {number} index - The index at which to insert the operation.
         *
         * @returns {TransactionBuilder} - The TransactionBuilder instance for method chaining.
         */
      }, {
        key: "addOperationAt",
        value: function addOperationAt(operation, index) {
          this.operations.splice(index, 0, operation);
          return this;
        }
        /**
         * Removes the operations from the builder (useful when cloning).
         * @returns {TransactionBuilder} this builder instance
         */
      }, {
        key: "clearOperations",
        value: function clearOperations() {
          this.operations = [];
          return this;
        }
        /**
         * Removes the operation at the specified index from the transaction.
         *
         * @param {number} index - The index of the operation to remove.
         *
         * @returns {TransactionBuilder} The TransactionBuilder instance for method chaining.
         */
      }, {
        key: "clearOperationAt",
        value: function clearOperationAt(index) {
          this.operations.splice(index, 1);
          return this;
        }
        /**
         * Adds a memo to the transaction.
         * @param {Memo} memo {@link Memo} object
         * @returns {TransactionBuilder}
         */
      }, {
        key: "addMemo",
        value: function addMemo(memo) {
          this.memo = memo;
          return this;
        }
        /**
         * Sets a timeout precondition on the transaction.
         *
         *  Because of the distributed nature of the Stellar network it is possible
         *  that the status of your transaction will be determined after a long time
         *  if the network is highly congested. If you want to be sure to receive the
         *  status of the transaction within a given period you should set the {@link
         *  TimeBounds} with `maxTime` on the transaction (this is what `setTimeout`
         *  does internally; if there's `minTime` set but no `maxTime` it will be
         *  added).
         *
         *  A call to `TransactionBuilder.setTimeout` is **required** if Transaction
         *  does not have `max_time` set. If you don't want to set timeout, use
         *  `{@link TimeoutInfinite}`. In general you should set `{@link
         *  TimeoutInfinite}` only in smart contracts.
         *
         *  Please note that Horizon may still return <code>504 Gateway Timeout</code>
         *  error, even for short timeouts. In such case you need to resubmit the same
         *  transaction again without making any changes to receive a status. This
         *  method is using the machine system time (UTC), make sure it is set
         *  correctly.
         *
         * @param {number} timeoutSeconds   Number of seconds the transaction is good.
         *     Can't be negative. If the value is {@link TimeoutInfinite}, the
         *     transaction is good indefinitely.
         *
         * @returns {TransactionBuilder}
         *
         * @see {@link TimeoutInfinite}
         * @see https://developers.stellar.org/docs/tutorials/handling-errors/
         */
      }, {
        key: "setTimeout",
        value: function setTimeout2(timeoutSeconds) {
          if (this.timebounds !== null && this.timebounds.maxTime > 0) {
            throw new Error("TimeBounds.max_time has been already set - setting timeout would overwrite it.");
          }
          if (timeoutSeconds < 0) {
            throw new Error("timeout cannot be negative");
          }
          if (timeoutSeconds > 0) {
            var timeoutTimestamp = Math.floor(Date.now() / 1e3) + timeoutSeconds;
            if (this.timebounds === null) {
              this.timebounds = {
                minTime: 0,
                maxTime: timeoutTimestamp
              };
            } else {
              this.timebounds = {
                minTime: this.timebounds.minTime,
                maxTime: timeoutTimestamp
              };
            }
          } else {
            this.timebounds = {
              minTime: 0,
              maxTime: 0
            };
          }
          return this;
        }
        /**
         * If you want to prepare a transaction which will become valid at some point
         * in the future, or be invalid after some time, you can set a timebounds
         * precondition. Internally this will set the `minTime`, and `maxTime`
         * preconditions. Conflicts with `setTimeout`, so use one or the other.
         *
         * @param {Date|number} minEpochOrDate  Either a JS Date object, or a number
         *     of UNIX epoch seconds. The transaction is valid after this timestamp.
         *     Can't be negative. If the value is `0`, the transaction is valid
         *     immediately.
         * @param {Date|number} maxEpochOrDate  Either a JS Date object, or a number
         *     of UNIX epoch seconds. The transaction is valid until this timestamp.
         *     Can't be negative. If the value is `0`, the transaction is valid
         *     indefinitely.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setTimebounds",
        value: function setTimebounds(minEpochOrDate, maxEpochOrDate) {
          if (typeof minEpochOrDate === "number") {
            minEpochOrDate = new Date(minEpochOrDate * 1e3);
          }
          if (typeof maxEpochOrDate === "number") {
            maxEpochOrDate = new Date(maxEpochOrDate * 1e3);
          }
          if (this.timebounds !== null) {
            throw new Error("TimeBounds has been already set - setting timebounds would overwrite it.");
          }
          var minTime = Math.floor(minEpochOrDate.valueOf() / 1e3);
          var maxTime = Math.floor(maxEpochOrDate.valueOf() / 1e3);
          if (minTime < 0) {
            throw new Error("min_time cannot be negative");
          }
          if (maxTime < 0) {
            throw new Error("max_time cannot be negative");
          }
          if (maxTime > 0 && minTime > maxTime) {
            throw new Error("min_time cannot be greater than max_time");
          }
          this.timebounds = {
            minTime,
            maxTime
          };
          return this;
        }
        /**
         * If you want to prepare a transaction which will only be valid within some
         * range of ledgers, you can set a ledgerbounds precondition.
         * Internally this will set the `minLedger` and `maxLedger` preconditions.
         *
         * @param {number} minLedger  The minimum ledger this transaction is valid at
         *     or after. Cannot be negative. If the value is `0` (the default), the
         *     transaction is valid immediately.
         *
         * @param {number} maxLedger  The maximum ledger this transaction is valid
         *     before. Cannot be negative. If the value is `0`, the transaction is
         *     valid indefinitely.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setLedgerbounds",
        value: function setLedgerbounds(minLedger, maxLedger) {
          if (this.ledgerbounds !== null) {
            throw new Error("LedgerBounds has been already set - setting ledgerbounds would overwrite it.");
          }
          if (minLedger < 0) {
            throw new Error("min_ledger cannot be negative");
          }
          if (maxLedger < 0) {
            throw new Error("max_ledger cannot be negative");
          }
          if (maxLedger > 0 && minLedger > maxLedger) {
            throw new Error("min_ledger cannot be greater than max_ledger");
          }
          this.ledgerbounds = {
            minLedger,
            maxLedger
          };
          return this;
        }
        /**
         * If you want to prepare a transaction which will be valid only while the
         * account sequence number is
         *
         *     minAccountSequence <= sourceAccountSequence < tx.seqNum
         *
         * Note that after execution the account's sequence number is always raised to
         * `tx.seqNum`. Internally this will set the `minAccountSequence`
         * precondition.
         *
         * @param {string} minAccountSequence   The minimum source account sequence
         *     number this transaction is valid for. If the value is `0` (the
         *     default), the transaction is valid when `sourceAccount's sequence
         *     number == tx.seqNum- 1`.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setMinAccountSequence",
        value: function setMinAccountSequence(minAccountSequence) {
          if (this.minAccountSequence !== null) {
            throw new Error("min_account_sequence has been already set - setting min_account_sequence would overwrite it.");
          }
          this.minAccountSequence = minAccountSequence;
          return this;
        }
        /**
         * For the transaction to be valid, the current ledger time must be at least
         * `minAccountSequenceAge` greater than sourceAccount's `sequenceTime`.
         * Internally this will set the `minAccountSequenceAge` precondition.
         *
         * @param {number} durationInSeconds  The minimum amount of time between
         *     source account sequence time and the ledger time when this transaction
         *     will become valid. If the value is `0`, the transaction is unrestricted
         *     by the account sequence age. Cannot be negative.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setMinAccountSequenceAge",
        value: function setMinAccountSequenceAge(durationInSeconds) {
          if (typeof durationInSeconds !== "number") {
            throw new Error("min_account_sequence_age must be a number");
          }
          if (this.minAccountSequenceAge !== null) {
            throw new Error("min_account_sequence_age has been already set - setting min_account_sequence_age would overwrite it.");
          }
          if (durationInSeconds < 0) {
            throw new Error("min_account_sequence_age cannot be negative");
          }
          this.minAccountSequenceAge = durationInSeconds;
          return this;
        }
        /**
         * For the transaction to be valid, the current ledger number must be at least
         * `minAccountSequenceLedgerGap` greater than sourceAccount's ledger sequence.
         * Internally this will set the `minAccountSequenceLedgerGap` precondition.
         *
         * @param {number} gap  The minimum number of ledgers between source account
         *     sequence and the ledger number when this transaction will become valid.
         *     If the value is `0`, the transaction is unrestricted by the account
         *     sequence ledger. Cannot be negative.
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setMinAccountSequenceLedgerGap",
        value: function setMinAccountSequenceLedgerGap(gap) {
          if (this.minAccountSequenceLedgerGap !== null) {
            throw new Error("min_account_sequence_ledger_gap has been already set - setting min_account_sequence_ledger_gap would overwrite it.");
          }
          if (gap < 0) {
            throw new Error("min_account_sequence_ledger_gap cannot be negative");
          }
          this.minAccountSequenceLedgerGap = gap;
          return this;
        }
        /**
         * For the transaction to be valid, there must be a signature corresponding to
         * every Signer in this array, even if the signature is not otherwise required
         * by the sourceAccount or operations. Internally this will set the
         * `extraSigners` precondition.
         *
         * @param {string[]} extraSigners   required extra signers (as {@link StrKey}s)
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setExtraSigners",
        value: function setExtraSigners(extraSigners) {
          if (!Array.isArray(extraSigners)) {
            throw new Error("extra_signers must be an array of strings.");
          }
          if (this.extraSigners !== null) {
            throw new Error("extra_signers has been already set - setting extra_signers would overwrite it.");
          }
          if (extraSigners.length > 2) {
            throw new Error("extra_signers cannot be longer than 2 elements.");
          }
          this.extraSigners = _toConsumableArray(extraSigners);
          return this;
        }
        /**
         * Set network nassphrase for the Transaction that will be built.
         *
         * @param {string} networkPassphrase    passphrase of the target Stellar
         *     network (e.g. "Public Global Stellar Network ; September 2015").
         *
         * @returns {TransactionBuilder}
         */
      }, {
        key: "setNetworkPassphrase",
        value: function setNetworkPassphrase(networkPassphrase) {
          this.networkPassphrase = networkPassphrase;
          return this;
        }
        /**
         * Sets the transaction's internal Soroban transaction data (resources,
         * footprint, etc.).
         *
         * For non-contract(non-Soroban) transactions, this setting has no effect. In
         * the case of Soroban transactions, this is either an instance of
         * {@link xdr.SorobanTransactionData} or a base64-encoded string of said
         * structure. This is usually obtained from the simulation response based on a
         * transaction with a Soroban operation (e.g.
         * {@link Operation.invokeHostFunction}, providing necessary resource
         * and storage footprint estimations for contract invocation.
         *
         * @param {xdr.SorobanTransactionData | string} sorobanData    the
         *    {@link xdr.SorobanTransactionData} as a raw xdr object or a base64
         *    string to be decoded
         *
         * @returns {TransactionBuilder}
         * @see {SorobanDataBuilder}
         */
      }, {
        key: "setSorobanData",
        value: function setSorobanData(sorobanData) {
          this.sorobanData = new _sorobandata_builder.SorobanDataBuilder(sorobanData).build();
          return this;
        }
        /**
         * This will build the transaction.
         * It will also increment the source account's sequence number by 1.
         * @returns {Transaction} This method will return the built {@link Transaction}.
         */
      }, {
        key: "build",
        value: function build() {
          var sequenceNumber = new _bignumber["default"](this.source.sequenceNumber()).plus(1);
          var fee = new _bignumber["default"](this.baseFee).times(this.operations.length).toNumber();
          var attrs = {
            fee,
            seqNum: _xdr["default"].SequenceNumber.fromString(sequenceNumber.toString()),
            memo: this.memo ? this.memo.toXDRObject() : null
          };
          if (this.timebounds === null || typeof this.timebounds.minTime === "undefined" || typeof this.timebounds.maxTime === "undefined") {
            throw new Error("TimeBounds has to be set or you must call setTimeout(TimeoutInfinite).");
          }
          if (isValidDate(this.timebounds.minTime)) {
            this.timebounds.minTime = this.timebounds.minTime.getTime() / 1e3;
          }
          if (isValidDate(this.timebounds.maxTime)) {
            this.timebounds.maxTime = this.timebounds.maxTime.getTime() / 1e3;
          }
          this.timebounds.minTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.minTime.toString());
          this.timebounds.maxTime = _jsXdr.UnsignedHyper.fromString(this.timebounds.maxTime.toString());
          var timeBounds = new _xdr["default"].TimeBounds(this.timebounds);
          if (this.hasV2Preconditions()) {
            var ledgerBounds = null;
            if (this.ledgerbounds !== null) {
              ledgerBounds = new _xdr["default"].LedgerBounds(this.ledgerbounds);
            }
            var minSeqNum = this.minAccountSequence || "0";
            minSeqNum = _xdr["default"].SequenceNumber.fromString(minSeqNum);
            var minSeqAge = _jsXdr.UnsignedHyper.fromString(this.minAccountSequenceAge !== null ? this.minAccountSequenceAge.toString() : "0");
            var minSeqLedgerGap = this.minAccountSequenceLedgerGap || 0;
            var extraSigners = this.extraSigners !== null ? this.extraSigners.map(_signerkey.SignerKey.decodeAddress) : [];
            attrs.cond = _xdr["default"].Preconditions.precondV2(new _xdr["default"].PreconditionsV2({
              timeBounds,
              ledgerBounds,
              minSeqNum,
              minSeqAge,
              minSeqLedgerGap,
              extraSigners
            }));
          } else {
            attrs.cond = _xdr["default"].Preconditions.precondTime(timeBounds);
          }
          attrs.sourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(this.source.accountId());
          if (this.sorobanData) {
            attrs.ext = new _xdr["default"].TransactionExt(1, this.sorobanData);
          } else {
            attrs.ext = new _xdr["default"].TransactionExt(0, _xdr["default"].Void);
          }
          var xtx = new _xdr["default"].Transaction(attrs);
          xtx.operations(this.operations);
          var txEnvelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
            tx: xtx
          }));
          var tx = new _transaction.Transaction(txEnvelope, this.networkPassphrase);
          this.source.incrementSequenceNumber();
          return tx;
        }
      }, {
        key: "hasV2Preconditions",
        value: function hasV2Preconditions() {
          return this.ledgerbounds !== null || this.minAccountSequence !== null || this.minAccountSequenceAge !== null || this.minAccountSequenceLedgerGap !== null || this.extraSigners !== null && this.extraSigners.length > 0;
        }
        /**
         * Builds a {@link FeeBumpTransaction}, enabling you to resubmit an existing
         * transaction with a higher fee.
         *
         * @param {Keypair|string}  feeSource - account paying for the transaction,
         *     in the form of either a Keypair (only the public key is used) or
         *     an account ID (in G... or M... form, but refer to `withMuxing`)
         * @param {string}          baseFee   - max fee willing to pay per operation
         *     in inner transaction (**in stroops**)
         * @param {Transaction}     innerTx   - {@link Transaction} to be bumped by
         *     the fee bump transaction
         * @param {string}          networkPassphrase - passphrase of the target
         *     Stellar network (e.g. "Public Global Stellar Network ; September 2015",
         *     see {@link Networks})
         *
         * @todo Alongside the next major version bump, this type signature can be
         *       changed to be less awkward: accept a MuxedAccount as the `feeSource`
         *       rather than a keypair or string.
         *
         * @note Your fee-bump amount should be >= 10x the original fee.
         * @see  https://developers.stellar.org/docs/glossary/fee-bumps/#replace-by-fee
         *
         * @returns {FeeBumpTransaction}
         */
      }], [{
        key: "cloneFrom",
        value: function cloneFrom(tx) {
          var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
          if (!(tx instanceof _transaction.Transaction)) {
            throw new TypeError("expected a 'Transaction', got: ".concat(tx));
          }
          var sequenceNum = (BigInt(tx.sequence) - 1n).toString();
          var source;
          if (_strkey.StrKey.isValidMed25519PublicKey(tx.source)) {
            source = _muxed_account.MuxedAccount.fromAddress(tx.source, sequenceNum);
          } else if (_strkey.StrKey.isValidEd25519PublicKey(tx.source)) {
            source = new _account.Account(tx.source, sequenceNum);
          } else {
            throw new TypeError("unsupported tx source account: ".concat(tx.source));
          }
          var unscaledFee = parseInt(tx.fee, 10) / tx.operations.length;
          var builder = new TransactionBuilder2(source, _objectSpread({
            fee: (unscaledFee || BASE_FEE).toString(),
            memo: tx.memo,
            networkPassphrase: tx.networkPassphrase,
            timebounds: tx.timeBounds,
            ledgerbounds: tx.ledgerBounds,
            minAccountSequence: tx.minAccountSequence,
            minAccountSequenceAge: tx.minAccountSequenceAge,
            minAccountSequenceLedgerGap: tx.minAccountSequenceLedgerGap,
            extraSigners: tx.extraSigners
          }, opts));
          tx._tx.operations().forEach(function(op) {
            return builder.addOperation(op);
          });
          return builder;
        }
      }, {
        key: "buildFeeBumpTransaction",
        value: function buildFeeBumpTransaction(feeSource, baseFee, innerTx, networkPassphrase) {
          var innerOps = innerTx.operations.length;
          var innerBaseFeeRate = new _bignumber["default"](innerTx.fee).div(innerOps);
          var base = new _bignumber["default"](baseFee);
          if (base.lt(innerBaseFeeRate)) {
            throw new Error("Invalid baseFee, it should be at least ".concat(innerBaseFeeRate, " stroops."));
          }
          var minBaseFee = new _bignumber["default"](BASE_FEE);
          if (base.lt(minBaseFee)) {
            throw new Error("Invalid baseFee, it should be at least ".concat(minBaseFee, " stroops."));
          }
          var innerTxEnvelope = innerTx.toEnvelope();
          if (innerTxEnvelope["switch"]() === _xdr["default"].EnvelopeType.envelopeTypeTxV0()) {
            var v0Tx = innerTxEnvelope.v0().tx();
            var v1Tx = new _xdr["default"].Transaction({
              sourceAccount: new _xdr["default"].MuxedAccount.keyTypeEd25519(v0Tx.sourceAccountEd25519()),
              fee: v0Tx.fee(),
              seqNum: v0Tx.seqNum(),
              cond: _xdr["default"].Preconditions.precondTime(v0Tx.timeBounds()),
              memo: v0Tx.memo(),
              operations: v0Tx.operations(),
              ext: new _xdr["default"].TransactionExt(0)
            });
            innerTxEnvelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTx(new _xdr["default"].TransactionV1Envelope({
              tx: v1Tx,
              signatures: innerTxEnvelope.v0().signatures()
            }));
          }
          var feeSourceAccount;
          if (typeof feeSource === "string") {
            feeSourceAccount = (0, _decode_encode_muxed_account.decodeAddressToMuxedAccount)(feeSource);
          } else {
            feeSourceAccount = feeSource.xdrMuxedAccount();
          }
          var tx = new _xdr["default"].FeeBumpTransaction({
            feeSource: feeSourceAccount,
            fee: _xdr["default"].Int64.fromString(base.times(innerOps + 1).toString()),
            innerTx: _xdr["default"].FeeBumpTransactionInnerTx.envelopeTypeTx(innerTxEnvelope.v1()),
            ext: new _xdr["default"].FeeBumpTransactionExt(0)
          });
          var feeBumpTxEnvelope = new _xdr["default"].FeeBumpTransactionEnvelope({
            tx,
            signatures: []
          });
          var envelope = new _xdr["default"].TransactionEnvelope.envelopeTypeTxFeeBump(feeBumpTxEnvelope);
          return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);
        }
        /**
         * Build a {@link Transaction} or {@link FeeBumpTransaction} from an
         * xdr.TransactionEnvelope.
         *
         * @param {string|xdr.TransactionEnvelope} envelope - The transaction envelope
         *     object or base64 encoded string.
         * @param {string} networkPassphrase - The network passphrase of the target
         *     Stellar network (e.g. "Public Global Stellar Network ; September
         *     2015"), see {@link Networks}.
         *
         * @returns {Transaction|FeeBumpTransaction}
         */
      }, {
        key: "fromXDR",
        value: function fromXDR(envelope, networkPassphrase) {
          if (typeof envelope === "string") {
            envelope = _xdr["default"].TransactionEnvelope.fromXDR(envelope, "base64");
          }
          if (envelope["switch"]() === _xdr["default"].EnvelopeType.envelopeTypeTxFeeBump()) {
            return new _fee_bump_transaction.FeeBumpTransaction(envelope, networkPassphrase);
          }
          return new _transaction.Transaction(envelope, networkPassphrase);
        }
      }]);
    }();
    function isValidDate(d) {
      return d instanceof Date && !isNaN(d);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/network.js
var require_network = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/network.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Networks = void 0;
    var Networks = exports.Networks = {
      PUBLIC: "Public Global Stellar Network ; September 2015",
      TESTNET: "Test SDF Network ; September 2015",
      FUTURENET: "Test SDF Future Network ; October 2022",
      SANDBOX: "Local Sandbox Stellar Network ; September 2022",
      STANDALONE: "Standalone Network ; February 2017"
    };
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/soroban.js
var require_soroban = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/soroban.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Soroban = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _toArray(r) {
      return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Soroban = exports.Soroban = function() {
      function Soroban2() {
        _classCallCheck(this, Soroban2);
      }
      return _createClass(Soroban2, null, [{
        key: "formatTokenAmount",
        value: (
          /**
           * Given a whole number smart contract amount of a token and an amount of
           * decimal places (if the token has any), it returns a "display" value.
           *
           * All arithmetic inside the contract is performed on integers to avoid
           * potential precision and consistency issues of floating-point.
           *
           * @param {string} amount   the token amount you want to display
           * @param {number} decimals specify how many decimal places a token has
           *
           * @returns {string} the display value
           * @throws {TypeError} if the given amount has a decimal point already
           * @example
           * formatTokenAmount("123000", 4) === "12.3";
           */
          function formatTokenAmount(amount, decimals) {
            if (amount.includes(".")) {
              throw new TypeError("No decimals are allowed");
            }
            var formatted = amount;
            if (decimals > 0) {
              if (decimals > formatted.length) {
                formatted = ["0", formatted.toString().padStart(decimals, "0")].join(".");
              } else {
                formatted = [formatted.slice(0, -decimals), formatted.slice(-decimals)].join(".");
              }
            }
            return formatted.replace(/(\.\d*?)0+$/, "$1");
          }
        )
        /**
         * Parse a token amount to use it on smart contract
         *
         * This function takes the display value and its decimals (if the token has
         * any) and returns a string that'll be used within the smart contract.
         *
         * @param {string} value      the token amount you want to use it on smart
         *    contract which you've been displaying in a UI
         * @param {number} decimals   the number of decimal places expected in the
         *    display value (different than the "actual" number, because suffix zeroes
         *    might not be present)
         *
         * @returns {string}  the whole number token amount represented by the display
         *    value with the decimal places shifted over
         *
         * @example
         * const displayValueAmount = "123.4560"
         * const parsedAmtForSmartContract = parseTokenAmount(displayValueAmount, 5);
         * parsedAmtForSmartContract === "12345600"
         */
      }, {
        key: "parseTokenAmount",
        value: function parseTokenAmount(value, decimals) {
          var _fraction$padEnd;
          var _value$split$slice = value.split(".").slice(), _value$split$slice2 = _toArray(_value$split$slice), whole = _value$split$slice2[0], fraction = _value$split$slice2[1], rest = _value$split$slice2.slice(2);
          if (rest.length) {
            throw new Error("Invalid decimal value: ".concat(value));
          }
          var shifted = BigInt(whole + ((_fraction$padEnd = fraction === null || fraction === void 0 ? void 0 : fraction.padEnd(decimals, "0")) !== null && _fraction$padEnd !== void 0 ? _fraction$padEnd : "0".repeat(decimals)));
          return shifted.toString();
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/contract.js
var require_contract = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/contract.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Contract = void 0;
    var _address = require_address();
    var _operation = require_operation();
    var _xdr = _interopRequireDefault(require_xdr2());
    var _strkey = require_strkey();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Contract = exports.Contract = function() {
      function Contract2(contractId) {
        _classCallCheck(this, Contract2);
        try {
          this._id = _strkey.StrKey.decodeContract(contractId);
        } catch (_) {
          throw new Error("Invalid contract ID: ".concat(contractId));
        }
      }
      return _createClass(Contract2, [{
        key: "contractId",
        value: function contractId() {
          return _strkey.StrKey.encodeContract(this._id);
        }
        /** @returns {string} the ID as a strkey (C...) */
      }, {
        key: "toString",
        value: function toString() {
          return this.contractId();
        }
        /** @returns {Address} the wrapped address of this contract */
      }, {
        key: "address",
        value: function address() {
          return _address.Address.contract(this._id);
        }
        /**
         * Returns an operation that will invoke this contract call.
         *
         * @param {string}        method   name of the method to call
         * @param {...xdr.ScVal}  params   arguments to pass to the function call
         *
         * @returns {xdr.Operation}   an InvokeHostFunctionOp operation to call the
         *    contract with the given method and parameters
         *
         * @see Operation.invokeHostFunction
         * @see Operation.invokeContractFunction
         * @see Operation.createCustomContract
         * @see Operation.createStellarAssetContract
         * @see Operation.uploadContractWasm
         */
      }, {
        key: "call",
        value: function call(method) {
          for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            params[_key - 1] = arguments[_key];
          }
          return _operation.Operation.invokeContractFunction({
            contract: this.address().toString(),
            "function": method,
            args: params
          });
        }
        /**
         * Returns the read-only footprint entries necessary for any invocations to
         * this contract, for convenience when manually adding it to your
         * transaction's overall footprint or doing bump/restore operations.
         *
         * @returns {xdr.LedgerKey} the ledger key for the deployed contract instance
         */
      }, {
        key: "getFootprint",
        value: function getFootprint() {
          return _xdr["default"].LedgerKey.contractData(new _xdr["default"].LedgerKeyContractData({
            contract: this.address().toScAddress(),
            key: _xdr["default"].ScVal.scvLedgerKeyContractInstance(),
            durability: _xdr["default"].ContractDataDurability.persistent()
          }));
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/uint128.js
var require_uint128 = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/uint128.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Uint128 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Uint128 = exports.Uint128 = function(_LargeInt) {
      function Uint1282() {
        _classCallCheck(this, Uint1282);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Uint1282, [args]);
      }
      _inherits(Uint1282, _LargeInt);
      return _createClass(Uint1282, [{
        key: "unsigned",
        get: function get() {
          return true;
        }
      }, {
        key: "size",
        get: function get() {
          return 128;
        }
      }]);
    }(_jsXdr.LargeInt);
    Uint128.defineIntBoundaries();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/uint256.js
var require_uint256 = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/uint256.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Uint256 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Uint256 = exports.Uint256 = function(_LargeInt) {
      function Uint2562() {
        _classCallCheck(this, Uint2562);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Uint2562, [args]);
      }
      _inherits(Uint2562, _LargeInt);
      return _createClass(Uint2562, [{
        key: "unsigned",
        get: function get() {
          return true;
        }
      }, {
        key: "size",
        get: function get() {
          return 256;
        }
      }]);
    }(_jsXdr.LargeInt);
    Uint256.defineIntBoundaries();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/int128.js
var require_int128 = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/int128.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Int128 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Int128 = exports.Int128 = function(_LargeInt) {
      function Int1282() {
        _classCallCheck(this, Int1282);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Int1282, [args]);
      }
      _inherits(Int1282, _LargeInt);
      return _createClass(Int1282, [{
        key: "unsigned",
        get: function get() {
          return false;
        }
      }, {
        key: "size",
        get: function get() {
          return 128;
        }
      }]);
    }(_jsXdr.LargeInt);
    Int128.defineIntBoundaries();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/int256.js
var require_int256 = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/int256.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Int256 = void 0;
    var _jsXdr = require_xdr();
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var Int256 = exports.Int256 = function(_LargeInt) {
      function Int2562() {
        _classCallCheck(this, Int2562);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return _callSuper(this, Int2562, [args]);
      }
      _inherits(Int2562, _LargeInt);
      return _createClass(Int2562, [{
        key: "unsigned",
        get: function get() {
          return false;
        }
      }, {
        key: "size",
        get: function get() {
          return 256;
        }
      }]);
    }(_jsXdr.LargeInt);
    Int256.defineIntBoundaries();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/xdr_large_int.js
var require_xdr_large_int = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/xdr_large_int.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.XdrLargeInt = void 0;
    var _jsXdr = require_xdr();
    var _uint = require_uint128();
    var _uint2 = require_uint256();
    var _int = require_int128();
    var _int2 = require_int256();
    var _xdr = _interopRequireDefault(require_xdr2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var XdrLargeInt = exports.XdrLargeInt = function() {
      function XdrLargeInt2(type, values) {
        _classCallCheck(this, XdrLargeInt2);
        _defineProperty(this, "int", void 0);
        _defineProperty(this, "type", void 0);
        if (!(values instanceof Array)) {
          values = [values];
        }
        values = values.map(function(i) {
          if (typeof i === "bigint") {
            return i;
          }
          if (i instanceof XdrLargeInt2) {
            return i.toBigInt();
          }
          return BigInt(i);
        });
        switch (type) {
          case "i64":
            this["int"] = new _jsXdr.Hyper(values);
            break;
          case "i128":
            this["int"] = new _int.Int128(values);
            break;
          case "i256":
            this["int"] = new _int2.Int256(values);
            break;
          case "u64":
            this["int"] = new _jsXdr.UnsignedHyper(values);
            break;
          case "u128":
            this["int"] = new _uint.Uint128(values);
            break;
          case "u256":
            this["int"] = new _uint2.Uint256(values);
            break;
          default:
            throw TypeError("invalid type: ".concat(type));
        }
        this.type = type;
      }
      return _createClass(XdrLargeInt2, [{
        key: "toNumber",
        value: function toNumber() {
          var bi = this["int"].toBigInt();
          if (bi > Number.MAX_SAFE_INTEGER || bi < Number.MIN_SAFE_INTEGER) {
            throw RangeError("value ".concat(bi, " not in range for Number ") + "[".concat(Number.MAX_SAFE_INTEGER, ", ").concat(Number.MIN_SAFE_INTEGER, "]"));
          }
          return Number(bi);
        }
        /** @returns {bigint} */
      }, {
        key: "toBigInt",
        value: function toBigInt() {
          return this["int"].toBigInt();
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = I64` */
      }, {
        key: "toI64",
        value: function toI64() {
          this._sizeCheck(64);
          var v = this.toBigInt();
          if (BigInt.asIntN(64, v) !== v) {
            throw RangeError("value too large for i64: ".concat(v));
          }
          return _xdr["default"].ScVal.scvI64(new _xdr["default"].Int64(v));
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = U64` */
      }, {
        key: "toU64",
        value: function toU64() {
          this._sizeCheck(64);
          return _xdr["default"].ScVal.scvU64(
            new _xdr["default"].Uint64(BigInt.asUintN(64, this.toBigInt()))
            // reiterpret as unsigned
          );
        }
        /**
         * @returns {xdr.ScVal} the integer encoded with `ScValType = I128`
         * @throws {RangeError} if the value cannot fit in 128 bits
         */
      }, {
        key: "toI128",
        value: function toI128() {
          this._sizeCheck(128);
          var v = this["int"].toBigInt();
          var hi64 = BigInt.asIntN(64, v >> 64n);
          var lo64 = BigInt.asUintN(64, v);
          return _xdr["default"].ScVal.scvI128(new _xdr["default"].Int128Parts({
            hi: new _xdr["default"].Int64(hi64),
            lo: new _xdr["default"].Uint64(lo64)
          }));
        }
        /**
         * @returns {xdr.ScVal} the integer encoded with `ScValType = U128`
         * @throws {RangeError} if the value cannot fit in 128 bits
         */
      }, {
        key: "toU128",
        value: function toU128() {
          this._sizeCheck(128);
          var v = this["int"].toBigInt();
          return _xdr["default"].ScVal.scvU128(new _xdr["default"].UInt128Parts({
            hi: new _xdr["default"].Uint64(BigInt.asUintN(64, v >> 64n)),
            lo: new _xdr["default"].Uint64(BigInt.asUintN(64, v))
          }));
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = I256` */
      }, {
        key: "toI256",
        value: function toI256() {
          var v = this["int"].toBigInt();
          var hiHi64 = BigInt.asIntN(64, v >> 192n);
          var hiLo64 = BigInt.asUintN(64, v >> 128n);
          var loHi64 = BigInt.asUintN(64, v >> 64n);
          var loLo64 = BigInt.asUintN(64, v);
          return _xdr["default"].ScVal.scvI256(new _xdr["default"].Int256Parts({
            hiHi: new _xdr["default"].Int64(hiHi64),
            hiLo: new _xdr["default"].Uint64(hiLo64),
            loHi: new _xdr["default"].Uint64(loHi64),
            loLo: new _xdr["default"].Uint64(loLo64)
          }));
        }
        /** @returns {xdr.ScVal} the integer encoded with `ScValType = U256` */
      }, {
        key: "toU256",
        value: function toU256() {
          var v = this["int"].toBigInt();
          var hiHi64 = BigInt.asUintN(64, v >> 192n);
          var hiLo64 = BigInt.asUintN(64, v >> 128n);
          var loHi64 = BigInt.asUintN(64, v >> 64n);
          var loLo64 = BigInt.asUintN(64, v);
          return _xdr["default"].ScVal.scvU256(new _xdr["default"].UInt256Parts({
            hiHi: new _xdr["default"].Uint64(hiHi64),
            hiLo: new _xdr["default"].Uint64(hiLo64),
            loHi: new _xdr["default"].Uint64(loHi64),
            loLo: new _xdr["default"].Uint64(loLo64)
          }));
        }
        /** @returns {xdr.ScVal} the smallest interpretation of the stored value */
      }, {
        key: "toScVal",
        value: function toScVal() {
          switch (this.type) {
            case "i64":
              return this.toI64();
            case "i128":
              return this.toI128();
            case "i256":
              return this.toI256();
            case "u64":
              return this.toU64();
            case "u128":
              return this.toU128();
            case "u256":
              return this.toU256();
            default:
              throw TypeError("invalid type: ".concat(this.type));
          }
        }
      }, {
        key: "valueOf",
        value: function valueOf() {
          return this["int"].valueOf();
        }
      }, {
        key: "toString",
        value: function toString() {
          return this["int"].toString();
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            value: this.toBigInt().toString(),
            type: this.type
          };
        }
      }, {
        key: "_sizeCheck",
        value: function _sizeCheck(bits) {
          if (this["int"].size > bits) {
            throw RangeError("value too large for ".concat(bits, " bits (").concat(this.type, ")"));
          }
        }
      }], [{
        key: "isType",
        value: function isType(type) {
          switch (type) {
            case "i64":
            case "i128":
            case "i256":
            case "u64":
            case "u128":
            case "u256":
              return true;
            default:
              return false;
          }
        }
        /**
         * Convert the raw `ScValType` string (e.g. 'scvI128', generated by the XDR)
         * to a type description for {@link XdrLargeInt} construction (e.g. 'i128')
         *
         * @param {string} scvType  the `xdr.ScValType` as a string
         * @returns {string} a suitable equivalent type to construct this object
         */
      }, {
        key: "getType",
        value: function getType(scvType) {
          return scvType.slice(3).toLowerCase();
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/sc_int.js
var require_sc_int = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/sc_int.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ScInt = void 0;
    var _xdr_large_int = require_xdr_large_int();
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _callSuper(t, o, e) {
      return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }
    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }
    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
      } catch (t2) {
      }
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct2() {
        return !!t;
      })();
    }
    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
        return t2.__proto__ || Object.getPrototypeOf(t2);
      }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: true, configurable: true } }), Object.defineProperty(t, "prototype", { writable: false }), e && _setPrototypeOf(t, e);
    }
    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
        return t2.__proto__ = e2, t2;
      }, _setPrototypeOf(t, e);
    }
    var ScInt = exports.ScInt = function(_XdrLargeInt) {
      function ScInt2(value, opts) {
        var _opts$type;
        _classCallCheck(this, ScInt2);
        var signed = value < 0;
        var type = (_opts$type = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type !== void 0 ? _opts$type : "";
        if (type.startsWith("u") && signed) {
          throw TypeError("specified type ".concat(opts.type, " yet negative (").concat(value, ")"));
        }
        if (type === "") {
          type = signed ? "i" : "u";
          var bitlen = nearestBigIntSize(value);
          switch (bitlen) {
            case 64:
            case 128:
            case 256:
              type += bitlen.toString();
              break;
            default:
              throw RangeError("expected 64/128/256 bits for input (".concat(value, "), got ").concat(bitlen));
          }
        }
        return _callSuper(this, ScInt2, [type, value]);
      }
      _inherits(ScInt2, _XdrLargeInt);
      return _createClass(ScInt2);
    }(_xdr_large_int.XdrLargeInt);
    function nearestBigIntSize(bigI) {
      var _find;
      var bitlen = bigI.toString(2).length;
      return (_find = [64, 128, 256].find(function(len) {
        return bitlen <= len;
      })) !== null && _find !== void 0 ? _find : bitlen;
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/index.js
var require_numbers = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/numbers/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "Int128", {
      enumerable: true,
      get: function get() {
        return _int.Int128;
      }
    });
    Object.defineProperty(exports, "Int256", {
      enumerable: true,
      get: function get() {
        return _int2.Int256;
      }
    });
    Object.defineProperty(exports, "ScInt", {
      enumerable: true,
      get: function get() {
        return _sc_int.ScInt;
      }
    });
    Object.defineProperty(exports, "Uint128", {
      enumerable: true,
      get: function get() {
        return _uint.Uint128;
      }
    });
    Object.defineProperty(exports, "Uint256", {
      enumerable: true,
      get: function get() {
        return _uint2.Uint256;
      }
    });
    Object.defineProperty(exports, "XdrLargeInt", {
      enumerable: true,
      get: function get() {
        return _xdr_large_int.XdrLargeInt;
      }
    });
    exports.scValToBigInt = scValToBigInt;
    var _xdr_large_int = require_xdr_large_int();
    var _uint = require_uint128();
    var _uint2 = require_uint256();
    var _int = require_int128();
    var _int2 = require_int256();
    var _sc_int = require_sc_int();
    function scValToBigInt(scv) {
      var scIntType = _xdr_large_int.XdrLargeInt.getType(scv["switch"]().name);
      switch (scv["switch"]().name) {
        case "scvU32":
        case "scvI32":
          return BigInt(scv.value());
        case "scvU64":
        case "scvI64":
          return new _xdr_large_int.XdrLargeInt(scIntType, scv.value()).toBigInt();
        case "scvU128":
        case "scvI128":
          return new _xdr_large_int.XdrLargeInt(scIntType, [scv.value().lo(), scv.value().hi()]).toBigInt();
        case "scvU256":
        case "scvI256":
          return new _xdr_large_int.XdrLargeInt(scIntType, [scv.value().loLo(), scv.value().loHi(), scv.value().hiLo(), scv.value().hiHi()]).toBigInt();
        default:
          throw TypeError("expected integer type, got ".concat(scv["switch"]()));
      }
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/scval.js
var require_scval = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/scval.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.nativeToScVal = nativeToScVal;
    exports.scValToNative = scValToNative;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _address = require_address();
    var _contract = require_contract();
    var _index = require_numbers();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }
    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }
    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }
    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = false;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function nativeToScVal(val) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      switch (_typeof(val)) {
        case "object": {
          var _val$constructor$name, _val$constructor;
          if (val === null) {
            return _xdr["default"].ScVal.scvVoid();
          }
          if (val instanceof _xdr["default"].ScVal) {
            return val;
          }
          if (val instanceof _address.Address) {
            return val.toScVal();
          }
          if (val instanceof _keypair.Keypair) {
            return nativeToScVal(val.publicKey(), {
              type: "address"
            });
          }
          if (val instanceof _contract.Contract) {
            return val.address().toScVal();
          }
          if (val instanceof Uint8Array || Buffer.isBuffer(val)) {
            var _opts$type;
            var copy = Uint8Array.from(val);
            switch ((_opts$type = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type !== void 0 ? _opts$type : "bytes") {
              case "bytes":
                return _xdr["default"].ScVal.scvBytes(copy);
              case "symbol":
                return _xdr["default"].ScVal.scvSymbol(copy);
              case "string":
                return _xdr["default"].ScVal.scvString(copy);
              default:
                throw new TypeError("invalid type (".concat(opts.type, ") specified for bytes-like value"));
            }
          }
          if (Array.isArray(val)) {
            return _xdr["default"].ScVal.scvVec(val.map(function(v) {
              return nativeToScVal(v, opts);
            }));
          }
          if (((_val$constructor$name = (_val$constructor = val.constructor) === null || _val$constructor === void 0 ? void 0 : _val$constructor.name) !== null && _val$constructor$name !== void 0 ? _val$constructor$name : "") !== "Object") {
            var _val$constructor2;
            throw new TypeError("cannot interpret ".concat((_val$constructor2 = val.constructor) === null || _val$constructor2 === void 0 ? void 0 : _val$constructor2.name, " value as ScVal (").concat(JSON.stringify(val), ")"));
          }
          return _xdr["default"].ScVal.scvMap(Object.entries(val).sort(function(_ref, _ref2) {
            var _ref3 = _slicedToArray(_ref, 1), key1 = _ref3[0];
            var _ref4 = _slicedToArray(_ref2, 1), key2 = _ref4[0];
            return key1.localeCompare(key2);
          }).map(function(_ref5) {
            var _k, _opts$type2;
            var _ref6 = _slicedToArray(_ref5, 2), k = _ref6[0], v = _ref6[1];
            var _ref7 = (_k = ((_opts$type2 = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type2 !== void 0 ? _opts$type2 : {})[k]) !== null && _k !== void 0 ? _k : [null, null], _ref8 = _slicedToArray(_ref7, 2), keyType = _ref8[0], valType = _ref8[1];
            var keyOpts = keyType ? {
              type: keyType
            } : {};
            var valOpts = valType ? {
              type: valType
            } : {};
            return new _xdr["default"].ScMapEntry({
              key: nativeToScVal(k, keyOpts),
              val: nativeToScVal(v, valOpts)
            });
          }));
        }
        case "number":
        case "bigint":
          switch (opts === null || opts === void 0 ? void 0 : opts.type) {
            case "u32":
              return _xdr["default"].ScVal.scvU32(val);
            case "i32":
              return _xdr["default"].ScVal.scvI32(val);
            default:
              break;
          }
          return new _index.ScInt(val, {
            type: opts === null || opts === void 0 ? void 0 : opts.type
          }).toScVal();
        case "string": {
          var _opts$type3;
          var optType = (_opts$type3 = opts === null || opts === void 0 ? void 0 : opts.type) !== null && _opts$type3 !== void 0 ? _opts$type3 : "string";
          switch (optType) {
            case "string":
              return _xdr["default"].ScVal.scvString(val);
            case "symbol":
              return _xdr["default"].ScVal.scvSymbol(val);
            case "address":
              return new _address.Address(val).toScVal();
            case "u32":
              return _xdr["default"].ScVal.scvU32(parseInt(val, 10));
            case "i32":
              return _xdr["default"].ScVal.scvI32(parseInt(val, 10));
            default:
              if (_index.XdrLargeInt.isType(optType)) {
                return new _index.XdrLargeInt(optType, val).toScVal();
              }
              throw new TypeError("invalid type (".concat(opts.type, ") specified for string value"));
          }
        }
        case "boolean":
          return _xdr["default"].ScVal.scvBool(val);
        case "undefined":
          return _xdr["default"].ScVal.scvVoid();
        case "function":
          return nativeToScVal(val());
        default:
          throw new TypeError("failed to convert typeof ".concat(_typeof(val), " (").concat(val, ")"));
      }
    }
    function scValToNative(scv) {
      var _scv$vec, _scv$map;
      switch (scv["switch"]().value) {
        case _xdr["default"].ScValType.scvVoid().value:
          return null;
        // these can be converted to bigints directly
        case _xdr["default"].ScValType.scvU64().value:
        case _xdr["default"].ScValType.scvI64().value:
          return scv.value().toBigInt();
        // these can be parsed by internal abstractions note that this can also
        // handle the above two cases, but it's not as efficient (another
        // type-check, parsing, etc.)
        case _xdr["default"].ScValType.scvU128().value:
        case _xdr["default"].ScValType.scvI128().value:
        case _xdr["default"].ScValType.scvU256().value:
        case _xdr["default"].ScValType.scvI256().value:
          return (0, _index.scValToBigInt)(scv);
        case _xdr["default"].ScValType.scvVec().value:
          return ((_scv$vec = scv.vec()) !== null && _scv$vec !== void 0 ? _scv$vec : []).map(scValToNative);
        case _xdr["default"].ScValType.scvAddress().value:
          return _address.Address.fromScVal(scv).toString();
        case _xdr["default"].ScValType.scvMap().value:
          return Object.fromEntries(((_scv$map = scv.map()) !== null && _scv$map !== void 0 ? _scv$map : []).map(function(entry) {
            return [scValToNative(entry.key()), scValToNative(entry.val())];
          }));
        // these return the primitive type directly
        case _xdr["default"].ScValType.scvBool().value:
        case _xdr["default"].ScValType.scvU32().value:
        case _xdr["default"].ScValType.scvI32().value:
        case _xdr["default"].ScValType.scvBytes().value:
          return scv.value();
        // Symbols are limited to [a-zA-Z0-9_]+, so we can safely make ascii strings
        //
        // Strings, however, are "presented" as strings and we treat them as such
        // (in other words, string = bytes with a hint that it's text). If the user
        // encoded non-printable bytes in their string value, that's on them.
        //
        // Note that we assume a utf8 encoding (ascii-compatible). For other
        // encodings, you should probably use bytes anyway. If it cannot be decoded,
        // the raw bytes are returned.
        case _xdr["default"].ScValType.scvSymbol().value:
        case _xdr["default"].ScValType.scvString().value: {
          var v = scv.value();
          if (Buffer.isBuffer(v) || ArrayBuffer.isView(v)) {
            try {
              return new TextDecoder().decode(v);
            } catch (e) {
              return new Uint8Array(v.buffer);
            }
          }
          return v;
        }
        // these can be converted to bigint
        case _xdr["default"].ScValType.scvTimepoint().value:
        case _xdr["default"].ScValType.scvDuration().value:
          return new _xdr["default"].Uint64(scv.value()).toBigInt();
        case _xdr["default"].ScValType.scvError().value:
          switch (scv.error()["switch"]().value) {
            // Distinguish errors from the user contract.
            case _xdr["default"].ScErrorType.sceContract().value:
              return {
                type: "contract",
                code: scv.error().contractCode()
              };
            default: {
              var err = scv.error();
              return {
                type: "system",
                code: err.code().value,
                value: err.code().name
              };
            }
          }
        // in the fallthrough case, just return the underlying value directly
        default:
          return scv.value();
      }
    }
    _xdr["default"].scvSortedMap = function(items) {
      var sorted = Array.from(items).sort(function(a, b) {
        var nativeA = scValToNative(a.key());
        var nativeB = scValToNative(b.key());
        switch (_typeof(nativeA)) {
          case "number":
          case "bigint":
            return nativeA < nativeB ? -1 : 1;
          default:
            return nativeA.toString().localeCompare(nativeB.toString());
        }
      });
      return _xdr["default"].ScVal.scvMap(sorted);
    };
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/events.js
var require_events = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/events.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.humanizeEvents = humanizeEvents;
    var _strkey = require_strkey();
    var _scval = require_scval();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function humanizeEvents(events) {
      return events.map(function(e) {
        if (e.inSuccessfulContractCall) {
          return extractEvent(e.event());
        }
        return extractEvent(e);
      });
    }
    function extractEvent(event) {
      return _objectSpread(_objectSpread({}, typeof event.contractId === "function" && event.contractId() != null && {
        contractId: _strkey.StrKey.encodeContract(event.contractId())
      }), {}, {
        type: event.type().name,
        topics: event.body().value().topics().map(function(t) {
          return (0, _scval.scValToNative)(t);
        }),
        data: (0, _scval.scValToNative)(event.body().value().data())
      });
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/auth.js
var require_auth = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/auth.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.authorizeEntry = authorizeEntry;
    exports.authorizeInvocation = authorizeInvocation;
    var _xdr = _interopRequireDefault(require_xdr2());
    var _keypair = require_keypair();
    var _strkey = require_strkey();
    var _network = require_network();
    var _hashing = require_hashing();
    var _address = require_address();
    var _scval = require_scval();
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator["return"] && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, "catch": function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function authorizeEntry(_x, _x2, _x3) {
      return _authorizeEntry.apply(this, arguments);
    }
    function _authorizeEntry() {
      _authorizeEntry = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(entry, signer, validUntilLedgerSeq) {
        var networkPassphrase, clone, addrAuth, networkId, preimage, payload, signature, publicKey, sigResult, sigScVal, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              networkPassphrase = _args.length > 3 && _args[3] !== void 0 ? _args[3] : _network.Networks.FUTURENET;
              if (!(entry.credentials()["switch"]().value !== _xdr["default"].SorobanCredentialsType.sorobanCredentialsAddress().value)) {
                _context.next = 3;
                break;
              }
              return _context.abrupt("return", entry);
            case 3:
              clone = _xdr["default"].SorobanAuthorizationEntry.fromXDR(entry.toXDR());
              addrAuth = clone.credentials().address();
              addrAuth.signatureExpirationLedger(validUntilLedgerSeq);
              networkId = (0, _hashing.hash)(Buffer.from(networkPassphrase));
              preimage = _xdr["default"].HashIdPreimage.envelopeTypeSorobanAuthorization(new _xdr["default"].HashIdPreimageSorobanAuthorization({
                networkId,
                nonce: addrAuth.nonce(),
                invocation: clone.rootInvocation(),
                signatureExpirationLedger: addrAuth.signatureExpirationLedger()
              }));
              payload = (0, _hashing.hash)(preimage.toXDR());
              if (!(typeof signer === "function")) {
                _context.next = 16;
                break;
              }
              _context.next = 12;
              return signer(preimage);
            case 12:
              sigResult = _context.sent;
              if (sigResult !== null && sigResult !== void 0 && sigResult.signature) {
                signature = Buffer.from(sigResult.signature);
                publicKey = sigResult.publicKey;
              } else {
                signature = Buffer.from(sigResult);
                publicKey = _address.Address.fromScAddress(addrAuth.address()).toString();
              }
              _context.next = 18;
              break;
            case 16:
              signature = Buffer.from(signer.sign(payload));
              publicKey = signer.publicKey();
            case 18:
              if (_keypair.Keypair.fromPublicKey(publicKey).verify(payload, signature)) {
                _context.next = 20;
                break;
              }
              throw new Error("signature doesn't match payload");
            case 20:
              sigScVal = (0, _scval.nativeToScVal)({
                public_key: _strkey.StrKey.decodeEd25519PublicKey(publicKey),
                signature
              }, {
                type: {
                  public_key: ["symbol", null],
                  signature: ["symbol", null]
                }
              });
              addrAuth.signature(_xdr["default"].ScVal.scvVec([sigScVal]));
              return _context.abrupt("return", clone);
            case 23:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _authorizeEntry.apply(this, arguments);
    }
    function authorizeInvocation(signer, validUntilLedgerSeq, invocation) {
      var publicKey = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "";
      var networkPassphrase = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : _network.Networks.FUTURENET;
      var kp = _keypair.Keypair.random().rawPublicKey();
      var nonce = new _xdr["default"].Int64(bytesToInt64(kp));
      var pk = publicKey || signer.publicKey();
      if (!pk) {
        throw new Error("authorizeInvocation requires publicKey parameter");
      }
      var entry = new _xdr["default"].SorobanAuthorizationEntry({
        rootInvocation: invocation,
        credentials: _xdr["default"].SorobanCredentials.sorobanCredentialsAddress(new _xdr["default"].SorobanAddressCredentials({
          address: new _address.Address(pk).toScAddress(),
          nonce,
          signatureExpirationLedger: 0,
          // replaced
          signature: _xdr["default"].ScVal.scvVec([])
          // replaced
        }))
      });
      return authorizeEntry(entry, signer, validUntilLedgerSeq, networkPassphrase);
    }
    function bytesToInt64(bytes) {
      return bytes.subarray(0, 8).reduce(function(accum, b) {
        return accum << 8 | b;
      }, 0);
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/invocation.js
var require_invocation = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/invocation.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildInvocationTree = buildInvocationTree;
    exports.walkInvocationTree = walkInvocationTree;
    var _asset = require_asset();
    var _address = require_address();
    var _scval = require_scval();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function buildInvocationTree(root) {
      var fn = root["function"]();
      var output = {};
      var inner = fn.value();
      switch (fn["switch"]().value) {
        // sorobanAuthorizedFunctionTypeContractFn
        case 0:
          output.type = "execute";
          output.args = {
            source: _address.Address.fromScAddress(inner.contractAddress()).toString(),
            "function": inner.functionName(),
            args: inner.args().map(function(arg) {
              return (0, _scval.scValToNative)(arg);
            })
          };
          break;
        // sorobanAuthorizedFunctionTypeCreateContractHostFn
        // sorobanAuthorizedFunctionTypeCreateContractV2HostFn
        case 1:
        // fallthrough: just no ctor args in V1
        case 2: {
          var createV2 = fn["switch"]().value === 2;
          output.type = "create";
          output.args = {};
          var _ref = [inner.executable(), inner.contractIdPreimage()], exec = _ref[0], preimage = _ref[1];
          if (!!exec["switch"]().value !== !!preimage["switch"]().value) {
            throw new Error("creation function appears invalid: ".concat(JSON.stringify(inner), " (should be wasm+address or token+asset)"));
          }
          switch (exec["switch"]().value) {
            // contractExecutableWasm
            case 0: {
              var details = preimage.fromAddress();
              output.args.type = "wasm";
              output.args.wasm = _objectSpread({
                salt: details.salt().toString("hex"),
                hash: exec.wasmHash().toString("hex"),
                address: _address.Address.fromScAddress(details.address()).toString()
              }, createV2 && {
                constructorArgs: inner.constructorArgs().map(function(arg) {
                  return (0, _scval.scValToNative)(arg);
                })
              });
              break;
            }
            // contractExecutableStellarAsset
            case 1:
              output.args.type = "sac";
              output.args.asset = _asset.Asset.fromOperation(preimage.fromAsset()).toString();
              break;
            default:
              throw new Error("unknown creation type: ".concat(JSON.stringify(exec)));
          }
          break;
        }
        default:
          throw new Error("unknown invocation type (".concat(fn["switch"](), "): ").concat(JSON.stringify(fn)));
      }
      output.invocations = root.subInvocations().map(function(i) {
        return buildInvocationTree(i);
      });
      return output;
    }
    function walkInvocationTree(root, callback) {
      walkHelper(root, 1, callback);
    }
    function walkHelper(node, depth, callback, parent) {
      if (callback(node, depth, parent) === false) {
        return;
      }
      node.subInvocations().forEach(function(i) {
        return walkHelper(i, depth + 1, callback, node);
      });
    }
  }
});

// node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/index.js
var require_lib = __commonJS({
  "node_modules/@stellar/stellar-sdk/node_modules/@stellar/stellar-base/lib/index.js"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      xdr: true,
      cereal: true,
      hash: true,
      sign: true,
      verify: true,
      FastSigning: true,
      getLiquidityPoolId: true,
      LiquidityPoolFeeV18: true,
      Keypair: true,
      UnsignedHyper: true,
      Hyper: true,
      TransactionBase: true,
      Transaction: true,
      FeeBumpTransaction: true,
      TransactionBuilder: true,
      TimeoutInfinite: true,
      BASE_FEE: true,
      Asset: true,
      LiquidityPoolAsset: true,
      LiquidityPoolId: true,
      Operation: true,
      AuthRequiredFlag: true,
      AuthRevocableFlag: true,
      AuthImmutableFlag: true,
      AuthClawbackEnabledFlag: true,
      Account: true,
      MuxedAccount: true,
      Claimant: true,
      Networks: true,
      StrKey: true,
      SignerKey: true,
      Soroban: true,
      decodeAddressToMuxedAccount: true,
      encodeMuxedAccountToAddress: true,
      extractBaseAddress: true,
      encodeMuxedAccount: true,
      Contract: true,
      Address: true
    };
    Object.defineProperty(exports, "Account", {
      enumerable: true,
      get: function get() {
        return _account.Account;
      }
    });
    Object.defineProperty(exports, "Address", {
      enumerable: true,
      get: function get() {
        return _address.Address;
      }
    });
    Object.defineProperty(exports, "Asset", {
      enumerable: true,
      get: function get() {
        return _asset.Asset;
      }
    });
    Object.defineProperty(exports, "AuthClawbackEnabledFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthClawbackEnabledFlag;
      }
    });
    Object.defineProperty(exports, "AuthImmutableFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthImmutableFlag;
      }
    });
    Object.defineProperty(exports, "AuthRequiredFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthRequiredFlag;
      }
    });
    Object.defineProperty(exports, "AuthRevocableFlag", {
      enumerable: true,
      get: function get() {
        return _operation.AuthRevocableFlag;
      }
    });
    Object.defineProperty(exports, "BASE_FEE", {
      enumerable: true,
      get: function get() {
        return _transaction_builder.BASE_FEE;
      }
    });
    Object.defineProperty(exports, "Claimant", {
      enumerable: true,
      get: function get() {
        return _claimant.Claimant;
      }
    });
    Object.defineProperty(exports, "Contract", {
      enumerable: true,
      get: function get() {
        return _contract.Contract;
      }
    });
    Object.defineProperty(exports, "FastSigning", {
      enumerable: true,
      get: function get() {
        return _signing.FastSigning;
      }
    });
    Object.defineProperty(exports, "FeeBumpTransaction", {
      enumerable: true,
      get: function get() {
        return _fee_bump_transaction.FeeBumpTransaction;
      }
    });
    Object.defineProperty(exports, "Hyper", {
      enumerable: true,
      get: function get() {
        return _jsXdr.Hyper;
      }
    });
    Object.defineProperty(exports, "Keypair", {
      enumerable: true,
      get: function get() {
        return _keypair.Keypair;
      }
    });
    Object.defineProperty(exports, "LiquidityPoolAsset", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_asset.LiquidityPoolAsset;
      }
    });
    Object.defineProperty(exports, "LiquidityPoolFeeV18", {
      enumerable: true,
      get: function get() {
        return _get_liquidity_pool_id.LiquidityPoolFeeV18;
      }
    });
    Object.defineProperty(exports, "LiquidityPoolId", {
      enumerable: true,
      get: function get() {
        return _liquidity_pool_id.LiquidityPoolId;
      }
    });
    Object.defineProperty(exports, "MuxedAccount", {
      enumerable: true,
      get: function get() {
        return _muxed_account.MuxedAccount;
      }
    });
    Object.defineProperty(exports, "Networks", {
      enumerable: true,
      get: function get() {
        return _network.Networks;
      }
    });
    Object.defineProperty(exports, "Operation", {
      enumerable: true,
      get: function get() {
        return _operation.Operation;
      }
    });
    Object.defineProperty(exports, "SignerKey", {
      enumerable: true,
      get: function get() {
        return _signerkey.SignerKey;
      }
    });
    Object.defineProperty(exports, "Soroban", {
      enumerable: true,
      get: function get() {
        return _soroban.Soroban;
      }
    });
    Object.defineProperty(exports, "StrKey", {
      enumerable: true,
      get: function get() {
        return _strkey.StrKey;
      }
    });
    Object.defineProperty(exports, "TimeoutInfinite", {
      enumerable: true,
      get: function get() {
        return _transaction_builder.TimeoutInfinite;
      }
    });
    Object.defineProperty(exports, "Transaction", {
      enumerable: true,
      get: function get() {
        return _transaction.Transaction;
      }
    });
    Object.defineProperty(exports, "TransactionBase", {
      enumerable: true,
      get: function get() {
        return _transaction_base.TransactionBase;
      }
    });
    Object.defineProperty(exports, "TransactionBuilder", {
      enumerable: true,
      get: function get() {
        return _transaction_builder.TransactionBuilder;
      }
    });
    Object.defineProperty(exports, "UnsignedHyper", {
      enumerable: true,
      get: function get() {
        return _jsXdr.UnsignedHyper;
      }
    });
    Object.defineProperty(exports, "cereal", {
      enumerable: true,
      get: function get() {
        return _jsxdr["default"];
      }
    });
    Object.defineProperty(exports, "decodeAddressToMuxedAccount", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.decodeAddressToMuxedAccount;
      }
    });
    exports["default"] = void 0;
    Object.defineProperty(exports, "encodeMuxedAccount", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.encodeMuxedAccount;
      }
    });
    Object.defineProperty(exports, "encodeMuxedAccountToAddress", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.encodeMuxedAccountToAddress;
      }
    });
    Object.defineProperty(exports, "extractBaseAddress", {
      enumerable: true,
      get: function get() {
        return _decode_encode_muxed_account.extractBaseAddress;
      }
    });
    Object.defineProperty(exports, "getLiquidityPoolId", {
      enumerable: true,
      get: function get() {
        return _get_liquidity_pool_id.getLiquidityPoolId;
      }
    });
    Object.defineProperty(exports, "hash", {
      enumerable: true,
      get: function get() {
        return _hashing.hash;
      }
    });
    Object.defineProperty(exports, "sign", {
      enumerable: true,
      get: function get() {
        return _signing.sign;
      }
    });
    Object.defineProperty(exports, "verify", {
      enumerable: true,
      get: function get() {
        return _signing.verify;
      }
    });
    Object.defineProperty(exports, "xdr", {
      enumerable: true,
      get: function get() {
        return _xdr["default"];
      }
    });
    var _xdr = _interopRequireDefault(require_xdr2());
    var _jsxdr = _interopRequireDefault(require_jsxdr());
    var _hashing = require_hashing();
    var _signing = require_signing();
    var _get_liquidity_pool_id = require_get_liquidity_pool_id();
    var _keypair = require_keypair();
    var _jsXdr = require_xdr();
    var _transaction_base = require_transaction_base();
    var _transaction = require_transaction();
    var _fee_bump_transaction = require_fee_bump_transaction();
    var _transaction_builder = require_transaction_builder();
    var _asset = require_asset();
    var _liquidity_pool_asset = require_liquidity_pool_asset();
    var _liquidity_pool_id = require_liquidity_pool_id();
    var _operation = require_operation();
    var _memo = require_memo();
    Object.keys(_memo).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _memo[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _memo[key];
        }
      });
    });
    var _account = require_account();
    var _muxed_account = require_muxed_account();
    var _claimant = require_claimant();
    var _network = require_network();
    var _strkey = require_strkey();
    var _signerkey = require_signerkey();
    var _soroban = require_soroban();
    var _decode_encode_muxed_account = require_decode_encode_muxed_account();
    var _contract = require_contract();
    var _address = require_address();
    var _numbers = require_numbers();
    Object.keys(_numbers).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _numbers[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _numbers[key];
        }
      });
    });
    var _scval = require_scval();
    Object.keys(_scval).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _scval[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _scval[key];
        }
      });
    });
    var _events = require_events();
    Object.keys(_events).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _events[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _events[key];
        }
      });
    });
    var _sorobandata_builder = require_sorobandata_builder();
    Object.keys(_sorobandata_builder).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _sorobandata_builder[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _sorobandata_builder[key];
        }
      });
    });
    var _auth = require_auth();
    Object.keys(_auth).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _auth[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _auth[key];
        }
      });
    });
    var _invocation = require_invocation();
    Object.keys(_invocation).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _invocation[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _invocation[key];
        }
      });
    });
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var _default = exports["default"] = module.exports;
  }
});

// node_modules/@stellar/stellar-sdk/lib/http-client/types.js
var require_types = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/http-client/types.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CancelToken = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var CancelToken = exports.CancelToken = function() {
      function CancelToken2(executor) {
        var _this = this;
        _classCallCheck(this, CancelToken2);
        var resolvePromise;
        this.promise = new Promise(function(resolve) {
          resolvePromise = resolve;
        });
        executor(function(reason) {
          _this.reason = reason;
          resolvePromise();
        });
      }
      return _createClass(CancelToken2, [{
        key: "throwIfRequested",
        value: function throwIfRequested() {
          if (this.reason) {
            throw new Error(this.reason);
          }
        }
      }]);
    }();
  }
});

// node_modules/axios/dist/browser/axios.cjs
var require_axios = __commonJS({
  "node_modules/axios/dist/browser/axios.cjs"(exports, module) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }
    var { toString } = Object.prototype;
    var { getPrototypeOf } = Object;
    var { iterator, toStringTag } = Symbol;
    var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
      const str = toString.call(thing);
      return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(/* @__PURE__ */ Object.create(null));
    var kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type;
    };
    var typeOfTest = (type) => (thing) => typeof thing === type;
    var { isArray } = Array;
    var isUndefined = typeOfTest("undefined");
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      let result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    var isString = typeOfTest("string");
    var isFunction = typeOfTest("function");
    var isNumber = typeOfTest("number");
    var isObject = (thing) => thing !== null && typeof thing === "object";
    var isBoolean = (thing) => thing === true || thing === false;
    var isPlainObject = (val) => {
      if (kindOf(val) !== "object") {
        return false;
      }
      const prototype2 = getPrototypeOf(val);
      return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
    };
    var isEmptyObject = (val) => {
      if (!isObject(val) || isBuffer(val)) {
        return false;
      }
      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        return false;
      }
    };
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    var isStream = (val) => isObject(val) && isFunction(val.pipe);
    var isFormData = (thing) => {
      let kind;
      return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
      kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
    };
    var isURLSearchParams = kindOfTest("URLSearchParams");
    var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
    var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    function forEach(obj, fn, { allOwnKeys = false } = {}) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      let i;
      let l;
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        if (isBuffer(obj)) {
          return;
        }
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;
        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }
    function findKey(obj, key) {
      if (isBuffer(obj)) {
        return null;
      }
      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }
    var _global = (() => {
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
    })();
    var isContextDefined = (context) => !isUndefined(context) && context !== _global;
    function merge() {
      const { caseless } = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else {
          result[targetKey] = val;
        }
      };
      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }
    var extend = (a, b, thisArg, { allOwnKeys } = {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, { allOwnKeys });
      return a;
    };
    var stripBOM = (content) => {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    };
    var inherits = (constructor, superConstructor, props, descriptors2) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, "super", {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };
    var toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};
      destObj = destObj || {};
      if (sourceObj == null) return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    };
    var endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
    var toArray = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber(i)) return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };
    var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
      return (thing) => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
    var forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];
      const _iterator = generator.call(obj);
      let result;
      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };
    var matchAll = (regExp, str) => {
      let matches;
      const arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    };
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var toCamelCase = (str) => {
      return str.toLowerCase().replace(
        /[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };
    var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
    var isRegExp = kindOfTest("RegExp");
    var reduceDescriptors = (obj, reducer) => {
      const descriptors2 = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};
      forEach(descriptors2, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });
      Object.defineProperties(obj, reducedDescriptors);
    };
    var freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
          return false;
        }
        const value = obj[name];
        if (!isFunction(value)) return;
        descriptor.enumerable = false;
        if ("writable" in descriptor) {
          descriptor.writable = false;
          return;
        }
        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error("Can not rewrite read-only method '" + name + "'");
          };
        }
      });
    };
    var toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};
      const define2 = (arr) => {
        arr.forEach((value) => {
          obj[value] = true;
        });
      };
      isArray(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
      return obj;
    };
    var noop = () => {
    };
    var toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
    }
    var toJSONObject = (obj) => {
      const stack = new Array(10);
      const visit = (source, i) => {
        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }
          if (isBuffer(source)) {
            return source;
          }
          if (!("toJSON" in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};
            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });
            stack[i] = void 0;
            return target;
          }
        }
        return source;
      };
      return visit(obj, 0);
    };
    var isAsyncFn = kindOfTest("AsyncFunction");
    var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
    var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }
      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({ source, data }) => {
          if (source === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);
        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        };
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === "function",
      isFunction(_global.postMessage)
    );
    var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
    var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isEmptyObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty,
      // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
      }
    }
    utils$1.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });
    var prototype$1 = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach((code) => {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype$1, "isAxiosError", { value: true });
    AxiosError.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);
      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, (prop) => {
        return prop !== "isAxiosError";
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    var httpAdapter = null;
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }
    function removeBrackets(key) {
      return utils$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path) return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function toFormData(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new FormData();
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils$1.isUndefined(source[option]);
      });
      const metaTokens = options.metaTokens;
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);
      if (!utils$1.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null) return "";
        if (utils$1.isDate(value)) {
          return value.toISOString();
        }
        if (utils$1.isBoolean(value)) {
          return value.toString();
        }
        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        let arr = value;
        if (value && !path && typeof value === "object") {
          if (utils$1.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils$1.isArray(value) && isFlatArray(value) || (utils$1.isFileList(value) || utils$1.endsWith(key, "[]")) && (arr = utils$1.toArray(value))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      const stack = [];
      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils$1.isUndefined(value)) return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData,
            el,
            utils$1.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils$1.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    function encode$1(str) {
      const charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString2(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      const _encode = options && options.encode || encode;
      if (utils$1.isFunction(options)) {
        options = {
          serialize: options
        };
      }
      const serializeFn = options && options.serialize;
      let serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    }
    var InterceptorManager = class {
      constructor() {
        this.handlers = [];
      }
      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }
      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }
      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }
      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    };
    var InterceptorManager$1 = InterceptorManager;
    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
    var URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
    var FormData$1 = typeof FormData !== "undefined" ? FormData : null;
    var Blob$1 = typeof Blob !== "undefined" ? Blob : null;
    var platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
    var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
    var _navigator = typeof navigator === "object" && navigator || void 0;
    var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
    var hasStandardBrowserWebWorkerEnv = (() => {
      return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
      self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
    })();
    var origin = hasBrowserEnv && window.location.href || "http://localhost";
    var utils = Object.freeze({
      __proto__: null,
      hasBrowserEnv,
      hasStandardBrowserWebWorkerEnv,
      hasStandardBrowserEnv,
      navigator: _navigator,
      origin
    });
    var platform = {
      ...utils,
      ...platform$1
    };
    function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), {
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        },
        ...options
      });
    }
    function parsePropPath(name) {
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];
        if (name === "__proto__") return true;
        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }
        const result = buildPath(path, value, target[name], index);
        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};
        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: ["xhr", "http", "fetch"],
      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || "";
        const hasJSONContentType = contentType.indexOf("application/json") > -1;
        const isObjectPayload = utils$1.isObject(data);
        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }
        const isFormData2 = utils$1.isFormData(data);
        if (isFormData2) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils$1.isArrayBuffer(data) || utils$1.isBuffer(data) || utils$1.isStream(data) || utils$1.isFile(data) || utils$1.isBlob(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
          return data.toString();
        }
        let isFileList2;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList2 = utils$1.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            const _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList2 ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          headers.setContentType("application/json", false);
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === "json";
        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }
        if (data && utils$1.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*",
          "Content-Type": void 0
        }
      }
    };
    utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
      defaults.headers[method] = {};
    });
    var defaults$1 = defaults;
    var ignoreDuplicateOf = utils$1.toObjectSet([
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ]);
    var parseHeaders = (rawHeaders) => {
      const parsed = {};
      let key;
      let val;
      let i;
      rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
        i = line.indexOf(":");
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();
        if (!key || parsed[key] && ignoreDuplicateOf[key]) {
          return;
        }
        if (key === "set-cookie") {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
        }
      });
      return parsed;
    };
    var $internals = Symbol("internals");
    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }
    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }
      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }
    function parseTokens(str) {
      const tokens = /* @__PURE__ */ Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;
      while (match = tokensRE.exec(str)) {
        tokens[match[1]] = match[2];
      }
      return tokens;
    }
    var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }
      if (isHeaderNameFilter) {
        value = header;
      }
      if (!utils$1.isString(value)) return;
      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }
      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }
    function formatHeader(header) {
      return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
        return char.toUpperCase() + str;
      });
    }
    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(" " + header);
      ["get", "set", "has"].forEach((methodName) => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }
    var AxiosHeaders = class {
      constructor(headers) {
        headers && this.set(headers);
      }
      set(header, valueOrRewrite, rewrite) {
        const self2 = this;
        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);
          if (!lHeader) {
            throw new Error("header name must be a non-empty string");
          }
          const key = utils$1.findKey(self2, lHeader);
          if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
            self2[key || _header] = normalizeValue(_value);
          }
        }
        const setHeaders = (headers, _rewrite) => utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if (utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
          let obj = {}, dest, key;
          for (const entry of header) {
            if (!utils$1.isArray(entry)) {
              throw TypeError("Object iterator must return a key-value pair");
            }
            obj[key = entry[0]] = (dest = obj[key]) ? utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
          }
          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }
        return this;
      }
      get(header, parser) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          if (key) {
            const value = this[key];
            if (!parser) {
              return value;
            }
            if (parser === true) {
              return parseTokens(value);
            }
            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }
            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }
            throw new TypeError("parser must be boolean|regexp|function");
          }
        }
      }
      has(header, matcher) {
        header = normalizeHeader(header);
        if (header) {
          const key = utils$1.findKey(this, header);
          return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }
        return false;
      }
      delete(header, matcher) {
        const self2 = this;
        let deleted = false;
        function deleteHeader(_header) {
          _header = normalizeHeader(_header);
          if (_header) {
            const key = utils$1.findKey(self2, _header);
            if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
              delete self2[key];
              deleted = true;
            }
          }
        }
        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }
        return deleted;
      }
      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;
        while (i--) {
          const key = keys[i];
          if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }
        return deleted;
      }
      normalize(format) {
        const self2 = this;
        const headers = {};
        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);
          if (key) {
            self2[key] = normalizeValue(value);
            delete self2[header];
            return;
          }
          const normalized = format ? formatHeader(header) : String(header).trim();
          if (normalized !== header) {
            delete self2[header];
          }
          self2[normalized] = normalizeValue(value);
          headers[normalized] = true;
        });
        return this;
      }
      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }
      toJSON(asStrings) {
        const obj = /* @__PURE__ */ Object.create(null);
        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(", ") : value);
        });
        return obj;
      }
      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }
      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
      }
      getSetCookie() {
        return this.get("set-cookie") || [];
      }
      get [Symbol.toStringTag]() {
        return "AxiosHeaders";
      }
      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }
      static concat(first, ...targets) {
        const computed = new this(first);
        targets.forEach((target) => computed.set(target));
        return computed;
      }
      static accessor(header) {
        const internals = this[$internals] = this[$internals] = {
          accessors: {}
        };
        const accessors = internals.accessors;
        const prototype2 = this.prototype;
        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);
          if (!accessors[lHeader]) {
            buildAccessors(prototype2, _header);
            accessors[lHeader] = true;
          }
        }
        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
        return this;
      }
    };
    AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
    utils$1.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1);
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      };
    });
    utils$1.freezeMethods(AxiosHeaders);
    var AxiosHeaders$1 = AxiosHeaders;
    function transformData(fns, response) {
      const config = this || defaults$1;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;
      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
      });
      headers.normalize();
      return data;
    }
    function isCancel(value) {
      return !!(value && value.__CANCEL__);
    }
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils$1.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }
    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    }
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;
      min = min !== void 0 ? min : 1e3;
      return function push(chunkLength) {
        const now = Date.now();
        const startedAt = timestamps[tail];
        if (!firstSampleTS) {
          firstSampleTS = now;
        }
        bytes[head] = chunkLength;
        timestamps[head] = now;
        let i = tail;
        let bytesCount = 0;
        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }
        head = (head + 1) % samplesCount;
        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }
        if (now - firstSampleTS < min) {
          return;
        }
        const passed = startedAt && now - startedAt;
        return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
      };
    }
    function throttle(fn, freq) {
      let timestamp = 0;
      let threshold = 1e3 / freq;
      let lastArgs;
      let timer;
      const invoke = (args, now = Date.now()) => {
        timestamp = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn(...args);
      };
      const throttled = (...args) => {
        const now = Date.now();
        const passed = now - timestamp;
        if (passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };
      const flush = () => lastArgs && invoke(lastArgs);
      return [throttled, flush];
    }
    var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);
      return throttle((e) => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : void 0;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;
        bytesNotified = loaded;
        const data = {
          loaded,
          total,
          progress: total ? loaded / total : void 0,
          bytes: progressBytes,
          rate: rate ? rate : void 0,
          estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? "download" : "upload"]: true
        };
        listener(data);
      }, freq);
    };
    var progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;
      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };
    var asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));
    var isURLSameOrigin = platform.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
      url = new URL(url, platform.origin);
      return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;
    var cookies = platform.hasStandardBrowserEnv ? (
      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure) {
          const cookie = [name + "=" + encodeURIComponent(value)];
          utils$1.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
          utils$1.isString(path) && cookie.push("path=" + path);
          utils$1.isString(domain) && cookie.push("domain=" + domain);
          secure === true && cookie.push("secure");
          document.cookie = cookie.join("; ");
        },
        read(name) {
          const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      }
    ) : (
      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {
        },
        read() {
          return null;
        },
        remove() {
        }
      }
    );
    function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }
    function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    }
    function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
      let isRelativeUrl = !isAbsoluteURL(requestedURL);
      if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }
    var headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
    function mergeConfig(config1, config2) {
      config2 = config2 || {};
      const config = {};
      function getMergedValue(target, source, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({ caseless }, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(a, b, prop, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, prop, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a, prop, caseless);
        }
      }
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        }
      }
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(void 0, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(void 0, a);
        }
      }
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(void 0, a);
        }
      }
      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
      };
      utils$1.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
        const merge2 = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge2(config1[prop], config2[prop], prop);
        utils$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    }
    var resolveConfig = (config) => {
      const newConfig = mergeConfig({}, config);
      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
      newConfig.headers = headers = AxiosHeaders$1.from(headers);
      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
      if (auth) {
        headers.set(
          "Authorization",
          "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
        );
      }
      let contentType;
      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(void 0);
        } else if ((contentType = headers.getContentType()) !== false) {
          const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
          headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
        }
      }
      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
        if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }
      return newConfig;
    };
    var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
    var xhrAdapter = isXHRAdapterSupported && function(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig(config);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let { responseType, onUploadProgress, onDownloadProgress } = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;
        function done() {
          flushUpload && flushUpload();
          flushDownload && flushDownload();
          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
          _config.signal && _config.signal.removeEventListener("abort", onCanceled);
        }
        let request = new XMLHttpRequest();
        request.open(_config.method.toUpperCase(), _config.url, true);
        request.timeout = _config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          const responseHeaders = AxiosHeaders$1.from(
            "getAllResponseHeaders" in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        requestData === void 0 && requestHeaders.setContentType(null);
        if ("setRequestHeader" in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = _config.responseType;
        }
        if (onDownloadProgress) {
          [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
          request.addEventListener("progress", downloadThrottled);
        }
        if (onUploadProgress && request.upload) {
          [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
          request.upload.addEventListener("progress", uploadThrottled);
          request.upload.addEventListener("loadend", flushUpload);
        }
        if (_config.cancelToken || _config.signal) {
          onCanceled = (cancel) => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
          }
        }
        const protocol = parseProtocol(_config.url);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData || null);
      });
    };
    var composeSignals = (signals, timeout) => {
      const { length } = signals = signals ? signals.filter(Boolean) : [];
      if (timeout || length) {
        let controller = new AbortController();
        let aborted;
        const onabort = function(reason) {
          if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
          }
        };
        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
        }, timeout);
        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach((signal2) => {
              signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
            });
            signals = null;
          }
        };
        signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
        const { signal } = controller;
        signal.unsubscribe = () => utils$1.asap(unsubscribe);
        return signal;
      }
    };
    var composeSignals$1 = composeSignals;
    var streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;
      if (!chunkSize || len < chunkSize) {
        yield chunk;
        return;
      }
      let pos = 0;
      let end;
      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };
    var readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };
    var readStream = async function* (stream) {
      if (stream[Symbol.asyncIterator]) {
        yield* stream;
        return;
      }
      const reader = stream.getReader();
      try {
        for (; ; ) {
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };
    var trackStream = (stream, chunkSize, onProgress, onFinish) => {
      const iterator2 = readBytes(stream, chunkSize);
      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };
      return new ReadableStream({
        async pull(controller) {
          try {
            const { done: done2, value } = await iterator2.next();
            if (done2) {
              _onFinish();
              controller.close();
              return;
            }
            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator2.return();
        }
      }, {
        highWaterMark: 2
      });
    };
    var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
    var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
    var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
    var test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false;
      }
    };
    var supportsRequestStream = isReadableStreamSupported && test(() => {
      let duplexAccessed = false;
      const hasContentType = new Request(platform.origin, {
        body: new ReadableStream(),
        method: "POST",
        get duplex() {
          duplexAccessed = true;
          return "half";
        }
      }).headers.has("Content-Type");
      return duplexAccessed && !hasContentType;
    });
    var DEFAULT_CHUNK_SIZE = 64 * 1024;
    var supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body));
    var resolvers = {
      stream: supportsResponseStream && ((res) => res.body)
    };
    isFetchSupported && ((res) => {
      ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
        !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res2) => res2[type]() : (_, config) => {
          throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
        });
      });
    })(new Response());
    var getBodyLength = async (body) => {
      if (body == null) {
        return 0;
      }
      if (utils$1.isBlob(body)) {
        return body.size;
      }
      if (utils$1.isSpecCompliantForm(body)) {
        const _request = new Request(platform.origin, {
          method: "POST",
          body
        });
        return (await _request.arrayBuffer()).byteLength;
      }
      if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
        return body.byteLength;
      }
      if (utils$1.isURLSearchParams(body)) {
        body = body + "";
      }
      if (utils$1.isString(body)) {
        return (await encodeText(body)).byteLength;
      }
    };
    var resolveBodyLength = async (headers, body) => {
      const length = utils$1.toFiniteNumber(headers.getContentLength());
      return length == null ? getBodyLength(body) : length;
    };
    var fetchAdapter = isFetchSupported && (async (config) => {
      let {
        url,
        method,
        data,
        signal,
        cancelToken,
        timeout,
        onDownloadProgress,
        onUploadProgress,
        responseType,
        headers,
        withCredentials = "same-origin",
        fetchOptions
      } = resolveConfig(config);
      responseType = responseType ? (responseType + "").toLowerCase() : "text";
      let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
      let request;
      const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
        composedSignal.unsubscribe();
      });
      let requestContentLength;
      try {
        if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
          let _request = new Request(url, {
            method: "POST",
            body: data,
            duplex: "half"
          });
          let contentTypeHeader;
          if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
            headers.setContentType(contentTypeHeader);
          }
          if (_request.body) {
            const [onProgress, flush] = progressEventDecorator(
              requestContentLength,
              progressEventReducer(asyncDecorator(onUploadProgress))
            );
            data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
          }
        }
        if (!utils$1.isString(withCredentials)) {
          withCredentials = withCredentials ? "include" : "omit";
        }
        const isCredentialsSupported = "credentials" in Request.prototype;
        request = new Request(url, {
          ...fetchOptions,
          signal: composedSignal,
          method: method.toUpperCase(),
          headers: headers.normalize().toJSON(),
          body: data,
          duplex: "half",
          credentials: isCredentialsSupported ? withCredentials : void 0
        });
        let response = await fetch(request, fetchOptions);
        const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
        if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
          const options = {};
          ["status", "statusText", "headers"].forEach((prop) => {
            options[prop] = response[prop];
          });
          const responseContentLength = utils$1.toFiniteNumber(response.headers.get("content-length"));
          const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
            responseContentLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true)
          ) || [];
          response = new Response(
            trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
              flush && flush();
              unsubscribe && unsubscribe();
            }),
            options
          );
        }
        responseType = responseType || "text";
        let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || "text"](response, config);
        !isStreamResponse && unsubscribe && unsubscribe();
        return await new Promise((resolve, reject) => {
          settle(resolve, reject, {
            data: responseData,
            headers: AxiosHeaders$1.from(response.headers),
            status: response.status,
            statusText: response.statusText,
            config,
            request
          });
        });
      } catch (err) {
        unsubscribe && unsubscribe();
        if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
          throw Object.assign(
            new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request),
            {
              cause: err.cause || err
            }
          );
        }
        throw AxiosError.from(err, err && err.code, config, request);
      }
    });
    var knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: fetchAdapter
    };
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, "name", { value });
        } catch (e) {
        }
        Object.defineProperty(fn, "adapterName", { value });
      }
    });
    var renderReason = (reason) => `- ${reason}`;
    var isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;
    var adapters = {
      getAdapter: (adapters2) => {
        adapters2 = utils$1.isArray(adapters2) ? adapters2 : [adapters2];
        const { length } = adapters2;
        let nameOrAdapter;
        let adapter;
        const rejectedReasons = {};
        for (let i = 0; i < length; i++) {
          nameOrAdapter = adapters2[i];
          let id;
          adapter = nameOrAdapter;
          if (!isResolvedHandle(nameOrAdapter)) {
            adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
            if (adapter === void 0) {
              throw new AxiosError(`Unknown adapter '${id}'`);
            }
          }
          if (adapter) {
            break;
          }
          rejectedReasons[id || "#" + i] = adapter;
        }
        if (!adapter) {
          const reasons = Object.entries(rejectedReasons).map(
            ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
          );
          let s = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
          throw new AxiosError(
            `There is no suitable adapter to dispatch the request ` + s,
            "ERR_NOT_SUPPORT"
          );
        }
        return adapter;
      },
      adapters: knownAdapters
    };
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError(null, config);
      }
    }
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = AxiosHeaders$1.from(config.headers);
      config.data = transformData.call(
        config,
        config.transformRequest
      );
      if (["post", "put", "patch"].indexOf(config.method) !== -1) {
        config.headers.setContentType("application/x-www-form-urlencoded", false);
      }
      const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );
        response.headers = AxiosHeaders$1.from(response.headers);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }
        return Promise.reject(reason);
      });
    }
    var VERSION = "1.11.0";
    var validators$1 = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i) => {
      validators$1[type] = function validator2(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators$1.transitional = function transitional(validator2, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return (value, opt, opts) => {
        if (validator2 === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator2 ? validator2(value, opt, opts) : true;
      };
    };
    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator2 = schema[opt];
        if (validator2) {
          const value = options[opt];
          const result = value === void 0 || validator2(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    var validator = {
      assertOptions,
      validators: validators$1
    };
    var validators = validator.validators;
    var Axios = class {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager$1(),
          response: new InterceptorManager$1()
        };
      }
      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};
            Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
            try {
              if (!err.stack) {
                err.stack = stack;
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
                err.stack += "\n" + stack;
              }
            } catch (e) {
            }
          }
          throw err;
        }
      }
      _request(configOrUrl, config) {
        if (typeof configOrUrl === "string") {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }
        config = mergeConfig(this.defaults, config);
        const { transitional, paramsSerializer, headers } = config;
        if (transitional !== void 0) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }
        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }
        if (config.allowAbsoluteUrls !== void 0) ;
        else if (this.defaults.allowAbsoluteUrls !== void 0) {
          config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config.allowAbsoluteUrls = true;
        }
        validator.assertOptions(config, {
          baseUrl: validators.spelling("baseURL"),
          withXsrfToken: validators.spelling("withXSRFToken")
        }, true);
        config.method = (config.method || this.defaults.method || "get").toLowerCase();
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );
        headers && utils$1.forEach(
          ["delete", "get", "head", "post", "put", "patch", "common"],
          (method) => {
            delete headers[method];
          }
        );
        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
            return;
          }
          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });
        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });
        let promise;
        let i = 0;
        let len;
        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), void 0];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;
          promise = Promise.resolve(config);
          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }
          return promise;
        }
        len = requestInterceptorChain.length;
        let newConfig = config;
        i = 0;
        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }
        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }
        i = 0;
        len = responseInterceptorChain.length;
        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }
        return promise;
      }
      getUri(config) {
        config = mergeConfig(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };
    utils$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    var Axios$1 = Axios;
    var CancelToken = class _CancelToken {
      constructor(executor) {
        if (typeof executor !== "function") {
          throw new TypeError("executor must be a function.");
        }
        let resolvePromise;
        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });
        const token = this;
        this.promise.then((cancel) => {
          if (!token._listeners) return;
          let i = token._listeners.length;
          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });
        this.promise.then = (onfulfilled) => {
          let _resolve;
          const promise = new Promise((resolve) => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);
          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };
          return promise;
        };
        executor(function cancel(message, config, request) {
          if (token.reason) {
            return;
          }
          token.reason = new CanceledError(message, config, request);
          resolvePromise(token.reason);
        });
      }
      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }
      /**
       * Subscribe to the cancel signal
       */
      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }
        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }
      /**
       * Unsubscribe from the cancel signal
       */
      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }
      toAbortSignal() {
        const controller = new AbortController();
        const abort = (err) => {
          controller.abort(err);
        };
        this.subscribe(abort);
        controller.signal.unsubscribe = () => this.unsubscribe(abort);
        return controller.signal;
      }
      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new _CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };
    var CancelToken$1 = CancelToken;
    function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }
    function isAxiosError(payload) {
      return utils$1.isObject(payload) && payload.isAxiosError === true;
    }
    var HttpStatusCode = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511
    };
    Object.entries(HttpStatusCode).forEach(([key, value]) => {
      HttpStatusCode[value] = key;
    });
    var HttpStatusCode$1 = HttpStatusCode;
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);
      utils$1.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
      utils$1.extend(instance, context, null, { allOwnKeys: true });
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios = createInstance(defaults$1);
    axios.Axios = Axios$1;
    axios.CanceledError = CanceledError;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel;
    axios.VERSION = VERSION;
    axios.toFormData = toFormData;
    axios.AxiosError = AxiosError;
    axios.Cancel = axios.CanceledError;
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;
    axios.isAxiosError = isAxiosError;
    axios.mergeConfig = mergeConfig;
    axios.AxiosHeaders = AxiosHeaders$1;
    axios.formToJSON = (thing) => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);
    axios.getAdapter = adapters.getAdapter;
    axios.HttpStatusCode = HttpStatusCode$1;
    axios.default = axios;
    module.exports = axios;
  }
});

// node_modules/@stellar/stellar-sdk/lib/http-client/axios-client.js
var require_axios_client = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/http-client/axios-client.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.create = exports.axiosClient = void 0;
    var _axios = _interopRequireDefault(require_axios());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var axiosClient = exports.axiosClient = _axios.default;
    var create = exports.create = _axios.default.create;
  }
});

// node_modules/@stellar/stellar-sdk/lib/http-client/index.js
var require_http_client = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/http-client/index.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      httpClient: true,
      create: true
    };
    exports.httpClient = exports.create = void 0;
    var _types = require_types();
    Object.keys(_types).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _types[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _types[key];
        }
      });
    });
    var httpClient;
    var create;
    if (true) {
      axiosModule = require_axios_client();
      exports.httpClient = httpClient = axiosModule.axiosClient;
      exports.create = create = axiosModule.create;
    } else {
      fetchModule = null;
      exports.httpClient = httpClient = fetchModule.fetchClient;
      exports.create = create = fetchModule.create;
    }
    var axiosModule;
    var fetchModule;
  }
});

// node_modules/@stellar/stellar-sdk/lib/rpc/axios.js
var require_axios2 = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/rpc/axios.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.version = exports.default = exports.AxiosClient = void 0;
    var _httpClient = require_http_client();
    var version = exports.version = "13.3.0";
    var AxiosClient = exports.AxiosClient = (0, _httpClient.create)({
      headers: {
        "X-Client-Name": "js-soroban-client",
        "X-Client-Version": version
      }
    });
    var _default = exports.default = AxiosClient;
  }
});

// node_modules/@stellar/stellar-sdk/lib/rpc/jsonrpc.js
var require_jsonrpc = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/rpc/jsonrpc.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.postObject = postObject;
    var _axios = _interopRequireDefault(require_axios2());
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function hasOwnProperty(obj, prop) {
      return obj.hasOwnProperty(prop);
    }
    function postObject(_x, _x2) {
      return _postObject.apply(this, arguments);
    }
    function _postObject() {
      _postObject = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(url, method) {
        var param, response, _response$data, _args = arguments;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              param = _args.length > 2 && _args[2] !== void 0 ? _args[2] : null;
              _context.next = 3;
              return _axios.default.post(url, {
                jsonrpc: "2.0",
                id: 1,
                method,
                params: param
              });
            case 3:
              response = _context.sent;
              if (!hasOwnProperty(response.data, "error")) {
                _context.next = 8;
                break;
              }
              throw response.data.error;
            case 8:
              return _context.abrupt("return", (_response$data = response.data) === null || _response$data === void 0 ? void 0 : _response$data.result);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _postObject.apply(this, arguments);
    }
  }
});

// node_modules/@stellar/stellar-sdk/lib/rpc/parsers.js
var require_parsers = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/rpc/parsers.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.parseRawEvents = parseRawEvents;
    exports.parseRawLedgerEntries = parseRawLedgerEntries;
    exports.parseRawSendTransaction = parseRawSendTransaction;
    exports.parseRawSimulation = parseRawSimulation;
    exports.parseRawTransactions = parseRawTransactions;
    exports.parseTransactionInfo = parseTransactionInfo;
    var _stellarBase = require_lib();
    var _api = require_api();
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function parseRawSendTransaction(raw) {
      var errorResultXdr = raw.errorResultXdr, diagnosticEventsXdr = raw.diagnosticEventsXdr;
      delete raw.errorResultXdr;
      delete raw.diagnosticEventsXdr;
      if (errorResultXdr) {
        return _objectSpread(_objectSpread(_objectSpread({}, raw), diagnosticEventsXdr !== void 0 && diagnosticEventsXdr.length > 0 && {
          diagnosticEvents: diagnosticEventsXdr.map(function(evt) {
            return _stellarBase.xdr.DiagnosticEvent.fromXDR(evt, "base64");
          })
        }), {}, {
          errorResult: _stellarBase.xdr.TransactionResult.fromXDR(errorResultXdr, "base64")
        });
      }
      return _objectSpread({}, raw);
    }
    function parseTransactionInfo(raw) {
      var meta = _stellarBase.xdr.TransactionMeta.fromXDR(raw.resultMetaXdr, "base64");
      var info = {
        ledger: raw.ledger,
        createdAt: raw.createdAt,
        applicationOrder: raw.applicationOrder,
        feeBump: raw.feeBump,
        envelopeXdr: _stellarBase.xdr.TransactionEnvelope.fromXDR(raw.envelopeXdr, "base64"),
        resultXdr: _stellarBase.xdr.TransactionResult.fromXDR(raw.resultXdr, "base64"),
        resultMetaXdr: meta
      };
      if (meta.switch() === 3 && meta.v3().sorobanMeta() !== null) {
        var _meta$v3$sorobanMeta;
        info.returnValue = (_meta$v3$sorobanMeta = meta.v3().sorobanMeta()) === null || _meta$v3$sorobanMeta === void 0 ? void 0 : _meta$v3$sorobanMeta.returnValue();
      }
      if ("diagnosticEventsXdr" in raw && raw.diagnosticEventsXdr) {
        info.diagnosticEventsXdr = raw.diagnosticEventsXdr.map(function(diagnosticEvent) {
          return _stellarBase.xdr.DiagnosticEvent.fromXDR(diagnosticEvent, "base64");
        });
      }
      return info;
    }
    function parseRawTransactions(r) {
      return _objectSpread({
        status: r.status,
        txHash: r.txHash
      }, parseTransactionInfo(r));
    }
    function parseRawEvents(raw) {
      var _raw$events;
      return {
        latestLedger: raw.latestLedger,
        cursor: raw.cursor,
        events: ((_raw$events = raw.events) !== null && _raw$events !== void 0 ? _raw$events : []).map(function(evt) {
          var clone = _objectSpread({}, evt);
          delete clone.contractId;
          return _objectSpread(_objectSpread(_objectSpread({}, clone), evt.contractId !== "" && {
            contractId: new _stellarBase.Contract(evt.contractId)
          }), {}, {
            topic: evt.topic.map(function(topic) {
              return _stellarBase.xdr.ScVal.fromXDR(topic, "base64");
            }),
            value: _stellarBase.xdr.ScVal.fromXDR(evt.value, "base64")
          });
        })
      };
    }
    function parseRawLedgerEntries(raw) {
      var _raw$entries;
      return {
        latestLedger: raw.latestLedger,
        entries: ((_raw$entries = raw.entries) !== null && _raw$entries !== void 0 ? _raw$entries : []).map(function(rawEntry) {
          if (!rawEntry.key || !rawEntry.xdr) {
            throw new TypeError("invalid ledger entry: ".concat(JSON.stringify(rawEntry)));
          }
          return _objectSpread({
            lastModifiedLedgerSeq: rawEntry.lastModifiedLedgerSeq,
            key: _stellarBase.xdr.LedgerKey.fromXDR(rawEntry.key, "base64"),
            val: _stellarBase.xdr.LedgerEntryData.fromXDR(rawEntry.xdr, "base64")
          }, rawEntry.liveUntilLedgerSeq !== void 0 && {
            liveUntilLedgerSeq: rawEntry.liveUntilLedgerSeq
          });
        })
      };
    }
    function parseSuccessful(sim, partial) {
      var _sim$results$length, _sim$results, _sim$stateChanges$len, _sim$stateChanges, _sim$stateChanges2;
      var success = _objectSpread(_objectSpread(_objectSpread({}, partial), {}, {
        transactionData: new _stellarBase.SorobanDataBuilder(sim.transactionData),
        minResourceFee: sim.minResourceFee
      }, ((_sim$results$length = (_sim$results = sim.results) === null || _sim$results === void 0 ? void 0 : _sim$results.length) !== null && _sim$results$length !== void 0 ? _sim$results$length : 0 > 0) && {
        result: sim.results.map(function(row) {
          var _row$auth;
          return {
            auth: ((_row$auth = row.auth) !== null && _row$auth !== void 0 ? _row$auth : []).map(function(entry) {
              return _stellarBase.xdr.SorobanAuthorizationEntry.fromXDR(entry, "base64");
            }),
            retval: row.xdr ? _stellarBase.xdr.ScVal.fromXDR(row.xdr, "base64") : _stellarBase.xdr.ScVal.scvVoid()
          };
        })[0]
      }), ((_sim$stateChanges$len = (_sim$stateChanges = sim.stateChanges) === null || _sim$stateChanges === void 0 ? void 0 : _sim$stateChanges.length) !== null && _sim$stateChanges$len !== void 0 ? _sim$stateChanges$len : 0 > 0) && {
        stateChanges: (_sim$stateChanges2 = sim.stateChanges) === null || _sim$stateChanges2 === void 0 ? void 0 : _sim$stateChanges2.map(function(entryChange) {
          return {
            type: entryChange.type,
            key: _stellarBase.xdr.LedgerKey.fromXDR(entryChange.key, "base64"),
            before: entryChange.before ? _stellarBase.xdr.LedgerEntry.fromXDR(entryChange.before, "base64") : null,
            after: entryChange.after ? _stellarBase.xdr.LedgerEntry.fromXDR(entryChange.after, "base64") : null
          };
        })
      });
      if (!sim.restorePreamble || sim.restorePreamble.transactionData === "") {
        return success;
      }
      return _objectSpread(_objectSpread({}, success), {}, {
        restorePreamble: {
          minResourceFee: sim.restorePreamble.minResourceFee,
          transactionData: new _stellarBase.SorobanDataBuilder(sim.restorePreamble.transactionData)
        }
      });
    }
    function parseRawSimulation(sim) {
      var _sim$events$map, _sim$events;
      var looksRaw = _api.Api.isSimulationRaw(sim);
      if (!looksRaw) {
        return sim;
      }
      var base = {
        _parsed: true,
        id: sim.id,
        latestLedger: sim.latestLedger,
        events: (_sim$events$map = (_sim$events = sim.events) === null || _sim$events === void 0 ? void 0 : _sim$events.map(function(evt) {
          return _stellarBase.xdr.DiagnosticEvent.fromXDR(evt, "base64");
        })) !== null && _sim$events$map !== void 0 ? _sim$events$map : []
      };
      if (typeof sim.error === "string") {
        return _objectSpread(_objectSpread({}, base), {}, {
          error: sim.error
        });
      }
      return parseSuccessful(sim, base);
    }
  }
});

// node_modules/@stellar/stellar-sdk/lib/rpc/transaction.js
var require_transaction2 = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/rpc/transaction.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.assembleTransaction = assembleTransaction;
    var _stellarBase = require_lib();
    var _api = require_api();
    var _parsers = require_parsers();
    function isSorobanTransaction(tx) {
      if (tx.operations.length !== 1) {
        return false;
      }
      switch (tx.operations[0].type) {
        case "invokeHostFunction":
        case "extendFootprintTtl":
        case "restoreFootprint":
          return true;
        default:
          return false;
      }
    }
    function assembleTransaction(raw, simulation) {
      if ("innerTransaction" in raw) {
        return assembleTransaction(raw.innerTransaction, simulation);
      }
      if (!isSorobanTransaction(raw)) {
        throw new TypeError("unsupported transaction: must contain exactly one invokeHostFunction, extendFootprintTtl, or restoreFootprint operation");
      }
      var success = (0, _parsers.parseRawSimulation)(simulation);
      if (!_api.Api.isSimulationSuccess(success)) {
        throw new Error("simulation incorrect: ".concat(JSON.stringify(success)));
      }
      var classicFeeNum = parseInt(raw.fee) || 0;
      var minResourceFeeNum = parseInt(success.minResourceFee) || 0;
      var txnBuilder = _stellarBase.TransactionBuilder.cloneFrom(raw, {
        fee: (classicFeeNum + minResourceFeeNum).toString(),
        sorobanData: success.transactionData.build(),
        networkPassphrase: raw.networkPassphrase
      });
      if (raw.operations[0].type === "invokeHostFunction") {
        var _invokeOp$auth;
        txnBuilder.clearOperations();
        var invokeOp = raw.operations[0];
        var existingAuth = (_invokeOp$auth = invokeOp.auth) !== null && _invokeOp$auth !== void 0 ? _invokeOp$auth : [];
        txnBuilder.addOperation(_stellarBase.Operation.invokeHostFunction({
          source: invokeOp.source,
          func: invokeOp.func,
          auth: existingAuth.length > 0 ? existingAuth : success.result.auth
        }));
      }
      return txnBuilder;
    }
  }
});

// node_modules/@stellar/stellar-sdk/lib/utils.js
var require_utils = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/utils.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Utils = void 0;
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var Utils = exports.Utils = function() {
      function Utils2() {
        _classCallCheck(this, Utils2);
      }
      return _createClass(Utils2, null, [{
        key: "validateTimebounds",
        value: function validateTimebounds(transaction) {
          var gracePeriod = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
          if (!transaction.timeBounds) {
            return false;
          }
          var now = Math.floor(Date.now() / 1e3);
          var _transaction$timeBoun = transaction.timeBounds, minTime = _transaction$timeBoun.minTime, maxTime = _transaction$timeBoun.maxTime;
          return now >= Number.parseInt(minTime, 10) - gracePeriod && now <= Number.parseInt(maxTime, 10) + gracePeriod;
        }
      }, {
        key: "sleep",
        value: function sleep(ms) {
          return new Promise(function(resolve) {
            return setTimeout(resolve, ms);
          });
        }
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/lib/rpc/server.js
var require_server = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/rpc/server.js"(exports) {
    "use strict";
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SUBMIT_TRANSACTION_TIMEOUT = exports.RpcServer = exports.LinearSleepStrategy = exports.Durability = exports.BasicSleepStrategy = void 0;
    var _urijs = _interopRequireDefault(require_URI());
    var _stellarBase = require_lib();
    var _axios = _interopRequireDefault(require_axios2());
    var jsonrpc = _interopRequireWildcard(require_jsonrpc());
    var _api = require_api();
    var _transaction = require_transaction2();
    var _parsers = require_parsers();
    var _utils = require_utils();
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n.default = e, t && t.set(e, n), n;
    }
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function _typeof(o) {
      "@babel/helpers - typeof";
      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof(o);
    }
    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
          _defineProperty(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty(e, r, t) {
      return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _regeneratorRuntime() {
      "use strict";
      _regeneratorRuntime = function _regeneratorRuntime2() {
        return e;
      };
      var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function(t2, e2, r2) {
        t2[e2] = r2.value;
      }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag";
      function define2(t2, e2, r2) {
        return Object.defineProperty(t2, e2, { value: r2, enumerable: true, configurable: true, writable: true }), t2[e2];
      }
      try {
        define2({}, "");
      } catch (t2) {
        define2 = function define3(t3, e2, r2) {
          return t3[e2] = r2;
        };
      }
      function wrap(t2, e2, r2, n2) {
        var i2 = e2 && e2.prototype instanceof Generator ? e2 : Generator, a2 = Object.create(i2.prototype), c2 = new Context(n2 || []);
        return o(a2, "_invoke", { value: makeInvokeMethod(t2, r2, c2) }), a2;
      }
      function tryCatch(t2, e2, r2) {
        try {
          return { type: "normal", arg: t2.call(e2, r2) };
        } catch (t3) {
          return { type: "throw", arg: t3 };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var p = {};
      define2(p, a, function() {
        return this;
      });
      var d = Object.getPrototypeOf, v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t2) {
        ["next", "throw", "return"].forEach(function(e2) {
          define2(t2, e2, function(t3) {
            return this._invoke(e2, t3);
          });
        });
      }
      function AsyncIterator(t2, e2) {
        function invoke(r3, o2, i2, a2) {
          var c2 = tryCatch(t2[r3], t2, o2);
          if ("throw" !== c2.type) {
            var u2 = c2.arg, h2 = u2.value;
            return h2 && "object" == _typeof(h2) && n.call(h2, "__await") ? e2.resolve(h2.__await).then(function(t3) {
              invoke("next", t3, i2, a2);
            }, function(t3) {
              invoke("throw", t3, i2, a2);
            }) : e2.resolve(h2).then(function(t3) {
              u2.value = t3, i2(u2);
            }, function(t3) {
              return invoke("throw", t3, i2, a2);
            });
          }
          a2(c2.arg);
        }
        var r2;
        o(this, "_invoke", { value: function value(t3, n2) {
          function callInvokeWithMethodAndArg() {
            return new e2(function(e3, r3) {
              invoke(t3, n2, e3, r3);
            });
          }
          return r2 = r2 ? r2.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        } });
      }
      function makeInvokeMethod(e2, r2, n2) {
        var o2 = h;
        return function(i2, a2) {
          if (o2 === f) throw Error("Generator is already running");
          if (o2 === s) {
            if ("throw" === i2) throw a2;
            return { value: t, done: true };
          }
          for (n2.method = i2, n2.arg = a2; ; ) {
            var c2 = n2.delegate;
            if (c2) {
              var u2 = maybeInvokeDelegate(c2, n2);
              if (u2) {
                if (u2 === y) continue;
                return u2;
              }
            }
            if ("next" === n2.method) n2.sent = n2._sent = n2.arg;
            else if ("throw" === n2.method) {
              if (o2 === h) throw o2 = s, n2.arg;
              n2.dispatchException(n2.arg);
            } else "return" === n2.method && n2.abrupt("return", n2.arg);
            o2 = f;
            var p2 = tryCatch(e2, r2, n2);
            if ("normal" === p2.type) {
              if (o2 = n2.done ? s : l, p2.arg === y) continue;
              return { value: p2.arg, done: n2.done };
            }
            "throw" === p2.type && (o2 = s, n2.method = "throw", n2.arg = p2.arg);
          }
        };
      }
      function maybeInvokeDelegate(e2, r2) {
        var n2 = r2.method, o2 = e2.iterator[n2];
        if (o2 === t) return r2.delegate = null, "throw" === n2 && e2.iterator.return && (r2.method = "return", r2.arg = t, maybeInvokeDelegate(e2, r2), "throw" === r2.method) || "return" !== n2 && (r2.method = "throw", r2.arg = new TypeError("The iterator does not provide a '" + n2 + "' method")), y;
        var i2 = tryCatch(o2, e2.iterator, r2.arg);
        if ("throw" === i2.type) return r2.method = "throw", r2.arg = i2.arg, r2.delegate = null, y;
        var a2 = i2.arg;
        return a2 ? a2.done ? (r2[e2.resultName] = a2.value, r2.next = e2.nextLoc, "return" !== r2.method && (r2.method = "next", r2.arg = t), r2.delegate = null, y) : a2 : (r2.method = "throw", r2.arg = new TypeError("iterator result is not an object"), r2.delegate = null, y);
      }
      function pushTryEntry(t2) {
        var e2 = { tryLoc: t2[0] };
        1 in t2 && (e2.catchLoc = t2[1]), 2 in t2 && (e2.finallyLoc = t2[2], e2.afterLoc = t2[3]), this.tryEntries.push(e2);
      }
      function resetTryEntry(t2) {
        var e2 = t2.completion || {};
        e2.type = "normal", delete e2.arg, t2.completion = e2;
      }
      function Context(t2) {
        this.tryEntries = [{ tryLoc: "root" }], t2.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e2) {
        if (e2 || "" === e2) {
          var r2 = e2[a];
          if (r2) return r2.call(e2);
          if ("function" == typeof e2.next) return e2;
          if (!isNaN(e2.length)) {
            var o2 = -1, i2 = function next() {
              for (; ++o2 < e2.length; ) if (n.call(e2, o2)) return next.value = e2[o2], next.done = false, next;
              return next.value = t, next.done = true, next;
            };
            return i2.next = i2;
          }
        }
        throw new TypeError(_typeof(e2) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: true }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true }), GeneratorFunction.displayName = define2(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function(t2) {
        var e2 = "function" == typeof t2 && t2.constructor;
        return !!e2 && (e2 === GeneratorFunction || "GeneratorFunction" === (e2.displayName || e2.name));
      }, e.mark = function(t2) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t2, GeneratorFunctionPrototype) : (t2.__proto__ = GeneratorFunctionPrototype, define2(t2, u, "GeneratorFunction")), t2.prototype = Object.create(g), t2;
      }, e.awrap = function(t2) {
        return { __await: t2 };
      }, defineIteratorMethods(AsyncIterator.prototype), define2(AsyncIterator.prototype, c, function() {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function(t2, r2, n2, o2, i2) {
        void 0 === i2 && (i2 = Promise);
        var a2 = new AsyncIterator(wrap(t2, r2, n2, o2), i2);
        return e.isGeneratorFunction(r2) ? a2 : a2.next().then(function(t3) {
          return t3.done ? t3.value : a2.next();
        });
      }, defineIteratorMethods(g), define2(g, u, "Generator"), define2(g, a, function() {
        return this;
      }), define2(g, "toString", function() {
        return "[object Generator]";
      }), e.keys = function(t2) {
        var e2 = Object(t2), r2 = [];
        for (var n2 in e2) r2.push(n2);
        return r2.reverse(), function next() {
          for (; r2.length; ) {
            var t3 = r2.pop();
            if (t3 in e2) return next.value = t3, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e2) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e2) for (var r2 in this) "t" === r2.charAt(0) && n.call(this, r2) && !isNaN(+r2.slice(1)) && (this[r2] = t);
      }, stop: function stop() {
        this.done = true;
        var t2 = this.tryEntries[0].completion;
        if ("throw" === t2.type) throw t2.arg;
        return this.rval;
      }, dispatchException: function dispatchException(e2) {
        if (this.done) throw e2;
        var r2 = this;
        function handle(n2, o3) {
          return a2.type = "throw", a2.arg = e2, r2.next = n2, o3 && (r2.method = "next", r2.arg = t), !!o3;
        }
        for (var o2 = this.tryEntries.length - 1; o2 >= 0; --o2) {
          var i2 = this.tryEntries[o2], a2 = i2.completion;
          if ("root" === i2.tryLoc) return handle("end");
          if (i2.tryLoc <= this.prev) {
            var c2 = n.call(i2, "catchLoc"), u2 = n.call(i2, "finallyLoc");
            if (c2 && u2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            } else if (c2) {
              if (this.prev < i2.catchLoc) return handle(i2.catchLoc, true);
            } else {
              if (!u2) throw Error("try statement without catch or finally");
              if (this.prev < i2.finallyLoc) return handle(i2.finallyLoc);
            }
          }
        }
      }, abrupt: function abrupt(t2, e2) {
        for (var r2 = this.tryEntries.length - 1; r2 >= 0; --r2) {
          var o2 = this.tryEntries[r2];
          if (o2.tryLoc <= this.prev && n.call(o2, "finallyLoc") && this.prev < o2.finallyLoc) {
            var i2 = o2;
            break;
          }
        }
        i2 && ("break" === t2 || "continue" === t2) && i2.tryLoc <= e2 && e2 <= i2.finallyLoc && (i2 = null);
        var a2 = i2 ? i2.completion : {};
        return a2.type = t2, a2.arg = e2, i2 ? (this.method = "next", this.next = i2.finallyLoc, y) : this.complete(a2);
      }, complete: function complete(t2, e2) {
        if ("throw" === t2.type) throw t2.arg;
        return "break" === t2.type || "continue" === t2.type ? this.next = t2.arg : "return" === t2.type ? (this.rval = this.arg = t2.arg, this.method = "return", this.next = "end") : "normal" === t2.type && e2 && (this.next = e2), y;
      }, finish: function finish(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.finallyLoc === t2) return this.complete(r2.completion, r2.afterLoc), resetTryEntry(r2), y;
        }
      }, catch: function _catch(t2) {
        for (var e2 = this.tryEntries.length - 1; e2 >= 0; --e2) {
          var r2 = this.tryEntries[e2];
          if (r2.tryLoc === t2) {
            var n2 = r2.completion;
            if ("throw" === n2.type) {
              var o2 = n2.arg;
              resetTryEntry(r2);
            }
            return o2;
          }
        }
        throw Error("illegal catch attempt");
      }, delegateYield: function delegateYield(e2, r2, n2) {
        return this.delegate = { iterator: values(e2), resultName: r2, nextLoc: n2 }, "next" === this.method && (this.arg = t), y;
      } }, e;
    }
    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c), u = i.value;
      } catch (n2) {
        return void e(n2);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function() {
        var t = this, e = arguments;
        return new Promise(function(r, o) {
          var a = n.apply(t, e);
          function _next(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n2);
          }
          function _throw(n2) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n2);
          }
          _next(void 0);
        });
      };
    }
    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: false }), e;
    }
    function _toPropertyKey(t) {
      var i = _toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }
    function _toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var SUBMIT_TRANSACTION_TIMEOUT = exports.SUBMIT_TRANSACTION_TIMEOUT = 60 * 1e3;
    var Durability = exports.Durability = function(Durability2) {
      Durability2["Temporary"] = "temporary";
      Durability2["Persistent"] = "persistent";
      return Durability2;
    }({});
    var DEFAULT_GET_TRANSACTION_TIMEOUT = 30;
    var BasicSleepStrategy = exports.BasicSleepStrategy = function BasicSleepStrategy2(_iter) {
      return 1e3;
    };
    var LinearSleepStrategy = exports.LinearSleepStrategy = function LinearSleepStrategy2(iter) {
      return 1e3 * iter;
    };
    function findCreatedAccountSequenceInTransactionMeta(meta) {
      var _operations$flatMap$f;
      var operations = [];
      switch (meta.switch()) {
        case 0:
          operations = meta.operations();
          break;
        case 1:
        case 2:
        case 3:
          operations = meta.value().operations();
          break;
        default:
          throw new Error("Unexpected transaction meta switch value");
      }
      var sequenceNumber = (_operations$flatMap$f = operations.flatMap(function(op) {
        return op.changes();
      }).find(function(c) {
        return c.switch() === _stellarBase.xdr.LedgerEntryChangeType.ledgerEntryCreated() && c.created().data().switch() === _stellarBase.xdr.LedgerEntryType.account();
      })) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.created()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.data()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.account()) === null || _operations$flatMap$f === void 0 || (_operations$flatMap$f = _operations$flatMap$f.seqNum()) === null || _operations$flatMap$f === void 0 ? void 0 : _operations$flatMap$f.toString();
      if (sequenceNumber) {
        return sequenceNumber;
      }
      throw new Error("No account created in transaction");
    }
    var RpcServer = exports.RpcServer = function() {
      function RpcServer2(serverURL) {
        var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        _classCallCheck(this, RpcServer2);
        this.serverURL = (0, _urijs.default)(serverURL);
        if (opts.headers && Object.keys(opts.headers).length !== 0) {
          _axios.default.interceptors.request.use(function(config) {
            config.headers = Object.assign(config.headers, opts.headers);
            return config;
          });
        }
        if (this.serverURL.protocol() !== "https" && !opts.allowHttp) {
          throw new Error("Cannot connect to insecure Soroban RPC server if `allowHttp` isn't set");
        }
      }
      return _createClass(RpcServer2, [{
        key: "getAccount",
        value: function() {
          var _getAccount = _asyncToGenerator(_regeneratorRuntime().mark(function _callee(address) {
            var ledgerKey, resp, accountEntry;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  ledgerKey = _stellarBase.xdr.LedgerKey.account(new _stellarBase.xdr.LedgerKeyAccount({
                    accountId: _stellarBase.Keypair.fromPublicKey(address).xdrPublicKey()
                  }));
                  _context.next = 3;
                  return this.getLedgerEntries(ledgerKey);
                case 3:
                  resp = _context.sent;
                  if (!(resp.entries.length === 0)) {
                    _context.next = 6;
                    break;
                  }
                  return _context.abrupt("return", Promise.reject({
                    code: 404,
                    message: "Account not found: ".concat(address)
                  }));
                case 6:
                  accountEntry = resp.entries[0].val.account();
                  return _context.abrupt("return", new _stellarBase.Account(address, accountEntry.seqNum().toString()));
                case 8:
                case "end":
                  return _context.stop();
              }
            }, _callee, this);
          }));
          function getAccount(_x) {
            return _getAccount.apply(this, arguments);
          }
          return getAccount;
        }()
      }, {
        key: "getHealth",
        value: function() {
          var _getHealth = _asyncToGenerator(_regeneratorRuntime().mark(function _callee2() {
            return _regeneratorRuntime().wrap(function _callee2$(_context2) {
              while (1) switch (_context2.prev = _context2.next) {
                case 0:
                  return _context2.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getHealth"));
                case 1:
                case "end":
                  return _context2.stop();
              }
            }, _callee2, this);
          }));
          function getHealth() {
            return _getHealth.apply(this, arguments);
          }
          return getHealth;
        }()
      }, {
        key: "getContractData",
        value: function() {
          var _getContractData = _asyncToGenerator(_regeneratorRuntime().mark(function _callee3(contract, key) {
            var durability, scAddress, xdrDurability, contractKey, _args3 = arguments;
            return _regeneratorRuntime().wrap(function _callee3$(_context3) {
              while (1) switch (_context3.prev = _context3.next) {
                case 0:
                  durability = _args3.length > 2 && _args3[2] !== void 0 ? _args3[2] : Durability.Persistent;
                  if (!(typeof contract === "string")) {
                    _context3.next = 5;
                    break;
                  }
                  scAddress = new _stellarBase.Contract(contract).address().toScAddress();
                  _context3.next = 14;
                  break;
                case 5:
                  if (!(contract instanceof _stellarBase.Address)) {
                    _context3.next = 9;
                    break;
                  }
                  scAddress = contract.toScAddress();
                  _context3.next = 14;
                  break;
                case 9:
                  if (!(contract instanceof _stellarBase.Contract)) {
                    _context3.next = 13;
                    break;
                  }
                  scAddress = contract.address().toScAddress();
                  _context3.next = 14;
                  break;
                case 13:
                  throw new TypeError("unknown contract type: ".concat(contract));
                case 14:
                  _context3.t0 = durability;
                  _context3.next = _context3.t0 === Durability.Temporary ? 17 : _context3.t0 === Durability.Persistent ? 19 : 21;
                  break;
                case 17:
                  xdrDurability = _stellarBase.xdr.ContractDataDurability.temporary();
                  return _context3.abrupt("break", 22);
                case 19:
                  xdrDurability = _stellarBase.xdr.ContractDataDurability.persistent();
                  return _context3.abrupt("break", 22);
                case 21:
                  throw new TypeError("invalid durability: ".concat(durability));
                case 22:
                  contractKey = _stellarBase.xdr.LedgerKey.contractData(new _stellarBase.xdr.LedgerKeyContractData({
                    key,
                    contract: scAddress,
                    durability: xdrDurability
                  }));
                  return _context3.abrupt("return", this.getLedgerEntries(contractKey).then(function(r) {
                    if (r.entries.length === 0) {
                      return Promise.reject({
                        code: 404,
                        message: "Contract data not found. Contract: ".concat(_stellarBase.Address.fromScAddress(scAddress).toString(), ", Key: ").concat(key.toXDR("base64"), ", Durability: ").concat(durability)
                      });
                    }
                    return r.entries[0];
                  }));
                case 24:
                case "end":
                  return _context3.stop();
              }
            }, _callee3, this);
          }));
          function getContractData(_x2, _x3) {
            return _getContractData.apply(this, arguments);
          }
          return getContractData;
        }()
      }, {
        key: "getContractWasmByContractId",
        value: function() {
          var _getContractWasmByContractId = _asyncToGenerator(_regeneratorRuntime().mark(function _callee4(contractId) {
            var _response$entries$;
            var contractLedgerKey, response, wasmHash;
            return _regeneratorRuntime().wrap(function _callee4$(_context4) {
              while (1) switch (_context4.prev = _context4.next) {
                case 0:
                  contractLedgerKey = new _stellarBase.Contract(contractId).getFootprint();
                  _context4.next = 3;
                  return this.getLedgerEntries(contractLedgerKey);
                case 3:
                  response = _context4.sent;
                  if (!(!response.entries.length || !((_response$entries$ = response.entries[0]) !== null && _response$entries$ !== void 0 && _response$entries$.val))) {
                    _context4.next = 6;
                    break;
                  }
                  return _context4.abrupt("return", Promise.reject({
                    code: 404,
                    message: "Could not obtain contract hash from server"
                  }));
                case 6:
                  wasmHash = response.entries[0].val.contractData().val().instance().executable().wasmHash();
                  return _context4.abrupt("return", this.getContractWasmByHash(wasmHash));
                case 8:
                case "end":
                  return _context4.stop();
              }
            }, _callee4, this);
          }));
          function getContractWasmByContractId(_x4) {
            return _getContractWasmByContractId.apply(this, arguments);
          }
          return getContractWasmByContractId;
        }()
      }, {
        key: "getContractWasmByHash",
        value: function() {
          var _getContractWasmByHash = _asyncToGenerator(_regeneratorRuntime().mark(function _callee5(wasmHash) {
            var _responseWasm$entries;
            var format, wasmHashBuffer, ledgerKeyWasmHash, responseWasm, wasmBuffer, _args5 = arguments;
            return _regeneratorRuntime().wrap(function _callee5$(_context5) {
              while (1) switch (_context5.prev = _context5.next) {
                case 0:
                  format = _args5.length > 1 && _args5[1] !== void 0 ? _args5[1] : void 0;
                  wasmHashBuffer = typeof wasmHash === "string" ? Buffer.from(wasmHash, format) : wasmHash;
                  ledgerKeyWasmHash = _stellarBase.xdr.LedgerKey.contractCode(new _stellarBase.xdr.LedgerKeyContractCode({
                    hash: wasmHashBuffer
                  }));
                  _context5.next = 5;
                  return this.getLedgerEntries(ledgerKeyWasmHash);
                case 5:
                  responseWasm = _context5.sent;
                  if (!(!responseWasm.entries.length || !((_responseWasm$entries = responseWasm.entries[0]) !== null && _responseWasm$entries !== void 0 && _responseWasm$entries.val))) {
                    _context5.next = 8;
                    break;
                  }
                  return _context5.abrupt("return", Promise.reject({
                    code: 404,
                    message: "Could not obtain contract wasm from server"
                  }));
                case 8:
                  wasmBuffer = responseWasm.entries[0].val.contractCode().code();
                  return _context5.abrupt("return", wasmBuffer);
                case 10:
                case "end":
                  return _context5.stop();
              }
            }, _callee5, this);
          }));
          function getContractWasmByHash(_x5) {
            return _getContractWasmByHash.apply(this, arguments);
          }
          return getContractWasmByHash;
        }()
      }, {
        key: "getLedgerEntries",
        value: function() {
          var _getLedgerEntries2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee6() {
            var _args6 = arguments;
            return _regeneratorRuntime().wrap(function _callee6$(_context6) {
              while (1) switch (_context6.prev = _context6.next) {
                case 0:
                  return _context6.abrupt("return", this._getLedgerEntries.apply(this, _args6).then(_parsers.parseRawLedgerEntries));
                case 1:
                case "end":
                  return _context6.stop();
              }
            }, _callee6, this);
          }));
          function getLedgerEntries() {
            return _getLedgerEntries2.apply(this, arguments);
          }
          return getLedgerEntries;
        }()
      }, {
        key: "_getLedgerEntries",
        value: function() {
          var _getLedgerEntries3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee7() {
            var _len, keys, _key, _args7 = arguments;
            return _regeneratorRuntime().wrap(function _callee7$(_context7) {
              while (1) switch (_context7.prev = _context7.next) {
                case 0:
                  for (_len = _args7.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
                    keys[_key] = _args7[_key];
                  }
                  return _context7.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getLedgerEntries", {
                    keys: keys.map(function(k) {
                      return k.toXDR("base64");
                    })
                  }));
                case 2:
                case "end":
                  return _context7.stop();
              }
            }, _callee7, this);
          }));
          function _getLedgerEntries() {
            return _getLedgerEntries3.apply(this, arguments);
          }
          return _getLedgerEntries;
        }()
      }, {
        key: "pollTransaction",
        value: function() {
          var _pollTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee8(hash, opts) {
            var _opts$attempts, _opts$attempts2;
            var maxAttempts, foundInfo, attempt, _opts$sleepStrategy;
            return _regeneratorRuntime().wrap(function _callee8$(_context8) {
              while (1) switch (_context8.prev = _context8.next) {
                case 0:
                  maxAttempts = ((_opts$attempts = opts === null || opts === void 0 ? void 0 : opts.attempts) !== null && _opts$attempts !== void 0 ? _opts$attempts : 0) < 1 ? DEFAULT_GET_TRANSACTION_TIMEOUT : (_opts$attempts2 = opts === null || opts === void 0 ? void 0 : opts.attempts) !== null && _opts$attempts2 !== void 0 ? _opts$attempts2 : DEFAULT_GET_TRANSACTION_TIMEOUT;
                  attempt = 1;
                case 2:
                  if (!(attempt < maxAttempts)) {
                    _context8.next = 13;
                    break;
                  }
                  _context8.next = 5;
                  return this.getTransaction(hash);
                case 5:
                  foundInfo = _context8.sent;
                  if (!(foundInfo.status !== _api.Api.GetTransactionStatus.NOT_FOUND)) {
                    _context8.next = 8;
                    break;
                  }
                  return _context8.abrupt("return", foundInfo);
                case 8:
                  _context8.next = 10;
                  return _utils.Utils.sleep(((_opts$sleepStrategy = opts === null || opts === void 0 ? void 0 : opts.sleepStrategy) !== null && _opts$sleepStrategy !== void 0 ? _opts$sleepStrategy : BasicSleepStrategy)(attempt));
                case 10:
                  attempt++;
                  _context8.next = 2;
                  break;
                case 13:
                  return _context8.abrupt("return", foundInfo);
                case 14:
                case "end":
                  return _context8.stop();
              }
            }, _callee8, this);
          }));
          function pollTransaction(_x6, _x7) {
            return _pollTransaction.apply(this, arguments);
          }
          return pollTransaction;
        }()
      }, {
        key: "getTransaction",
        value: function() {
          var _getTransaction2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee9(hash) {
            return _regeneratorRuntime().wrap(function _callee9$(_context9) {
              while (1) switch (_context9.prev = _context9.next) {
                case 0:
                  return _context9.abrupt("return", this._getTransaction(hash).then(function(raw) {
                    var foundInfo = {};
                    if (raw.status !== _api.Api.GetTransactionStatus.NOT_FOUND) {
                      Object.assign(foundInfo, (0, _parsers.parseTransactionInfo)(raw));
                    }
                    var result = _objectSpread({
                      status: raw.status,
                      txHash: hash,
                      latestLedger: raw.latestLedger,
                      latestLedgerCloseTime: raw.latestLedgerCloseTime,
                      oldestLedger: raw.oldestLedger,
                      oldestLedgerCloseTime: raw.oldestLedgerCloseTime
                    }, foundInfo);
                    return result;
                  }));
                case 1:
                case "end":
                  return _context9.stop();
              }
            }, _callee9, this);
          }));
          function getTransaction(_x8) {
            return _getTransaction2.apply(this, arguments);
          }
          return getTransaction;
        }()
      }, {
        key: "_getTransaction",
        value: function() {
          var _getTransaction3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee10(hash) {
            return _regeneratorRuntime().wrap(function _callee10$(_context10) {
              while (1) switch (_context10.prev = _context10.next) {
                case 0:
                  return _context10.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getTransaction", {
                    hash
                  }));
                case 1:
                case "end":
                  return _context10.stop();
              }
            }, _callee10, this);
          }));
          function _getTransaction(_x9) {
            return _getTransaction3.apply(this, arguments);
          }
          return _getTransaction;
        }()
      }, {
        key: "getTransactions",
        value: function() {
          var _getTransactions2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee11(request) {
            return _regeneratorRuntime().wrap(function _callee11$(_context11) {
              while (1) switch (_context11.prev = _context11.next) {
                case 0:
                  return _context11.abrupt("return", this._getTransactions(request).then(function(raw) {
                    var result = {
                      transactions: (raw.transactions || []).map(_parsers.parseRawTransactions),
                      latestLedger: raw.latestLedger,
                      latestLedgerCloseTimestamp: raw.latestLedgerCloseTimestamp,
                      oldestLedger: raw.oldestLedger,
                      oldestLedgerCloseTimestamp: raw.oldestLedgerCloseTimestamp,
                      cursor: raw.cursor
                    };
                    return result;
                  }));
                case 1:
                case "end":
                  return _context11.stop();
              }
            }, _callee11, this);
          }));
          function getTransactions(_x10) {
            return _getTransactions2.apply(this, arguments);
          }
          return getTransactions;
        }()
      }, {
        key: "_getTransactions",
        value: function() {
          var _getTransactions3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee12(request) {
            return _regeneratorRuntime().wrap(function _callee12$(_context12) {
              while (1) switch (_context12.prev = _context12.next) {
                case 0:
                  return _context12.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getTransactions", request));
                case 1:
                case "end":
                  return _context12.stop();
              }
            }, _callee12, this);
          }));
          function _getTransactions(_x11) {
            return _getTransactions3.apply(this, arguments);
          }
          return _getTransactions;
        }()
      }, {
        key: "getEvents",
        value: function() {
          var _getEvents2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee13(request) {
            return _regeneratorRuntime().wrap(function _callee13$(_context13) {
              while (1) switch (_context13.prev = _context13.next) {
                case 0:
                  return _context13.abrupt("return", this._getEvents(request).then(_parsers.parseRawEvents));
                case 1:
                case "end":
                  return _context13.stop();
              }
            }, _callee13, this);
          }));
          function getEvents(_x12) {
            return _getEvents2.apply(this, arguments);
          }
          return getEvents;
        }()
      }, {
        key: "_getEvents",
        value: function() {
          var _getEvents3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee14(request) {
            var _request$filters;
            return _regeneratorRuntime().wrap(function _callee14$(_context14) {
              while (1) switch (_context14.prev = _context14.next) {
                case 0:
                  return _context14.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getEvents", _objectSpread(_objectSpread({
                    filters: (_request$filters = request.filters) !== null && _request$filters !== void 0 ? _request$filters : [],
                    pagination: _objectSpread(_objectSpread({}, request.cursor && {
                      cursor: request.cursor
                    }), request.limit && {
                      limit: request.limit
                    })
                  }, request.startLedger && {
                    startLedger: request.startLedger
                  }), request.endLedger && {
                    endLedger: request.endLedger
                  })));
                case 1:
                case "end":
                  return _context14.stop();
              }
            }, _callee14, this);
          }));
          function _getEvents(_x13) {
            return _getEvents3.apply(this, arguments);
          }
          return _getEvents;
        }()
      }, {
        key: "getNetwork",
        value: function() {
          var _getNetwork = _asyncToGenerator(_regeneratorRuntime().mark(function _callee15() {
            return _regeneratorRuntime().wrap(function _callee15$(_context15) {
              while (1) switch (_context15.prev = _context15.next) {
                case 0:
                  return _context15.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getNetwork"));
                case 1:
                case "end":
                  return _context15.stop();
              }
            }, _callee15, this);
          }));
          function getNetwork() {
            return _getNetwork.apply(this, arguments);
          }
          return getNetwork;
        }()
      }, {
        key: "getLatestLedger",
        value: function() {
          var _getLatestLedger = _asyncToGenerator(_regeneratorRuntime().mark(function _callee16() {
            return _regeneratorRuntime().wrap(function _callee16$(_context16) {
              while (1) switch (_context16.prev = _context16.next) {
                case 0:
                  return _context16.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getLatestLedger"));
                case 1:
                case "end":
                  return _context16.stop();
              }
            }, _callee16, this);
          }));
          function getLatestLedger() {
            return _getLatestLedger.apply(this, arguments);
          }
          return getLatestLedger;
        }()
      }, {
        key: "simulateTransaction",
        value: function() {
          var _simulateTransaction2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee17(tx, addlResources) {
            return _regeneratorRuntime().wrap(function _callee17$(_context17) {
              while (1) switch (_context17.prev = _context17.next) {
                case 0:
                  return _context17.abrupt("return", this._simulateTransaction(tx, addlResources).then(_parsers.parseRawSimulation));
                case 1:
                case "end":
                  return _context17.stop();
              }
            }, _callee17, this);
          }));
          function simulateTransaction(_x14, _x15) {
            return _simulateTransaction2.apply(this, arguments);
          }
          return simulateTransaction;
        }()
      }, {
        key: "_simulateTransaction",
        value: function() {
          var _simulateTransaction3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee18(transaction, addlResources) {
            return _regeneratorRuntime().wrap(function _callee18$(_context18) {
              while (1) switch (_context18.prev = _context18.next) {
                case 0:
                  return _context18.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "simulateTransaction", _objectSpread({
                    transaction: transaction.toXDR()
                  }, addlResources !== void 0 && {
                    resourceConfig: {
                      instructionLeeway: addlResources.cpuInstructions
                    }
                  })));
                case 1:
                case "end":
                  return _context18.stop();
              }
            }, _callee18, this);
          }));
          function _simulateTransaction(_x16, _x17) {
            return _simulateTransaction3.apply(this, arguments);
          }
          return _simulateTransaction;
        }()
      }, {
        key: "prepareTransaction",
        value: function() {
          var _prepareTransaction = _asyncToGenerator(_regeneratorRuntime().mark(function _callee19(tx) {
            var simResponse;
            return _regeneratorRuntime().wrap(function _callee19$(_context19) {
              while (1) switch (_context19.prev = _context19.next) {
                case 0:
                  _context19.next = 2;
                  return this.simulateTransaction(tx);
                case 2:
                  simResponse = _context19.sent;
                  if (!_api.Api.isSimulationError(simResponse)) {
                    _context19.next = 5;
                    break;
                  }
                  throw new Error(simResponse.error);
                case 5:
                  return _context19.abrupt("return", (0, _transaction.assembleTransaction)(tx, simResponse).build());
                case 6:
                case "end":
                  return _context19.stop();
              }
            }, _callee19, this);
          }));
          function prepareTransaction(_x18) {
            return _prepareTransaction.apply(this, arguments);
          }
          return prepareTransaction;
        }()
      }, {
        key: "sendTransaction",
        value: function() {
          var _sendTransaction2 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee20(transaction) {
            return _regeneratorRuntime().wrap(function _callee20$(_context20) {
              while (1) switch (_context20.prev = _context20.next) {
                case 0:
                  return _context20.abrupt("return", this._sendTransaction(transaction).then(_parsers.parseRawSendTransaction));
                case 1:
                case "end":
                  return _context20.stop();
              }
            }, _callee20, this);
          }));
          function sendTransaction(_x19) {
            return _sendTransaction2.apply(this, arguments);
          }
          return sendTransaction;
        }()
      }, {
        key: "_sendTransaction",
        value: function() {
          var _sendTransaction3 = _asyncToGenerator(_regeneratorRuntime().mark(function _callee21(transaction) {
            return _regeneratorRuntime().wrap(function _callee21$(_context21) {
              while (1) switch (_context21.prev = _context21.next) {
                case 0:
                  return _context21.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "sendTransaction", {
                    transaction: transaction.toXDR()
                  }));
                case 1:
                case "end":
                  return _context21.stop();
              }
            }, _callee21, this);
          }));
          function _sendTransaction(_x20) {
            return _sendTransaction3.apply(this, arguments);
          }
          return _sendTransaction;
        }()
      }, {
        key: "requestAirdrop",
        value: function() {
          var _requestAirdrop = _asyncToGenerator(_regeneratorRuntime().mark(function _callee22(address, friendbotUrl) {
            var account, response, meta, txMeta, sequence, _error$response, _error$response$detai;
            return _regeneratorRuntime().wrap(function _callee22$(_context22) {
              while (1) switch (_context22.prev = _context22.next) {
                case 0:
                  account = typeof address === "string" ? address : address.accountId();
                  _context22.t0 = friendbotUrl;
                  if (_context22.t0) {
                    _context22.next = 6;
                    break;
                  }
                  _context22.next = 5;
                  return this.getNetwork();
                case 5:
                  _context22.t0 = _context22.sent.friendbotUrl;
                case 6:
                  friendbotUrl = _context22.t0;
                  if (friendbotUrl) {
                    _context22.next = 9;
                    break;
                  }
                  throw new Error("No friendbot URL configured for current network");
                case 9:
                  _context22.prev = 9;
                  _context22.next = 12;
                  return _axios.default.post("".concat(friendbotUrl, "?addr=").concat(encodeURIComponent(account)));
                case 12:
                  response = _context22.sent;
                  if (response.data.result_meta_xdr) {
                    _context22.next = 22;
                    break;
                  }
                  _context22.next = 16;
                  return this.getTransaction(response.data.hash);
                case 16:
                  txMeta = _context22.sent;
                  if (!(txMeta.status !== _api.Api.GetTransactionStatus.SUCCESS)) {
                    _context22.next = 19;
                    break;
                  }
                  throw new Error("Funding account ".concat(address, " failed"));
                case 19:
                  meta = txMeta.resultMetaXdr;
                  _context22.next = 23;
                  break;
                case 22:
                  meta = _stellarBase.xdr.TransactionMeta.fromXDR(response.data.result_meta_xdr, "base64");
                case 23:
                  sequence = findCreatedAccountSequenceInTransactionMeta(meta);
                  return _context22.abrupt("return", new _stellarBase.Account(account, sequence));
                case 27:
                  _context22.prev = 27;
                  _context22.t1 = _context22["catch"](9);
                  if (!(((_error$response = _context22.t1.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 400)) {
                    _context22.next = 32;
                    break;
                  }
                  if (!((_error$response$detai = _context22.t1.response.detail) !== null && _error$response$detai !== void 0 && _error$response$detai.includes("createAccountAlreadyExist"))) {
                    _context22.next = 32;
                    break;
                  }
                  return _context22.abrupt("return", this.getAccount(account));
                case 32:
                  throw _context22.t1;
                case 33:
                case "end":
                  return _context22.stop();
              }
            }, _callee22, this, [[9, 27]]);
          }));
          function requestAirdrop(_x21, _x22) {
            return _requestAirdrop.apply(this, arguments);
          }
          return requestAirdrop;
        }()
      }, {
        key: "getFeeStats",
        value: function() {
          var _getFeeStats = _asyncToGenerator(_regeneratorRuntime().mark(function _callee23() {
            return _regeneratorRuntime().wrap(function _callee23$(_context23) {
              while (1) switch (_context23.prev = _context23.next) {
                case 0:
                  return _context23.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getFeeStats"));
                case 1:
                case "end":
                  return _context23.stop();
              }
            }, _callee23, this);
          }));
          function getFeeStats() {
            return _getFeeStats.apply(this, arguments);
          }
          return getFeeStats;
        }()
      }, {
        key: "getVersionInfo",
        value: function() {
          var _getVersionInfo = _asyncToGenerator(_regeneratorRuntime().mark(function _callee24() {
            return _regeneratorRuntime().wrap(function _callee24$(_context24) {
              while (1) switch (_context24.prev = _context24.next) {
                case 0:
                  return _context24.abrupt("return", jsonrpc.postObject(this.serverURL.toString(), "getVersionInfo"));
                case 1:
                case "end":
                  return _context24.stop();
              }
            }, _callee24, this);
          }));
          function getVersionInfo() {
            return _getVersionInfo.apply(this, arguments);
          }
          return getVersionInfo;
        }()
      }, {
        key: "getSACBalance",
        value: function() {
          var _getSACBalance = _asyncToGenerator(_regeneratorRuntime().mark(function _callee25(contractId, sac, networkPassphrase) {
            var passphrase, sacId, key, ledgerKey, response, _response$entries$2, lastModifiedLedgerSeq, liveUntilLedgerSeq, val, entry;
            return _regeneratorRuntime().wrap(function _callee25$(_context25) {
              while (1) switch (_context25.prev = _context25.next) {
                case 0:
                  if (_stellarBase.StrKey.isValidContract(contractId)) {
                    _context25.next = 2;
                    break;
                  }
                  throw new TypeError("expected contract ID, got ".concat(contractId));
                case 2:
                  if (!(networkPassphrase !== null && networkPassphrase !== void 0)) {
                    _context25.next = 6;
                    break;
                  }
                  _context25.t0 = networkPassphrase;
                  _context25.next = 9;
                  break;
                case 6:
                  _context25.next = 8;
                  return this.getNetwork().then(function(n) {
                    return n.passphrase;
                  });
                case 8:
                  _context25.t0 = _context25.sent;
                case 9:
                  passphrase = _context25.t0;
                  sacId = sac.contractId(passphrase);
                  key = _stellarBase.xdr.ScVal.scvVec([(0, _stellarBase.nativeToScVal)("Balance", {
                    type: "symbol"
                  }), (0, _stellarBase.nativeToScVal)(contractId, {
                    type: "address"
                  })]);
                  ledgerKey = _stellarBase.xdr.LedgerKey.contractData(new _stellarBase.xdr.LedgerKeyContractData({
                    contract: new _stellarBase.Address(sacId).toScAddress(),
                    durability: _stellarBase.xdr.ContractDataDurability.persistent(),
                    key
                  }));
                  _context25.next = 15;
                  return this.getLedgerEntries(ledgerKey);
                case 15:
                  response = _context25.sent;
                  if (!(response.entries.length === 0)) {
                    _context25.next = 18;
                    break;
                  }
                  return _context25.abrupt("return", {
                    latestLedger: response.latestLedger
                  });
                case 18:
                  _response$entries$2 = response.entries[0], lastModifiedLedgerSeq = _response$entries$2.lastModifiedLedgerSeq, liveUntilLedgerSeq = _response$entries$2.liveUntilLedgerSeq, val = _response$entries$2.val;
                  if (!(val.switch().value !== _stellarBase.xdr.LedgerEntryType.contractData().value)) {
                    _context25.next = 21;
                    break;
                  }
                  return _context25.abrupt("return", {
                    latestLedger: response.latestLedger
                  });
                case 21:
                  entry = (0, _stellarBase.scValToNative)(val.contractData().val());
                  return _context25.abrupt("return", {
                    latestLedger: response.latestLedger,
                    balanceEntry: {
                      liveUntilLedgerSeq,
                      lastModifiedLedgerSeq,
                      amount: entry.amount.toString(),
                      authorized: entry.authorized,
                      clawback: entry.clawback
                    }
                  });
                case 23:
                case "end":
                  return _context25.stop();
              }
            }, _callee25, this);
          }));
          function getSACBalance(_x23, _x24, _x25) {
            return _getSACBalance.apply(this, arguments);
          }
          return getSACBalance;
        }()
      }]);
    }();
  }
});

// node_modules/@stellar/stellar-sdk/lib/rpc/index.js
var require_rpc = __commonJS({
  "node_modules/@stellar/stellar-sdk/lib/rpc/index.js"(exports, module) {
    var import_dist = __toESM(require_dist());
    var import_dist2 = __toESM(require_dist2());
    var import_dist3 = __toESM(require_dist3());
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _exportNames = {
      Server: true,
      BasicSleepStrategy: true,
      LinearSleepStrategy: true,
      Durability: true,
      AxiosClient: true,
      parseRawSimulation: true,
      parseRawEvents: true
    };
    Object.defineProperty(exports, "AxiosClient", {
      enumerable: true,
      get: function get() {
        return _axios.default;
      }
    });
    Object.defineProperty(exports, "BasicSleepStrategy", {
      enumerable: true,
      get: function get() {
        return _server.BasicSleepStrategy;
      }
    });
    Object.defineProperty(exports, "Durability", {
      enumerable: true,
      get: function get() {
        return _server.Durability;
      }
    });
    Object.defineProperty(exports, "LinearSleepStrategy", {
      enumerable: true,
      get: function get() {
        return _server.LinearSleepStrategy;
      }
    });
    Object.defineProperty(exports, "Server", {
      enumerable: true,
      get: function get() {
        return _server.RpcServer;
      }
    });
    exports.default = void 0;
    Object.defineProperty(exports, "parseRawEvents", {
      enumerable: true,
      get: function get() {
        return _parsers.parseRawEvents;
      }
    });
    Object.defineProperty(exports, "parseRawSimulation", {
      enumerable: true,
      get: function get() {
        return _parsers.parseRawSimulation;
      }
    });
    var _api = require_api();
    Object.keys(_api).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _api[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _api[key];
        }
      });
    });
    var _server = require_server();
    var _axios = _interopRequireDefault(require_axios2());
    var _parsers = require_parsers();
    var _transaction = require_transaction2();
    Object.keys(_transaction).forEach(function(key) {
      if (key === "default" || key === "__esModule") return;
      if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
      if (key in exports && exports[key] === _transaction[key]) return;
      Object.defineProperty(exports, key, {
        enumerable: true,
        get: function get() {
          return _transaction[key];
        }
      });
    });
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    var _default = exports.default = module.exports;
  }
});

export {
  require_api,
  require_lib,
  require_transaction2 as require_transaction,
  require_rpc
};
/*! Bundled license information:

urijs/src/punycode.js:
  (*! https://mths.be/punycode v1.4.0 by @mathias *)

urijs/src/IPv6.js:
  (*!
   * URI.js - Mutating URLs
   * IPv6 Support
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

urijs/src/SecondLevelDomains.js:
  (*!
   * URI.js - Mutating URLs
   * Second Level Domain (SLD) Support
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

urijs/src/URI.js:
  (*!
   * URI.js - Mutating URLs
   *
   * Version: 1.19.11
   *
   * Author: Rodney Rehm
   * Web: http://medialize.github.io/URI.js/
   *
   * Licensed under
   *   MIT License http://www.opensource.org/licenses/mit-license
   *
   *)

@stellar/js-xdr/dist/xdr.js:
  (*! For license information please see xdr.js.LICENSE.txt *)

@stellar/stellar-base/lib/auth.js:
  (*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE *)

axios/dist/browser/axios.cjs:
  (*! Axios v1.11.0 Copyright (c) 2025 Matt Zabriskie and contributors *)
*/
//# sourceMappingURL=chunk-TD56FCTW.js.map
