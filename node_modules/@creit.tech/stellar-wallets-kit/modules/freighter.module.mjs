import { isConnected, requestAccess, getAddress, signTransaction, signAuthEntry, signMessage, getNetwork } from '@stellar/freighter-api';
import { ModuleType } from '../types.mjs';
import { parseError } from '../utils.mjs';
import { Buffer } from 'buffer';

const FREIGHTER_ID = "freighter";
class FreighterModule {
  constructor() {
    this.moduleType = ModuleType.HOT_WALLET;
    this.productId = FREIGHTER_ID;
    this.productName = "Freighter";
    this.productUrl = "https://freighter.app";
    this.productIcon = "https://stellar.creit.tech/wallet-icons/freighter.png";
  }
  async runChecks() {
    if (!await this.isAvailable()) {
      throw new Error("Freighter is not connected");
    }
  }
  async isAvailable() {
    return isConnected().then(({ isConnected: isConnected2, error }) => !error && isConnected2).catch(() => false);
  }
  async getAddress() {
    return this.runChecks().then(() => requestAccess()).then(() => getAddress()).then(({ address, error }) => {
      if (error) throw error;
      return { address };
    }).catch((e) => {
      throw parseError(e);
    });
  }
  async signTransaction(xdr, opts) {
    return this.runChecks().then(async () => {
      const { signedTxXdr, signerAddress, error } = await signTransaction(xdr, {
        address: opts?.address,
        networkPassphrase: opts?.networkPassphrase
      });
      if (error) throw error;
      return { signedTxXdr, signerAddress };
    }).catch((e) => {
      throw parseError(e);
    });
  }
  async signAuthEntry(authEntry, opts) {
    return this.runChecks().then(async () => {
      const { signedAuthEntry, signerAddress, error } = await signAuthEntry(authEntry, {
        address: opts?.address,
        networkPassphrase: opts?.networkPassphrase
      });
      if (error || !signedAuthEntry) throw error;
      return { signedAuthEntry: Buffer.from(signedAuthEntry).toString("base64"), signerAddress };
    }).catch((e) => {
      throw parseError(e);
    });
  }
  async signMessage(message, opts) {
    return this.runChecks().then(async () => {
      const { signedMessage, signerAddress, error } = await signMessage(message, {
        address: opts?.address,
        networkPassphrase: opts?.networkPassphrase
      });
      if (error || !signedMessage) throw error;
      return { signedMessage: Buffer.from(signedMessage).toString("base64"), signerAddress };
    }).catch((e) => {
      throw parseError(e);
    });
  }
  async getNetwork() {
    return this.runChecks().then(async () => {
      const { network, networkPassphrase, error } = await getNetwork();
      if (error) throw error;
      return { network, networkPassphrase };
    }).catch((e) => {
      throw parseError(e);
    });
  }
}

export { FREIGHTER_ID, FreighterModule };
//# sourceMappingURL=freighter.module.mjs.map
